<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mech_Mind&#39;s blog</title>
  
  <subtitle>Proletoj el ĉiuj landoj, unuiĝu!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mechanicalmind.cn/"/>
  <updated>2020-06-17T15:12:08.000Z</updated>
  <id>http://mechanicalmind.cn/</id>
  
  <author>
    <name>Mechanical_Mind</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux文件系统</title>
    <link href="http://mechanicalmind.cn/posts/e0738fea.html"/>
    <id>http://mechanicalmind.cn/posts/e0738fea.html</id>
    <published>2020-06-17T15:12:03.000Z</published>
    <updated>2020-06-17T15:12:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center></center><a id="more"></a><h1 id="基础">基础</h1><p>在Linux系统中，打开文件就会获得文件描述符，它是一个很小的非负整数int fd，Linux内核在打开文件时分配一个文件对象，文件描述符指向内核中的文件描述符表元素，此元素再指向文件对象；每个进程启动后至少分配3个文件描述符：标准输入、标准输出、标准错误，文件描述符依次为0,1,2，定义于unistd.h。</p><p>I/O相关的函数有系统调用和C语言库函数之分（C语言编程时系统调用和库函数都以C函数的形式出现）：</p><ul><li>系统调用：<ul><li>Linux内核的对外接口</li><li>用户程序与内核之间的唯一接口</li><li>提供最小接口</li><li>主要是open/create，close，read，write，lseek（移动读写位置），fcntl（改变已打开的文件性质）</li></ul></li><li>库函数<ul><li>依赖于系统调用</li><li>提供带缓冲区的较复杂功能</li><li>例如标准I/O库</li></ul></li></ul><h1 id="系统调用">系统调用</h1><h2 id="opencreat">open/creat</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> falgs, <span class="keyword">mode_t</span> mode)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="comment">//return: a new file descriptor if success; -1 if failure</span></span></span></pre></td></tr></table></figure><ul><li>flags：文件权限</li><li>O_RDONLY，O_WRONLY，O_RDWR，即只读、只写、读/写； 还有O_CREAT表示如果不存在即创建文件；O_APPEND追加模式，O_TRUNC，O_EXCL</li><li>creat函数等价于open使用O_CREAT|O_WRONLY|O_TRUNC</li><li>mode：用于创建新文件的时指定访问（r,w,x）权限</li></ul><h2 id="close">close</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//return 0 if success, -1 if failure</span></span></pre></td></tr></table></figure><h2 id="readwrite">read/write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssized_t</span> <span class="built_in">read</span>(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//从fd对应的文件中读count个字节的数据到buf数组里，返回读到的字节数，若已到文件尾为0，若出错为1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">write</span>(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//从buf数组中读count个字节的数据写到fd对应的文件中，若成功返回已写的字节数，若出错为-1</span></span></pre></td></tr></table></figure><h1 id="标准io库函数">标准I/O库函数</h1><h2 id="文件流file">文件流（FILE *）</h2><p>流与FILE结构：FILE* fp；</p><p>预定义的指针：stdin,stdout,stderr；</p><p>缓冲IO：全缓冲、行缓冲、无缓冲；</p><p>库函数都是针对流，即FILE*结构进行的操作。</p><h2 id="fopenfclose">fopen/fclose</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="comment">//mode参数：r, w, a, r+, w+, a+分别表示读、写、追加、读和写、读写创建、读追加创建</span></span></span></pre></td></tr></table></figure><h2 id="freadfwrite">fread/fwrite</h2><h2 id="scanffscanf">scanf/fscanf</h2><h2 id="printffprintf">printf/fprintf</h2><h2 id="fflush">fflush</h2><p>刷新文件流，把流里的数据立刻写入文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">int fflush(FILE *stream);</span></pre></td></tr></table></figure><h1 id="写文件示例">写文件示例</h1><p>编写C程序，完成将键盘输入的一组整数递减排序后输出到指定的磁盘文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> cur, output;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a &gt; b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; cur)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        v.push_back(stoi(cur));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="built_in">cin</span>.get() == <span class="string">'\n'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    sort(v.begin(), v.end(), cmp);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = v.begin(); iter != v.end(); ++iter)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        output = output + to_string(*iter) + <span class="string">' '</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"./text.txt"</span>, O_RDWR | O_APPEND);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(output.c_str()) + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">strcpy</span>(buf, output.c_str());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    write(fd, buf, <span class="built_in">strlen</span>(buf));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    close(fd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>编写程序，可以将两个已排好序的数据文件归并到一个有序的结果文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> cur, output;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a &gt; b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readfile</span><span class="params">(<span class="built_in">string</span> file)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">string</span> input;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> *filename = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(file.c_str()) + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">strcpy</span>(filename, file.c_str());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> fd = open(filename, O_RDWR | O_APPEND);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> inbuf[<span class="number">100</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(inbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(inbuf));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (read(fd, inbuf, <span class="keyword">sizeof</span>(inbuf)) &gt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        input = input +inbuf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">memset</span>(inbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(inbuf));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    close(fd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(input)</span></span>; <span class="comment">//explicit construct</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; cur)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    v.push_back(stoi(cur)); <span class="comment">//add record</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    readfile(<span class="string">"sorted1.txt"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    readfile(<span class="string">"sorted2.txt"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    sort(v.begin(), v.end(), cmp);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = v.begin(); iter != v.end(); ++iter)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    output = output + to_string(*iter) + <span class="string">' '</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"./text.txt"</span>, O_RDWR | O_APPEND);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(output.c_str()) + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">strcpy</span>(buf, output.c_str());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    write(fd, buf, <span class="built_in">strlen</span>(buf));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    close(fd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h1 id="文件操作示例">文件操作示例</h1><p>编写一个程序（delDIR.c）,当执行 delDIR sub1 时可以将指定sub1目录下的所有为空的子目录删除：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *dir;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> cur_dir[] = <span class="string">"."</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> up_dir[] = <span class="string">".."</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> dir_name[<span class="number">128</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">DIR *dirp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dp</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">dir_stat</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    dirp = opendir(dir);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((dp = readdir(dirp)) != <span class="literal">NULL</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//忽略 . 和 ..目录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((<span class="number">0</span> == <span class="built_in">strcmp</span>(cur_dir, dp-&gt;d_name)) || (<span class="number">0</span> == <span class="built_in">strcmp</span>(up_dir, dp-&gt;d_name)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//如果一个文件是目录就执行rmdir</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">char</span> *tmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(dir) + <span class="built_in">strlen</span>(dp-&gt;d_name));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">"%s%s"</span>, dir, dp-&gt;d_name);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">tmp_stat</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        stat(tmp, &amp;tmp_stat);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (S_ISDIR(tmp_stat.st_mode))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            rmdir(tmp);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    closedir(dirp);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    dir = argv[<span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">//传进来的目录不存在</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != access(dir, F_OK))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        perror(<span class="string">"error:no such dir."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//获取目录属性失败</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; stat(dir, &amp;dir_stat))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        perror(<span class="string">"error:cannot get dir stat."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//传进来的是有效的目录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (S_ISDIR(dir_stat.st_mode))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"strat..."</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        del();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"done."</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        perror(<span class="string">"error:not a dir."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;/center&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://mechanicalmind.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux命令操作</title>
    <link href="http://mechanicalmind.cn/posts/67495bc7.html"/>
    <id>http://mechanicalmind.cn/posts/67495bc7.html</id>
    <published>2020-06-17T02:13:56.000Z</published>
    <updated>2020-06-17T02:13:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center></center><a id="more"></a><h1 id="重定向">重定向</h1><p>Linux重定向是指修改原来默认的一些东西，对原来系统命令的默认执行方式进行改变，比如说将原本会在显示器上显示的输出输出到某一文件中。</p><p>用<code>&lt;</code>来改变读进的数据信道（stdin），使之从指定的档案读进；用<code>&gt;</code>来改变送出的数据信道（stdout，stderr），使之输出到指定的档案；</p><p>0是<code>&lt;</code>的默认值，因此<code>&lt;</code>与<code>0&lt;</code>是一样的；同理，<code>&gt;</code>与<code>1&gt;</code>是一样的；</p><p>例如： + <code>cmd &gt; file</code>：把stdout重定向到file文件中； + <code>cmd &gt; &gt; file</code>：把stdout重定向到file文件中（追加）； + <code>cmd &lt; file &gt;file2</code>：cmd命令以file文件作为stdin，以file2文件作为stdout； + <code>cat &lt;&gt; file</code>：以读写的方式打开file；</p><h1 id="管道">管道</h1><p>管道<code>|</code>（pipe line）：上一个命令的stdout接到下一个命令的stdin，一个进程的输出作为另一个进程的输入；</p><p>例如： + <code>ls | wc -l</code> + <code>ls | grep 'txt'</code></p><h1 id="环境变量">环境变量</h1><ul><li>echo：使用echo查看单个环境变量，如：echo $PATH；</li><li>env：使用env查看所有环境变量；</li><li>set：使用set查看所有本地定义的环境变量（输出结果看起来会像是一堆函数）；</li><li>shell中：在shell中使用<code>export 变量名=$环境变量名</code>，可以自定义shell变量，它的值就是环境变量的值。该变量只在当前的shell或其子shell中有效。</li></ul><h1 id="查找命令">查找命令</h1><ul><li>find：用来在指定目录下查找文件，参数是查找文件的起始目录，根据文件或正则表达式进行匹配；</li><li>grep：全面搜索正则表达式并把行打印出来，是一种强大的文本搜索工具，它能使用正则表达式搜索文件，并把匹配的行打印出来，例如在文件中搜索一个单词，命令会返回一个包含搜索内容的文本行：<code>grep match_pattern file_name / grep &quot;match_pattern&quot; file_name</code>。</li></ul><h1 id="目录">目录</h1><p>在Linux中，所有的文件和目录都被组织成一个根节点开始的倒置的树状结构；</p><ul><li>/bin：binary，存放最常使用的命令；</li><li>/boot：启动Linux时使用的一些核心文件，包括一些连接文件和镜像文件；</li><li>/dev：device，存放Linux的外部设备——在Linux中，访问设备和访问文件的方式是相同的；</li><li>/etc：存放所有的系统管理所需要的配置文件和子目录；</li><li>/home：用户的主目录；</li><li>/lib：存放着系统最基本的动态连接共享库；</li><li>/media：Linux系统会自动识别一些设备，如U盘、光驱等，识别后，Linux会把被识别的设备挂载到这个目录下；</li><li>/mnt：为了让用户临时挂载别的文件系统用，如可以将光驱挂载在/mnt上，然后进入该目录就可以查看光驱里的内容了；</li><li>/root：系统管理员的用户主目录；</li><li>/tmp：存放一些临时文件</li><li>/usr：用户的很多应用程序和文件</li><li><p>/var：存放在不断扩充着的东西，习惯性将那些经常被修改的文件放到这个目录下， 包括各种日志文件；</p></li><li><code>pwd</code>：显示当前目录；</li><li><code>cd</code>：切换目录；</li><li><code>mkdir</code>：创建目录；</li><li><code>rmdir</code>：删除目录（最好是空目录，否则用-r递归删除其下的子目录和文件）；</li><li><p><code>ls</code>：以列表形式显示目录内容，有<code>-l</code>（详细）,<code>-a</code>（包含隐藏的全部）,<code>-R</code>（子目录展开）等选项。</p></li></ul><h1 id="文件">文件</h1><ul><li>touch：更新文件权限或最后修改时间（创建文件也可使用这个命令）；</li><li>cp：复制文件，<code>cp [options] 源文件 目标文件</code>，options：-r/R递归、-l对源文件建立硬链接而非复制文件；-s建立符号链接；</li><li>mv：移动和重命名文件/目录：<code>mv source target</code>；</li><li>ln：链接文件；默认创建硬链接，使用-s选项创建符号链接（软链接）；</li><li>rm：删除文件；</li><li>cat：输出文件内容；</li><li>more/less：逐页显示文件，more以全屏幕的方式按页显示文本文件的内容，less允许向后浏览文件；</li></ul><h1 id="链接">链接</h1><ul><li>硬链接可以理解为多个文件指向同一个物理地址，所以不能对目录做硬链接，也不可以在不同的文件系统之间做硬链接；</li><li>软链接/符号链接：<code>ln -s</code>，将一个路径名链接到一个文件。这些创建出来的软链接文件是一种特别类型的文件，实际上它只是一个文本文件，其中包含了链接时的源文件的路径名，而源文件才是实际包含所有数据的文件；软链接产生的这个文件在<code>ls -l</code>中第一列会显示一个<code>l</code>，即表示符号链接文件（而硬链接的第一列依然是<code>-</code>，即文件）；</li></ul><h1 id="文件属性">文件属性</h1><ul><li><code>ls -l</code>，得到<code>文件类型与权限 硬链接数目 所有者 用户组 文件大小 修改时间 文件名</code>的序列，其中文件类型与权限一长串（形如<code>drwxrwxrwx</code>各位的意义为：<ul><li>第1个字符，可能值：<code>d</code>-目录，<code>-</code>-文件，<code>|</code>-连接文件，<code>b</code>-接口设备，<code>c</code>串行端口设备；</li><li>第2-4位：该文件所属用户对本文件的权限；</li><li>第5-7位：该文件所属用户组对本文件的权限</li><li>第8-10位：其他用户对该文件的权限。</li></ul></li><li>更改文件权限：<code>chmod</code>，两种方式——数字或符号：<ul><li>对于符号，<code>chmod u/g/o/a +/-/=  r/w/x 文件或目录</code>，其中u表示user，g表示group，o表示others，a表示all（用户、操作符、权限是连起来写的）；</li><li>对于数字，<code>chmod [-R] xyz 文件或目录</code>，<code>-R</code>表示递归，xyz分别由三组权限属性值对应的数字累加而成，其中<code>r=4,w=2,x=1</code>，如<code>chmod 761 f.txt</code>，就表示<code>f.txt</code>的权限被改成了<code>rwx rw- --x</code>。</li></ul></li><li>更改文件所有者或组：<code>chown [-R] user:[group] filename</code></li><li>更改文件所在组：<code>chgrp [-R] group filename</code>；</li></ul><p>chown和chgrp需要在root权限下执行。</p><h1 id="其它命令">其它命令</h1><ul><li>passwd：改密码；</li><li>date：显示时间；</li><li>cal：显示日历；</li><li>who：显示当前登录到系统的用户；</li><li>clear：清屏；</li><li>echo：直接输出echo后面的文本。</li></ul><h1 id="基本命令示例">基本命令示例</h1><ul><li>以root登录，查看当前所处目录的绝对路径并列出该目录中有多少子目录：<code>su root</code>，<code>pwd</code>，<code>ls -la|grep &quot;^d&quot;|wc -l</code>；</li><li>在本机某普通用户的家目录（home）中创建子目录rootdir，并同时创建rootdir的子目录sondir：<code>mkdir rootdir</code>，<code>mkdir rootdir/sondir</code>；</li><li>§3在rootdir子目录中建立文本文件myorder，内容为<code>date pwd ls -l</code>，并将该文件复制到sondir目录，并同时改名为用户指定文件名：<code>cd ./rootdir</code>，<code>vi myorder</code>，<code>cp myorder ./sondir</code>，<code>cd ./sondir</code>，<code>mv ./myorder ./newname</code>；</li><li>查看刚才复制的文件的属性，添加文件主可执行权限：<code>ls -la</code>，<code>chmod u+x ./newname</code>；</li></ul><h1 id="编程相关命令示例">编程相关命令示例</h1><p>在自己的用户目录下建立一个子目录proexam,在该子目录中建立exam.c和exmax.c两个C语言源文件，exam.c是主函数文件，用数组datalist接受键盘输入的一组整数（以-99结束）并输出该数组datalist中的每个数据，exmax.c用自定义函数getmax()输出该数组中的最大值，并用cat命令将这两个源文件合并成exall.c源文件。再用命令统计该子目录中ex打头的文件名数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * exam.c</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> datalist[MAXN], cur, cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cur) &amp;&amp; cur != <span class="number">-99</span>; ++cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        datalist[cnt] = cur;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, datalist[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"/n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    getmax();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * examax.c</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> datalist[MAXN],cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">max</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">max</span> = <span class="number">0xc0c0c0c0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (datalist[loop] &gt; <span class="built_in">max</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">max</span> = datalist[loop];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"the largest one is: %d"</span>, <span class="built_in">max</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>合并：<code>cat exam.c exmax.c &gt; exall.c</code>；</p><p>合并结果（程序貌似有问题）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> datalist[MAXN], cur, cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cur) &amp;&amp; cur != <span class="number">-99</span>; ++cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        datalist[cnt] = cur;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, datalist[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"/n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    getmax();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> datalist[MAXN],cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">max</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">max</span> = <span class="number">0xc0c0c0c0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (datalist[loop] &gt; <span class="built_in">max</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">max</span> = datalist[loop];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"the largest one is: %d"</span>, <span class="built_in">max</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>统计：<code>ls | grep &quot;^ex&quot;| wc -l</code>；</p><p>makeFile语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">目标文件（.o或可执行文件） : （生成目标文件所需要的文件，源文件、头文件之类，空格隔开即可） ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">（必须有个Tab）command</span></pre></td></tr></table></figure><p>可通过如下makeFile文件使用make命令生成可执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">all: examall</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">examall: exam.o examax.o </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">gcc -Wall exam.o examax.o -o examall</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">exam.o: exam.c </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">gcc -c -Wall exam.c </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">examax.o: examax.c </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">gcc -c -Wall examax.c </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">clean: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">rm -rf *.o</span></pre></td></tr></table></figure><p>make、gcc还有gdb还有很多命令……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;/center&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://mechanicalmind.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Shell编程</title>
    <link href="http://mechanicalmind.cn/posts/6309c3f8.html"/>
    <id>http://mechanicalmind.cn/posts/6309c3f8.html</id>
    <published>2020-06-17T02:13:56.000Z</published>
    <updated>2020-06-17T02:13:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center>Shell是用户与操作系统之间的接口。</center><a id="more"></a><h1 id="引号">引号</h1><ul><li>单引号：单引号中的任何字符都会原样输出，转义失败，变量也是无效的；</li><li>双引号：里面可以有变量，也可以出现转义字符。</li></ul><h1 id="变量">变量</h1><p>有三种：</p><ul><li>用户变量：shell中自定义的变量</li><li>环境变量：操作系统变量，为OS或应用程序服务，如<code>$PATH</code>，也可以自定义；</li><li>位置（参数）变量：运行shell时传入的参数，以及额外产生的一些变量</li></ul><h2 id="字符串">字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">取长度：$&#123;#name&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">截取：$&#123;name:2:3&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">字串查找：expr index &quot;$&#123;name&#125;&quot; objectStr</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">这一段不放到代码块里的话hexo会崩哈哈哈，行内代码块都不行……</span></pre></td></tr></table></figure><h2 id="数组">数组</h2><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">array&#x3D;(v0 v1 v2 &quot;v3&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">array[1000]&#x3D;&quot;m_number&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#print all elements</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">echo $&#123;array[@]&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">echo $&#123;array[*]&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">#print array length</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">echo $&#123;#array[@]&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">echo $&#123;#array[*]&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">#print a element</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">echo $&#123;array[1000]&#125;</span></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">v0 v1 v2 v3 m_number</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">v0 v1 v2 v3 m_number</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">m_number</span></pre></td></tr></table></figure><h1 id="运算符">运算符</h1><ul><li>算术运算：<code>expr $a + $b</code>，五种运算，注意乘号要转义；</li><li>条件表达式：用方括号包起，两端需要留空格；如<code>[ $a == $b ]</code>；</li><li>关系运算：<code>[ $a -gt(-eq -gt -ne -lg -ge -le) $b ]</code>；</li><li>布尔运算：<code>[ !false ]</code>、<code>[ true -o false]</code>、<code>[true -a true]</code>；</li><li>逻辑运算：<code>[[ true &amp;&amp; false ]]</code>、<code>[ true || false ]</code>；</li><li>字符串运算：<code>[ $a ==(!= -z -n) $b ]</code>，还有<code>[ $a ]</code>检测字符串a是否为空；</li><li>文件测试运算：<code>[ -b(-c, -d, -f, -p, -r , -w, -x, -e) $file ]</code>是否为指定文件类型；</li></ul><p>注：<code>test</code>命令可以起到和方括号类似的作用，如<code>test $a -eq $b</code>。</p><p>算术扩展<code>$((...))</code>——shell算术运算和条件判断的另一种写法：</p><ul><li>如：<code>x=$(($x+1))</code>，等价于高级语言里的<code>x++</code>；</li><li>又如：<code>(( $x &gt;= 2 ))</code>，等价于<code>[ $x -ge 2 ]</code>；</li></ul><p>注意：双层括号与方括号不一样之处在于中间不需要空格来分割。</p><h1 id="io">I/O</h1><ul><li>read命令：读取输入，如<code>read FILM</code>，读取键盘输入并命名为FILM变量<ul><li><code>-p</code>：表示后面的输出提示字符，不会换行；</li><li><code>-n</code>：后面的数字表示输入的字符长度限制；</li></ul></li><li>echo命令：输出信息<ul><li><code>-p</code>：不换行；</li><li><code>-e</code>：解释转义符；</li></ul></li></ul><h1 id="流程控制">流程控制</h1><ul><li>if、for、while、case（let x++命令，是bash中用于计算的工具，使用变量不需要<code>$</code>）</li><li>shell函数：<code>形参 $1,$2 ; return n ;</code> 返回值<code>n</code>可用 <code>$？</code>得到</li></ul><h1 id="其它命令">其它命令</h1><ul><li><code>exit n</code>：退出，退出码n，退出后可以使用<code>$?</code>来获得上一个命令的退出码。</li><li>break和continue；</li></ul><h1 id="基本io与算术运算示例">基本I/O与算术运算示例</h1><p>读入一组整数，以-999结束。输出其中正数个数和负数的累加和。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">num_pos=0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">sum_neg=0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="variable">$num</span> -ne -999 ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$num</span> -gt 0 ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">then</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> num_pos++</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> sum_neg+=<span class="variable">$num</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">fi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">done</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"正数个数为：<span class="variable">$num_pos</span>，负数累加和为：<span class="variable">$sum_neg</span>。"</span></span></pre></td></tr></table></figure><p>求菲波纳妾数列的第N个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">array[0]=0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">array[1]=1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">i=2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -lt <span class="variable">$num</span> ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">let</span> array[<span class="variable">$i</span>]=array[<span class="variable">$i</span>-1]+array[<span class="variable">$i</span>-2]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">let</span> i++</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">done</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[$num-1]&#125;</span></span></pre></td></tr></table></figure><p>编写一个文件名为square的脚本程序，参数为不大于20的正整数。先检查参数是否符合要求。如果不符合要求，请给出提示；如果符合要求，输出从1到该正整数的平方值。参数可以由键盘或命令行方式给出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$num</span> -lt 20 ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">then</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    n=1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    m=1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> [ <span class="variable">$n</span> -le <span class="variable">$num</span> ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">do</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        m=$(expr <span class="variable">$n</span> \* <span class="variable">$n</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$n</span> <span class="variable">$m</span>   "</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        n=$(expr <span class="variable">$n</span> + 1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">done</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">echo</span> <span class="string">"number should less than 20"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">fi</span></span></pre></td></tr></table></figure><h1 id="自定义函数示例">自定义函数示例</h1><p>运用自定义函数compare()判断两个数的大小,并输出比较结果。函数返回值0表示相等、1表示大于、2表示小于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> [ <span class="variable">$1</span> -lt <span class="variable">$2</span> ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">then</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">echo</span> <span class="string">"2"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>[ <span class="variable">$1</span> -lt <span class="variable">$2</span> ]  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">then</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">echo</span> <span class="string">"0"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">echo</span> <span class="string">"1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">fi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">fi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">compare <span class="variable">$1</span> <span class="variable">$2</span></span></pre></td></tr></table></figure><h1 id="涉及目录与文件的操作示例">涉及目录与文件的操作示例</h1><p>编写shell程序，统计当前目录中指定学生（姓名由键盘读入，quit结束操作），自定义函数<code>examcount()</code>返回某学生的上传的文件数量（文件名中含学生姓名），并将记录 学生姓名 – 实验文件数 存入文件 examlist 中 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">examcount</span></span>()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">read</span> dir</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    ret=`find <span class="variable">$dir</span> -<span class="built_in">type</span> f -name <span class="string">"*<span class="variable">$1</span>*"</span>|wc -l`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">echo</span> <span class="variable">$ret</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">return</span> <span class="variable">$ret</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> name</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="variable">$name</span> != <span class="string">'quit'</span> ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    examcount <span class="variable">$name</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> - $?"</span>&gt;&gt;examlist</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">read</span> name</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">done</span></span></pre></td></tr></table></figure><p>编写一个SHELL程序，脚本文件名为listfile，若命令行的第一个参数是合法目录名，则由后续参数指定（应为.c后缀）该目录需显示的普通文件的内容，否则显示错误的目录名信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">dir=<span class="variable">$1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$dir</span> ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">then</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cd</span> <span class="variable">$dir</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    cat <span class="variable">$2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">echo</span> <span class="string">"end of file <span class="variable">$file</span>"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">done</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">echo</span> <span class="string">"bad directory name <span class="variable">$dir</span>"</span>   </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">fi</span></span></pre></td></tr></table></figure><p>编写一个SHELL程序，若命令行参数是一个合法目录则显示该目录下所有普通文件的内容，否则显示错误的目录名信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">dir=<span class="variable">$1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$dir</span> ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">then</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$dir</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$file</span> ] </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">then</span> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">cat <span class="variable">$file</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"end of file <span class="variable">$file</span>"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">fi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">done</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"bad directory name <span class="variable">$dir</span>"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">fi</span></span></pre></td></tr></table></figure><p>若<code>/root/bak</code>不存在则创建之，然后将<code>/etc</code>按日期打包保存于该目录中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">DIRNAME=`ls /root | grep bak`<span class="comment">#（1）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$DIRNAME</span>"</span> ]<span class="comment">#（2）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">then</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">mkdir /root/bak</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/bak<span class="comment">#（3）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">fi</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">YY=`date +%y`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">MM=`date +%m`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">DD=`date +%d`<span class="comment">#（4）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">BACKETC=<span class="variable">$YY</span><span class="variable">$MM</span><span class="variable">$DD_etc</span>.tar.gz<span class="comment">#（5）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">tar zcvf <span class="variable">$BACKETC</span> /etc<span class="comment">#（6）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"fileback finished!"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#（1）获取/root中名称包含bak的文件或目录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#（2）判断1结果为空</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#（3）创建目录/root/bak并进入该目录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#（4）获取当前时间的年月日</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#（5）按照年（2位）月（2位）日（2位）_etc方式构造压缩文件名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#（6）压缩etc目录并保存在/root/bak中</span></span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
Shell是用户与操作系统之间的接口。
&lt;/center&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://mechanicalmind.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>第六章：51单片机串行接口</title>
    <link href="http://mechanicalmind.cn/posts/ac2899d7.html"/>
    <id>http://mechanicalmind.cn/posts/ac2899d7.html</id>
    <published>2020-06-06T07:06:49.000Z</published>
    <updated>2020-06-06T07:06:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center></center><a id="more"></a><h1 id="串行通信的基本概念">串行通信的基本概念</h1><p>同步和异步： + 异步通信：1个起始位“0”表示字符的开始，然后是5～8位数据即该字符的代码，规定低位在前，高位在后，接下来是奇偶校验位(可省略)，最后以停止位“1”表示字符的结束。 + 同步通信：在同步通信中，发送方在数据或字符开始用同步字符(常约定1～2个字节)指示一帧的开始，由时钟来实现发送端和接收端同步，接收方一旦检测到与规定的同步字符符合，下面就连续按顺序传送若干个数据 ，最后发校验字节。</p><p>单工与双工： + 单工方式：一端只能发送，另一端只能接收。 + 半双工方式：数据可以双向传送，但不能同时发送和接收， 只能分时发送和接收。 + 全双工方式：通信双方可以同时发送和接收数据。</p><p>波特率与发送、接收时钟： + 波特率：单位时间内传送的信息量，以每秒传送的二进制位数为单位即bit/s(bps)。 + 发送、接收时钟：在串行传输中，二进制数据序列是以数字波形出现的，发送时在发送时钟作用下将发送移位寄存器的数据串行移位输出；在接收时，在接收时钟的作用下将通信线上传来的数据串行移入移位寄存器，所以发送时钟和接收时钟也可称作移位时钟。能产生时钟的电路称为波特率发生器。在单片机中，发送/接收时钟可以由系统时钟fosc产生，这种波特率称为固定波特率方式；也可以由单片机内部定时器T1产生，T1工作于自动再装入8位定时方式（方式2），由于定时器的计数初值可以人为改变，T1产生的时钟频率也就可变，这种称为可变波特率方式。单片机串行通信的波特率选择因工作方式不同而不同。</p><h1 id="串行通信接口结构和工作原理">串行通信接口结构和工作原理</h1><p>串行通信接口需要实现如下功能： + 实现数据格式化：因为CPU发出的数据是并行数据，接口电路应实现不同串行通信方式下的数据格式化任务，如自动生成起、止位的帧数据格式(异步方式)或在待传送的数据块前加上同步字符等。 + 进行串、并转换：在发送端，接口将CPU送来的并行数据转换成串行数据进行传送；而在接收端，接口要将接 收到串行数据变成并行数据送往CPU，由CPU进行处理。 + 控制数据的传输速率：接口应具备对数据传输率（即波特率）的控制选择能力，即具有波特率发生器。 + 进行传送错误检测：在发送时，对传送的数据自动生成校验位或校验码，在接收时能检查校验位或校验码，以确定传送中是否有错误。</p><p>串行接口通常分为两种类型： + 串行通信接口（本章介绍的）：设备之间的互连接口。 + 串行扩展接口：是设备内部器件之间的互连接口，常用的有SPI、I2C等。串行扩展接口的芯片很多，可以根据需要选择。特点是芯片体积小，采用串行总线技术，控制较复杂。</p><p>51单片机内有一个全双工的异步通信接口，通过对串行接口写控制字可以选择其数据格式，同时内部有波特率发生器，提供可选的波特率，可完成双机通信或多机通信。</p><p>不同的通信距离，串行通信电路有不同的连接方法： + 近距离传送（1.5米左右），单片机之间可直接连接（TTL电平）。 + 较远距离传送（15米左右），加电平转换电路实现（RS-232C电平）。 + 如果更远距离（上千米）传送，数字信号通过调制器变成模拟信号通过电话线传送到对方，接收方通过解调器将模拟信号转换成数字信号接收（调制解调器MODEM）。</p><p>主从结构多机通信原理——设有一台主机与四台从机通信，其中一台从机通信地址号为01H，主机呼叫从机并向其传送一个字节数据的过程： + 将所有从机的REN、SM2置1，工作在方式2或3。 + 主机发送一个地址桢01H，第9位为1即TB8=1。 + 各从机接收到后，都发生中断，进入中断服务程序，比较自己的地址与01H是否相同，若相同则将本机SM2置0，否则仍为1。 + 主机发送数据桢，TB8=0，各从机接收该数据桢，从机中SM2为0的产生中断，而其它SM2为1的从机不产生中断将信息丢弃，从而实现主机与从机传递数据。</p><h1 id="串行通信的控制寄存器">串行通信的控制寄存器</h1><p>51单片机串行口是一个可编程的接口，编程时主要是对两个特殊功能寄存器SCON和PCON的控制。</p><p>串行口控制寄存器SCON（98H）用以存放串行口的控制和状态信息。方式选择，接受和发送控制及串行口的标志均由专用寄存器SCON控制和指示，其格式如下： + SM0、SM1:串行口工作方式控制位。00-方式0，01-方式1，10-方式2，11-方式3。 + REN：串行接收允许位。0-禁止接收，1-允许接收 + TB8: 在方式2、3时，存放要发送的第9位数据。 + RB8: 在方式2、3中，存放收到的第9位数据，该数据来自发送方的TB8。 + TI: 发送中断标志位。发送前必须用软件清零，发送过程中TI保持零电平，发送完一帧数据后，由硬件置 “1”；如果再发送，必须用软件再清零。 + RI: 接收中断标志位。接收前，必须用软件清零，接收过程中RI保持零电平，接收完一帧数据后由片内硬件自动置“1”。如果再接收必须用软件清零。 + SM2:多机通信控制位，仅用于方式2和方式3。发送机设置SM2=1(程序设置)，TB8=1作为地址帧寻找从机，TB8=0作为数据帧进行通信，接收机SM2=1，若RB8=1，激活RI，引起接收中断.RB8=0，不激活RI，不引起中断.SM2=0， 激活RI引起接收中断。</p><p>串行通信只用PCON中的最高位SMOD，是串行口波特率的倍增控制位。</p><h1 id="串行口的工作方式">串行口的工作方式</h1><p>根据串行通信数据格式和波特率的不同，51系列单片机的串行通信有四种工作方式，通过编程进行选择，各工作方式的特点如下: + 方式0的数据格式为8位,低位在前,高位在后RXD为串行数据的发送端或接收端,TXD输出频率为fosc/12的时钟脉冲。波特率固定为fosc/12 (fosc为晶振频率)，移位寄位器方式多用于接口的扩展,当用单片机构成系统时,往往感到并行口不够用,此时可通过外接串入并出移位寄存器扩展输出接口；通过外接并入串出移位寄存器扩展输入接口。 + 方式1为10位异步通信方式, 每帧数据由1个起始位“0”，8个数据位和1个停止位“1”共10位构成。其中起始位和停止位在发送时是自动插入的。以TXD为串行数据的发送端,T1提供移位时钟，RXD为数据的接收端,由T1提供移位时钟,波特率可变。波特率=(2SMOD/32)×(T1的溢出率)=(2^SMOD/32)×(fosc/12(256-x))，根据给定的波特率,可以计算T1的计数初值x。 + 方式2为11位异步发送/接收方式，即每帧数据由有1个起始位“0”，9个数据位和1个停止位“1”组成。发送时第9位数据由SCON寄存器的TB8位提供，而接收到的第9位数据存放在SCON寄存器的RB8位。第9位数据可作为检验位，也可用于多机通信中识别传送的是地址还是数据的特征位。波特率固定为(2^SMOD/64)×fosc. + 方式3的数据格式同方式 2，所不同的是波特率可变，计算方式同方式 1。</p><h1 id="串行通信的应用编程">串行通信的应用编程</h1><p>若晶体振荡器为11.0592MHz，串行口工作于方式1，波特率为4800bit/s，写出用T1作为波特率发生器的方式控制字和计数初值的初始化程序段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">;X&#x3D;256-(fosc*2^SMOD)&#x2F;(12*32*波特率)&#x3D;256-(11059200*1)&#x2F;(12*32*4800)&#x3D;256-6&#x3D;250&#x3D;FAH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ANL TMOD,#0FH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ORL TMOD,#20H  ;T1设置为方式2，T0方式保持不变，如果用MOV会改变T0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">;因为定时器&#x2F;计数器在方式2下，初值可以自动重装，这样在进行串口波特率发生器设置时，就避免了重装参数的操作,且减少了重装参数的误差。因此做此设置。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">MOV TH1,#0FAH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">MOV TL1,#0FAH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">MOV SCON,#40H  ;方式1</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;/center&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第五章：51单片机定时/计数器</title>
    <link href="http://mechanicalmind.cn/posts/a3394965.html"/>
    <id>http://mechanicalmind.cn/posts/a3394965.html</id>
    <published>2020-06-06T07:06:26.000Z</published>
    <updated>2020-06-06T07:06:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center></center><a id="more"></a><h1 id="定时计数器结构和工作原理">定时/计数器结构和工作原理</h1><p>51单片机片内有2个16位定时/计数器：定时器0(T0)和定时器1(T1)。两个定时器都有定时或计数的功能，可通过软件的设置来选择是定时还是计数工作方式，核心部件是16位加1计数器。 + T0由2个8位持殊功能寄存器TH0和TL0构成， + T1由2个8位持殊功能寄存器TH1和TL1构成。 + T0和T1受特殊功能寄存器TMOD和TCON控制。</p><p>设置为定时工作方式时，定时器计数的脉冲是由51单片机片内振荡器经12分频后产生的。每经过一个机器周期，定时器(T0或T1)的数值加1，直至计数满产生溢出。如采用12MHz晶体时，每个机器周期为1μs，计5个机器周期即为5μs，即定时5μs。</p><p>设置为计数工作方式时，定时/计数器对引脚P3.4 (T0)和P3.5 (T1)输入的外部脉冲信号计数。当输入脉冲信号产生由1至0的下降沿时，定时器的值加1。由于检测一个1至0的跳变需要二个机器周期，故最高计数频率为振荡频率的二十四分之一。</p><p>无论是定时还是计数，当软件设定了定时/计数器的工作方式，启动以后，定时/计数器就按规定的方式工作，不占用CPU的操作时间，此时CPU可执行其他程序，到了计满规定的时间或规定的个数（定时/计数器溢出），定时/计数器会给出溢出标志，程序可以通过查询或中断方式了解是否溢出。</p><h1 id="定时计数器的控制寄存器">定时/计数器的控制寄存器</h1><h2 id="工作模式寄存器tmod89h">工作模式寄存器TMOD(89H)</h2><p>TMOD用于控制T0和T1的工作方式，前四位/高四位控制T1，后四位/低四位控制T0。</p><ul><li>GATE门控信号：GATE=0，TRx=1时即可启动定时器工作；GATE=1，TRx=1且INTx=1才可启动定时器工作（外部启动）。</li><li>C/T定时器/计数器选择位：C/T=1，为计数器方式；(C-Counter计数器)；C/T=0，为定时器方式。(T-Timer定时器)。</li><li>M1/M0工作模式选择位：<ul><li>M1M0=00：方式0（13位方式）。</li><li>M1M0=01：方式1（16位方式）。</li><li>M1M0=10：方式2（8位自动再装入方式）。</li><li>M1M0=11：方式3（T0为2个8位方式）。</li></ul></li></ul><h2 id="控制寄存器tcon88h">控制寄存器TCON(88H)</h2><p>定时器控制仅用了其中高4位，其意义如下： + TF1：T1溢出中断请求标志。TF1=1，T1有溢出中断请求。TF1=0，T1无溢出中断请求。 + TR1：T1运行控制位。TR1=1，启动T1工作。TR1=0，停止T1工作。 + TF0：T0溢出中断请求标志。TF0=1，T0有溢出中断请求。TF0=0，T0无溢出中断请求。 + TR0：T0运行控制位。TR0=1，启动T0工作。TR0=0，停止T0工作。</p><h1 id="定时计数器的工作方式">定时/计数器的工作方式</h1><p>对TMOD寄存器的M1、M0位的设置，可选择4种工作方式，即方式0、方式1、方式2和方式3。</p><h2 id="方式0">方式0</h2><p>定时器(T0或T1)工作于13位定时、计数方式。用于计数方式时最大计数值为2<sup>13＝8192个脉冲，用于定时工作时，定时时间为t＝(2</sup>13-Tx初值)×机器周期。在这种模式下，16位寄存器(THx和TLx)只用13位，其中THx占高8位。其中TLx占低5位，TLx的高3位末用；当TLx的低5位溢出时向THx进位，而THx溢出时硬件置位TFx，并申请中断。定时/计数器是否溢出可查询TFx是否为1，如果开中断则当TFx=1时会产生溢出中断。</p><h2 id="方式1">方式1</h2><p>当TMOD中M1M0=01时，定时计数器工作在方式1。该模式是一个16位定时/计数方式。寄存器THx和TLx是以全16位参与操作，计数方式时最大计数2^16＝65536个脉冲，用于定时工作方式时，定时时间为t＝(216-Tx初值)×机器周期。在这种模式下，16位寄存器(THx和TLx) 中THx提供高8位、TLx提供低8位计数初值。</p><h2 id="方式2">方式2</h2><p>当TMOD中M1M0=10时，定时器工作在方式2。方式2是8位的可自动重装载的定时/计数方式。16位的计数器被拆成两个8位，其中TLx用作8位计数器，THx用以保持计数初值。当TLx计数溢出，置TFx，THx中的初值自动装入TLx，继续计数，循环重复计数。用于计数工作方式时，最大计数值为2<sup>8＝256个外部脉冲，用于定时工作方式时，其定时时间为t＝(2</sup>8-THx初值)×机器周期。这种工作方式可省去用户重装常数的程序，并可产生精确的定时时间，特别适用作串行口波待率发生器。</p><h2 id="方式3">方式3</h2><p>当TMOD中M1M0=11时，定时器工作在方式3。方式3只适合于定时/计数器0(T0)。若将T0设置为方式3，TL0和TH0被分成为两个互相独立的8位计数器。TL0可工作为定时方式或计数方式。占用原T0的各控制位、引脚和中断源。即C／T、GATE、TR0、TF0和T0(P3.4)引脚、INT0(P3.2)引脚。TH0只可用作定时功能，占用定时器T1的控制位TR1和T1的中断标志位TF1，其启动和关闭仅受TRl的控制。只有将T1用做串行口的波特率发生器时，T0才工作在方式3，以便增加一个定时器。</p><h1 id="定时计数器的应用程序设计">定时/计数器的应用程序设计</h1><h2 id="定时计数器的计数初值c的计算和装入">定时/计数器的计数初值C的计算和装入</h2><p>如前所述，定时/计数器在不同工作方式时的模值是不同的（如模为2<sup>13，2</sup>16，2^8等），由于采用加1计数，因此若计数个数为X,则计数初值应为负值(模-X=-X)。计数初值（C）的求法如下：</p><ul><li>计数方式：<code>C=模-X</code>（其中X为要计的脉冲个数）</li><li>定时方式：<code>C=[t/MC]补=模-t/MC</code>，其中t为欲定时时间，MC为机器周期=12/fosc，当采用12MHz晶振时，MC=1μs，当采用6MHz晶振时，MC=2μs。</li></ul><p>例如要计100个脉冲的计数初值：</p><ul><li>方式0（13位方式）： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">;C&#x3D;（-64H）补&#x3D;2000H－64H&#x3D;1F9CH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">;1F9CH＝0001 1111 1001 1100B</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">;高八位1111 1100B装入TH0，</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">;低五位xxx1 1100B装入TL0,xxx用“0”填入。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">MOV TH0,#0FCH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">MOV TL0,#1CH</span></pre></td></tr></table></figure></li><li>方式1(16位方式): <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">;C&#x3D;（-64H）补&#x3D;10000H-64H&#x3D;FF9CH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">;用指令装入计数初值：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOV TH0,#0FFH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOV TL0,#9CH</span></pre></td></tr></table></figure></li><li>方式2（8位自动再装入方式） <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">;C&#x3D;（-64H）补&#x3D;100H-64H&#x3D;9CH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">;初值既要装入TH0，也要装入TL0：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOV TH0，#9CH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOV TL0，#9CH</span></pre></td></tr></table></figure></li></ul><h2 id="定时计数器的初始化编程">定时计数器的初始化编程</h2><ol start="0" type="1"><li>根据定时时间要求或计数要求计算计数器初值；</li><li>工作方式控制字送TMOD寄存器；</li><li>送计数初值的高8位和低8位到THX和TLX寄存器中；</li><li>启动定时（或计数），即将TRX置位。如果工作于中断方式，需要置位EA（中断总开关）及ETX（允许定时/计数器中断），并编中断服务程序。</li></ol><p>例如定时/计数器0为定时模式工作于方式1，主频fosc=6MHz，要求定时Tc=10ms。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">START:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV      TMOD,#01H  ;方式1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOV      TH0, #0ECH ;Tc&#x3D;10ms&#x3D;10000us&#x3D;（65536-x）×（12&#x2F;6）得x&#x3D;60536&#x3D;0EC78H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOV      TL0, #78H  ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">SETB     EA         ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">SETB     ET0        ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">SETB     TR0        ;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;/center&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第四章：51单片机中断系统</title>
    <link href="http://mechanicalmind.cn/posts/46009304.html"/>
    <id>http://mechanicalmind.cn/posts/46009304.html</id>
    <published>2020-06-06T07:06:02.000Z</published>
    <updated>2020-06-06T07:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center></center><a id="more"></a><h1 id="中断的基本概念">中断的基本概念</h1><ul><li>中断：CPU暂停正在执行的程序而转去为外设服务(或处理紧急事件)，处理完毕再回到原程序继续执行的过程。</li><li>中断源：引起中断的原因,中断申请的来源。中断源可以是I/O设备、故障、时钟等。</li><li>中断优先级：当有多个中断源时，CPU优先响应最需紧急处理(优先级别高）的中断请求。</li><li>中断的嵌套：在中断系统中，高优先级的中断请求能中断正在进行的较低优先级的中断源处理。</li><li>中断系统：能实现中断功能并能对中断进行管理的硬件和软件。</li></ul><h1 id="中断的系统结构">中断的系统结构</h1><p>8XX51有5个中断源，3个在片内，2个在片外，它们在程序存贮器中有固定的中断入口地址， 当CPU响应中断时，硬件自动形成这些地址，由此进入中断服务程序；5个中断源有两级中断优先级，可形成中断嵌套。</p><ul><li>/INT0：外部中断请求0，外部中断请求信号（低电平或负跳变有效）由/INT0引脚输入，中断请求标志为IE0。</li><li>/INT1：外部中断请求1，外部中断请求信号（低电平或负跳变有效）由/INT1引脚输入，中断请求标志为IE1。</li><li>定时器/计数器T0计数溢出的中断请求，标志为TF0。</li><li>定时器/计数器T1计数溢出的中断请求，标志为TF1。</li><li>串行口中断请求，标志为发送中断TI或接收中断RI。</li></ul><p>5个中断请求源的中断请求标志分别由特殊功能寄存器TCON和SCON相应位锁存。</p><ul><li>TCON寄存器为定时器/计数器的控制寄存器，字节地址为88H，可位寻址。既包括定时器/计数器T0、T1溢出中断请求标志位TF0和TF1，也包括两个外部中断请求的标志位IE1与IE0，还包括两个外部中断请求源的中断触发方式选择位。<ul><li>TF1：定时器/计数器T1的溢出中断请求标志位。当启动T1计数后，T1从初值开始加1计数，当最高位产生溢出时，硬件置TF1为“1”，向CPU申请中断，响应TF1中断时，TF1标志硬件自动清“0”，TF1也可由软件清“0”。</li><li>TF0：定时器/计数器T0溢出中断请求标志位，与TF1类似。</li><li>IE1：外部中断请求1中断请求标志位。</li><li>IE0：外部中断请求0中断请求标志位，与IE1类似。</li><li>IT1：选择外中断请求1为跳沿触发（高到低的负跳变有效，置1）还是电平触发（低电平有效，置0）方式。</li><li>IT0：选择外中断请求0为跳沿触发方式还是电平触发方式，与IT1类似。</li><li>TR1（D6位）、TR0（D4位）这2位仅与定时器/计数器T1和T0有关。</li></ul></li><li>SCON寄存器是串行口控制寄存器，字节地址为98H，可位寻址。SCON的低二位锁存串口的发送中断和接收中断的中断请求标志TI和RI。<ul><li>TI：串口发送中断请求标志位。CPU将1字节的数据写入串口的发送缓冲器SBUF时，就启动一帧串行数据的发送，每发送完一帧串行数据后，硬件使TI自动置“1”。CPU响应串口发送中断时，并不清除TI中断请求标志，TI标志必须在中断服务程序中用指令对其清“0”。</li><li>RI：串行口接收中断请求标志位。在串口接收完一个串行数据帧，硬件自动使RI中断请求标志置“1”。CPU在响应串口接收中断时，RI标志并不清“0”，须在中断服务程序中用指令对RI清“0”。</li></ul></li></ul><p>实现中断允许控制由中断允许寄存器IE实现。IE字节地址为A8H，可进行位寻址。IE对中断开放和关闭实现两级控制，有一个总的中断开关控制位EA（IE.7位），当EA=0，所有中断请求被屏蔽，CPU对任何中断请求都不接受；当EA=1时，CPU开中断，但5个中断源的中断请求是否允许，还要由IE中的低5位所对应的5个中断请求允许控制位的状态来决定。IE中各位（头一位即IE.7位是EA，之后一位无用，如果不是增强性第三位也无用否则对应计时器2，以下列出EA和剩下后五位）的功能如下： + EA：中断允许总开关控制位。EA=0，所有的中断请求被屏蔽。EA=1，所有的中断请求被开放。 + ES：串行口中断允许位。ES=0，禁止串行口中断。ES=1，允许串行口中断。 + ET1：定时器/计数器T1溢出中断允许位。ET1=0，禁止T1溢出中断。ET1=1，允许T1溢出中断。 + EX1：外部中断1中断允许位。EX1=0，禁止外部中断1中断。EX1=1，允许外部中断1中断。 + ET0：定时器/计数器T0溢出中断允许位。ET0=0，禁止T0溢出中断。ET0=1，允许T0溢出中断。 + EX0：外部中断0中断允许位。EX0=0，禁止外部中断0中断。EX0=1，允许外部中断0中断。</p><p>复位后，IE被清“0”，所有中断请求被禁止。</p><p>中断优先级控制由中断优先级寄存器IP实现，字节地址为B8H，可位寻址。。中断请求源有两个中断优先级，每一个中断请求源可由软件设置为高优先级中断或低优先级中断，也可实现两级中断嵌套。所谓两级中断嵌套，就是正在执行低优先级中断的服务程序时，可被高优先级中断请求所中断，待高优先级中断处理完毕后，再返回低优先级中断服务程序。IP中各位（前两位无用，如果不是增强性第三位也无用否则对应计时器2，以下列出剩下后五位）功能如下：</p><ul><li>PS：串行口中断优先级控制位，1—高级；0—低级。</li><li>PT1：T1中断优先级控制位，1—高级；0—低级。</li><li>PX1：外部中断1中断优先级控制位，1—高级；0—低级。</li><li>PT0：T0中断优先级控制位，1—高级；0—低级。</li><li>PX0：外部中断0中断优先级控制位，1—高级；0—低级。</li></ul><p>默认的优先级为：外部中断0-&gt;定时器0中断-&gt;外部中断1-&gt;定时器1中断-&gt;串行口中断。</p><h1 id="中断的响应过程">中断的响应过程</h1><p>中断处理过程分为四个阶段：中断请求，中断响应，中断处理、中断返回。中断请求、中断响应过程由硬件完成。中断处理的服务程序应根据需要进行编写。中断返回是通过执行一条RETI中断返回指令，使堆栈中被压入的断点地址送PC，从而返回主程序继续执行。另外RETI还有恢复优先级状态触发器(IP)的作用，因此不能以RET指令代替RETI指令。</p><p>若某中断源通过编程设置，处于中断允许的状态，并满足中断响应的条件，则中断可被触发；然而下面三种情况单片机不响应中断： + 当前正在执行的那条指令没执行完； + 当前响应了同级或高级中断； + 正在操作IE、IP寄存器或正在执行RETI指令。</p><p>正常情况下，从中断请求到中断得到响应，通常需要3~8个机器周期。</p><p>CPU响应中断后，应撤除该中断请求标志，否则会再次中断： + 对边沿触发的外部中断INT1和INT0，CPU响应中断后，硬件自动清除中断请求标志IE0和IE1。 + 对电平触发的外部中断INT1和INT0，CPU不会自动清除中断标志，在CPU响应中断后应立即撤除INT1或INT0的低电平信号。 + 对定时计数器T0、T1的中断，CPU响应中断后，硬件自动清除中断请求标志TF0、TF1。 + 对于串行口中断，CPU响应中断后，中断请求标志TI、RI不会自动清除，必须用软件清除。</p><h1 id="中断的应用编程">中断的应用编程</h1><p>用户对中断的控制和管理，实际是对4个与中断有关的寄存器IE、TCON、IP、SCON进行控制或管理。这几个寄存器在单片机复位时是清零的，因此必须根据需要对这几个寄存器的有关位进行预置。在中断程序的编制中应注意： + 中断总控开关EA=1，某中断源的中断允许位=1。 + 对外部中断INT0、INT1应选择中断触发方式 + 多个中断源中断，应设定中断优先级，预置IP。</p><p>51单片机5个中断服务程序的中断入口地址为：0003H、000BH 、0013H、001BH、0023H，由于这五个中断入口地址之间相距很近，可能装不下一个中断服务程序。通常将中断服务程序安排在程序存贮器的其他地址空间，而在入口地址的单元中安排一条转移指令。</p><p>例程，编写外部中断1为跳沿（下降沿）触发的中断初始化程序段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SETB IT1  ;方式下跳沿</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">SETB EX1  ;允许外部中断1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">SETB EA   ;总开关开启</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;/center&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第三章：51单片机并行接口</title>
    <link href="http://mechanicalmind.cn/posts/d1e12d51.html"/>
    <id>http://mechanicalmind.cn/posts/d1e12d51.html</id>
    <published>2020-06-06T07:05:39.000Z</published>
    <updated>2020-06-06T07:05:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center>51单片机集成有并行接口、串行接口、定时/计数器接口等，由此外设可直接与单片机相连（有时需加驱动）。本章介绍单片机的并行接口。</center><a id="more"></a><h1 id="pop3端口的功能">PO～P3端口的功能</h1><ul><li>PO口<ul><li>作为输入/输出口。</li><li>作为地址/数据总线 ,接外围芯片时PO口分时输出低8位地址与数据信号。</li></ul></li><li>P1口<ul><li>作为输入/输出口。</li><li>在增强型(52系列)和ISP型(在系统编程型)中P1口还有定时/计数器功能和系统编程相关功能。</li></ul></li><li>P2口<ul><li>作为输入/输出口。</li><li>作为高8位地址总线。</li></ul></li><li>P3口<ul><li>作为输入/输出口。</li><li>作第二功能使用，定义如下:<ul><li>P3.0 RXD（串行口输入）；</li><li>P3.1 TXD（串行口输出）；</li><li>P3.2 /INT0（外部中断0输入）；</li><li>P3.3 /INT1（外部中断1输入）；</li><li>P3.4 T0（定时器/计数器0的外部输入）；</li><li>P3.5 T1（定时器/计数器1的外部输入）；</li><li>P3.6 /WR（片外数据存储器写选通控制输出）；</li><li>P3.7 /RD（片外数据存储器读选通控制输出）；</li></ul></li></ul></li></ul><h1 id="pop3端口的结构">PO～P3端口的结构</h1><ul><li>四个端口结构相似：<ul><li>都有两个输入缓冲器，分别受读锁存器和读引脚的控制。</li><li>都有锁存器(即寄存器PO～P3)</li><li>都是场效应管输出驱动。</li></ul></li><li>同一个端口的各位结构相同</li></ul><p>不同端口结构区别略。</p><p>总结： + 如果单片机不需要扩展外部存贮器和I/O接口，单片机的四个口均可作I/O口使用。 + 四个口在作输入口使用时，均应先对其写“1”，以避免误读。 + P0口作I/O口使用时应外接10K的上拉电阻，其它口内有上拉电阻（因此不必外接）。 + P2口某几根线作地址使用时，剩下的线不能作I/O口线使用。 + P3口的某些口线作第二功能时，剩下的口线可以单独作I/O口线使用。</p><h1 id="pop3端口的编程">PO～P3端口的编程</h1><h2 id="用并行口控制led">用并行口控制LED</h2><p>例程：利用51单片机的P1口控制8个发光二极管LED，相邻的4个为一组，使两组交替发亮，周而复始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV A,#0FH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ABC:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  MOV P1,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  ACALL D05</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  SWAP A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  SJMP ABC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">;延时程序，循环250*250次（每次双周期），加上判断之类指令的执行大约为0.13s</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">D05:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  MOV R6,#250</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  DY:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  MOV R7,#250</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  DAY:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    NOP</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    NOP</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  DJNZ R7,DAY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  DJNZ R6,DY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr></table></figure><h2 id="用并行口控制数码管">用并行口控制数码管</h2><p>数码管内部由七个条形发光二极管和一个小圆点发光二极管组成，根据各管的亮暗组合成字符。常见LED的管脚排列见图(a)。数码管每段需10～20mA的驱动电流，可用TTL或CMOS器件驱动。其中COM为公共点，根据内部发光二极管的接线 形式，可分成共阴极型图(b)和共阳极型图(c)。</p><p><img src="" /></p><p>数码管的a～g+dp八个发光二极管加正电压而发亮，加零电压而灭，不同亮灭的组合就能形成不同的字形，这种组合称之为字形码(段码)，如显示“0”,字形码为00111111即3fh（共阴极时），此时dp和g灭其余亮。</p><p>共阳极和共阴极的字形码是不同的(刚好互为反码)，见下表。</p><p><img src="" /></p><p>字形码的控制输出可采用2种方法：</p><ul><li>硬件译码方式，如采用BCD译码/驱动器74LS48、CD4511(共阴极)或74LS46、CD4513(共阳极)；</li><li>软件查表方式：<ul><li>共阴极：<ul><li>汇编查表：3FH,06H,5BH,4FH,6EH,6DH,7DH,07H,7FH,6FH,77H,7CH,59H,3EH,79H,71H,6FH,76H,73H,5EH,00H</li><li>C语言数字数组：{0x3F,0x06,0x5B,0x4F,0x6E,0x6D,0x7D,0x07,0x7F,0x6F}</li><li>C语言字幕数组：{0x77,0x7C,0x59,0x3E,0x79,0x71}</li></ul></li><li>共阳极<ul><li>汇编查表：C0H,F9H,A4H,B0H,91H,A2H,82H,F8H,80H,90H,88H,83H,A6H,C1H,86H,8EH,90H,89H,8CH,A1H,FFH</li><li>C语言数字数组：{0xC0,0xF9,0xA4,0xB0,0x91,0xA2,0x82,0xF8,0x80,0x90}</li><li>C语言字母数组：{0x88,0x83,0xA6,0xC1,0x86,0x8E}</li></ul></li></ul></li></ul><p>LED数码管的接口有静态接口和动态接口。 + 静态接口：用一个并行口接一个数据管，数码管的公共端com接地(共阴)或接Vcc(共阳)。 + 优点：显示稳定，无闪烁，控制容易。 + 缺点：占用接口多。如果PO口和P2口要用作数据线和地址线，仅用单片机的并行口就只能接2个数码管。 + 动态接口：一个接口输出字形码 (字选)，另一接口选择点亮某位数码管 (位选)。采用各数码管循环轮流显示的方法，当循环显示频率较高时，看不出闪烁显示现象。 + 优点：节省接口（2个接口就可以接8个数码管）。 + 缺点：显示可能会有闪烁，软件控制复杂。</p><p>例程：用51单片机P3口设计显示一个数码的电路，使数码管循环显示“0”～“F”（使用共阴极数码管）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ORG 0000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#TAB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">AGAIN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  MOV R0,#0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">NEXT:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  MOV  A,R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  MOVC A,@A+DPTR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  MOV  P3,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  ;延时</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  MOV  R7,#0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  DAY: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    NOP</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    NOP</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  DJNZ R7,DAY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  INC R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  CJNE R0,#10H,NEXT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  SJMP  AGAIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">TAB:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  DB 3FH,06H...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr></table></figure><h2 id="用并行口设计键盘电路">用并行口设计键盘电路</h2><p>见实验三。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
51单片机集成有并行接口、串行接口、定时/计数器接口等，由此外设可直接与单片机相连（有时需加驱动）。本章介绍单片机的并行接口。
&lt;/center&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第二章：51单片机指令系统</title>
    <link href="http://mechanicalmind.cn/posts/8e95d8ee.html"/>
    <id>http://mechanicalmind.cn/posts/8e95d8ee.html</id>
    <published>2020-06-06T07:04:25.000Z</published>
    <updated>2020-06-06T07:04:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center></center><a id="more"></a><p>开始之前，先约定如下符号的含义：</p><ul><li>Rn（n=0～7）：当前工作寄存器R0～R7中的一个；</li><li>Ri（i=0|1）：R0和R1寄存器中的一个，用作间接寻址寄存器；</li><li>dir：8位直接地址（片内 RAM 和 SFR）</li><li>#data：8位立即数，即8位常数。可以为2进制（B）、10进制、16进制（H）、字符（''）；</li><li>#data16：表示16位立即数，取值范围为#0000H～#0FFFFH；</li><li>addr16：表示16位地址；</li><li>addr11：表示11位地址；</li><li>rel：相对偏移量（为1字节补码）用于相对转移指令中；</li><li>bit：位地址，在位地址空间中；</li><li>$：表示当前指令的地址；</li><li>(XXH)：用于注释中表示存储单元的内容。</li></ul><p>与在电脑上进行编程不同，51系列单片机指令系统的特点是不同的存储空间寻址方式不同，适用的指令不同，必须进行区分——因此相比电脑上的汇编，51的更加恶心。</p><h1 id="寻址方式">寻址方式</h1><h2 id="立即寻址">立即寻址</h2><p>指令中直接给出操作数的寻址方式称为立即寻址。51单片机中立即数前面要加<code>#</code>，如8位数（#30H）或16位数（#2000H）。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV A   ,#30H  ;A←30H，执行后A&#x3D;30H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#2000H;DPTR←2000H，执行后DPTR&#x3D;2000H</span></pre></td></tr></table></figure><h2 id="直接寻址">直接寻址</h2><p>操作数的地址直接出现在指令中。寻址对象：</p><ul><li>内部数据存贮器：使用它的地址。</li><li>特殊功能寄存器：既可使用它的地址，也可以直接使用寄存器名。</li></ul><p>例如地址41H处存储有数据78H、40H处存储有数据56H：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV A,40H  ; （40H）→A，执行后A&#x3D;56H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV P0,41H ; （41H）→P0，执行后（80H）&#x3D;（41H）&#x3D;78H（寄存器P0的地址为80H）</span></pre></td></tr></table></figure><h2 id="寄存器寻址">寄存器寻址</h2><p>操作数存放在寄存器中，寻址对象：A，B，DPTR，Rn。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV A,R0  ;R0→A，此处A、R0均为寄存器寻址</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MUL A,B   ;A*B→B，A、B均为寄存器寻址</span></pre></td></tr></table></figure><h2 id="寄存器间接寻址">寄存器间接寻址</h2><p>操作数存放在以寄存器内容为地址的单元中。在寄存器前加前缀标志<code>@</code>。注意：<strong>只有Ri和DPTR可以作为间址寄存器</strong>（也就是说只有它们前面可以加“@”）。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV  R0,#20H       ;R0存放地址号码</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV  @R0,A         ;A→(20H)，执行后地址为20H的RAM&#x3D;A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOV  DPTR,#3000H  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR,A       ;A→(3000H)，执行后地址为3000H的外部RAM&#x3D;A</span></pre></td></tr></table></figure><h2 id="变址寻址">变址寻址</h2><p>以DPTR或PC的内容加上A的内容之和为地址寻找操作数的寻址方式。它只有两条针对程序存储器的操作指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOVC A,@A+DPTR  ;（A+DPTR） → A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOVC A,@A+PC    ;（A+PC） → A</span></pre></td></tr></table></figure><h2 id="相对寻址">相对寻址</h2><p>以PC寄存器加上偏移量形成新的PC值作为转移地址的寻址方式，仅用于相对转移指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">SJMP 08 ;08+PC→PC</span></pre></td></tr></table></figure><h2 id="位寻址">位寻址</h2><p>寻址对象为片内RAM中20H～2FH中的128个位或SFR中的可位寻址的位，形式与直接寻址相同，究竟是位寻址还是直接寻址，由另一个操作数决定。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV C,20H ;位寻址，位地址为20H的内容送CY标志位（C&#x3D;CY）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV A,20H ;直接寻址</span></pre></td></tr></table></figure><h1 id="数据传送指令">数据传送指令</h1><h2 id="mov指令内部ramsfr之间的传送">MOV指令：内部RAM、SFR之间的传送</h2><ul><li>MOV A,Rn/dir/<span class="citation" data-cites="Ri">@Ri</span>/#data（只能传8位的数据）</li><li>MOV dir,A/Rn/dir/<span class="citation" data-cites="Ri">@Ri</span>/#data（dir间是可以直接互传的）</li><li>MOV Rn,A/dir/#data（Rn之间不行）</li><li>MOV <span class="citation" data-cites="Ri">@Ri</span>,A/dir/#data（Rn不行）</li><li>MOV DPTR,#data16</li></ul><h2 id="movx指令外部存储器和累加器a之间的传送">MOVX指令：外部存储器和累加器A之间的传送</h2><ul><li>MOVX <span class="citation" data-cites="Ri">@Ri</span>,A</li><li>MOVX <span class="citation" data-cites="DPTR">@DPTR</span>,A</li><li>MOVX A,<span class="citation" data-cites="Ri">@Ri</span></li><li>MOVX A,<span class="citation" data-cites="DPTR">@DPTR</span></li></ul><p>例如实现(2000H)→(2100H)，使用DPTR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV   DPTR  , #2000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOVX  A     , @DPTR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOV   DPTR  , #2100H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOVX  @DPTR , A</span></pre></td></tr></table></figure><p>使用Ri（Ri只能存8位数据）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV  P2，#20H  ;高位地址</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV  R0，#00   ;低位地址</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOVX A，@R0    ;读片外RAM</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOV  P2，#21H  ;改变高位地址</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">MOVX @R0，A    ;写片外RAM</span></pre></td></tr></table></figure><h2 id="movc访问程序存储器指令">MOVC：访问程序存储器指令</h2><p>主要用于查表，只能从程序存储器读取数据到A累加器，只能使用变址间接寻址方式。</p><ul><li>MOVC A，<span class="citation" data-cites="A+DPTR">@A+DPTR</span> ;A←(A+DPTR)，范围为64KB程序存储器任意空间；</li><li>MOVC A，<span class="citation" data-cites="A+PC">@A+PC</span> ;A←(A+PC)，范围为该指令后256B范围内。</li></ul><p>例如想查表格中的第二个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV  A,#01</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV  DPTR,#TAB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOVC A,@A+DPTR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">TAB：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">DB 66H, 77H, 88H,99H</span></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV  A,#02</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOVC A,@A+PC ;取完该指令后PC指向RET，RET占一个字节，所以要再往后移两字节是77H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">DB 66H, 77H, 88H,99H</span></pre></td></tr></table></figure><h1 id="堆栈操作指令">堆栈操作指令</h1><p>51单片机的堆栈设在内部RAM，SP为堆栈指针，初始化时SP指向07H，入栈时SP自动加1，出栈时SP自动减1。堆栈操作指令如下：</p><ul><li>入栈指令：PUSH dir ;SP←SP+1，(SP) ←(dir)</li><li>出栈指令：POP dir ;(dir)←(SP)，SP←SP-1</li></ul><h1 id="数据交换指令">数据交换指令</h1><h2 id="字节交换指令">字节交换指令</h2><ul><li>XCH A，Rn</li><li>XCH A，<span class="citation" data-cites="Ri">@Ri</span></li><li>XCH A，dir</li></ul><p>即XCH指令中一个操作数必须是A。</p><h2 id="低半字节交换指令">低半字节交换指令</h2><ul><li>XCHD A，<span class="citation" data-cites="Ri">@Ri</span></li></ul><h2 id="a的高低半字节交换指令">A的高低半字节交换指令</h2><ul><li>SWAP A</li></ul><h1 id="算术运算指令与逻辑运算指令">算术运算指令与逻辑运算指令</h1><h2 id="第一个操作数是a的">第一个操作数是A的</h2><ul><li>加：ADD</li><li>进位加：ADDC</li><li>借位减：SUBB</li><li>与：ANL</li><li>或：ORL</li><li>异或：XRL</li></ul><p>第二个可以是Rn，<span class="citation" data-cites="Ri">@Ri</span>，#data，dir。</p><p>除此之外，逻辑运算指令的第一个操作数还可以是dir，此时第二个操作数可以为A或#data。</p><p>ADDC为两数相加后还需加进位位（CY）；</p><p>SUBB为两数相减后还需减去进位位（CY），由于减指令没有SUB指令，所以在多字节减法程序中，最低位字节作减法时，注意要先清 CY。</p><p>除CY外，加减运算指令影响标志位OV、AC。逻辑运算是按位进行的，因此不影响CY、OV、AC标志位。</p><h2 id="自增自减">自增自减</h2><ul><li>加一：INC，操作数可以是Rn，<span class="citation" data-cites="Ri">@Ri</span>，<strong>DPTR</strong>，dir，A；</li><li>减一：DEC，操作数可以是Rn，<span class="citation" data-cites="Ri">@Ri</span>，dir，A，<strong>不能是DPTR</strong>。</li></ul><p>凡是指令执行结果在A累加器中，运行结果“1”的奇、偶性反映在P标志位（包括前面的传送指令和后面的移位指令）。</p><h2 id="十进制调整指令">十进制调整指令</h2><p>单片机中ADD指令完成的是二进制加法，如果要实现十进制相加（即BCD码相加）并得到十进制结果，必须进行十进制调整（即BCD码调整），调整指令：DA A，将A中二进制相加的和调整成十进制数（BCD码）。</p><p>调整方法：若和的低4位大于9或有半进位AC=1，则低4位加6；若和的高4位大于9或有进位CY=1，则高4位加6。</p><p>该指令只对加法ADD指令的和调整，不能对减法结果进行调整。所以应紧跟在加指令之后，在加指令和该指令之间不能有影响标志位的指令。</p><h2 id="专对a的指令">专对A的指令</h2><ul><li>A取反：CPL A</li><li>A清零：CLR A</li><li>循环右移：RR A</li><li>循环左移：RL A</li><li>向右到CY循环移：RLC A</li><li>向左到CY循环移：RRC A</li></ul><h2 id="乘法指令-mul-ab">乘法指令 MUL AB</h2><p>A、B中各放一8位无符号乘数，<strong>执行后16位积的高8位在B中，低8位在A中</strong>，使CY=0，当乘积大于255，OV置1。</p><p>例如A=50H，B=A0H，指令执行后A=00H，B=32H，CY=0，OV=1。</p><h2 id="除法指令-div-ab">除法指令 DIV AB</h2><p>A中放一8位无符号被除数、B中放一8位无符号除数，<strong>商在A中，余数在B中</strong>，使CY=0，若除数B=00H，则OV=1，A，B内容不变。</p><p>例如A=28H，B=12H，指令执行后，A=02H，B=04H,CY=0, OV=0。</p><h1 id="控制转移指令">控制转移指令</h1><p>这一类指令的功能是转到新的PC地址执行。</p><h2 id="子程序调用">子程序调用</h2><h3 id="长调用-lcall-addr16">长调用 LCALL addr16</h3><p>可用于保护断点和将子程序的入口地址送PC，转子程序执行，子程序可在64KB地址空间的任一处。</p><p>本指令的机器码为三字节。</p><h3 id="短调用-acall-addr11">短调用 ACALL addr11</h3><p>addr11→PC0～10,而PC11～15保持不变。因此地址范围2KB，如果用来调用子程序，子程序入口距当前PC不得超过2KB地址范围。</p><p>本指令的机器码为二字节。</p><h3 id="子程序返回指令">子程序返回指令</h3><ul><li>RET：从栈顶弹出断点到PC。</li><li>RETI：从中断服务程序返回。</li></ul><h2 id="无条件转移">无条件转移</h2><p>无条件转移到目的地址。</p><h3 id="短转移-ajmp-addr11">短转移 AJMP addr11</h3><p>类似ACALL。</p><h3 id="长转移-ljmp-addr16">长转移 LJMP addr16</h3><p>类似LCALL。</p><h3 id="间接转移常用于多路转移">间接转移（常用于多路转移）</h3><p>JMP <span class="citation" data-cites="A+DPTR">@A+DPTR</span>;A+DPTR→PC</p><h3 id="无条件相对转移">无条件相对转移</h3><p>SJMP rel;PC+rel→PC</p><h2 id="条件转移">条件转移</h2><p>满足条件转移到目的地址。</p><h3 id="累加器为零非零转移">累加器为零（非零）转移</h3><ul><li>JZ rel;A=0则转移（PC+rel→PC）否则程序顺序执行</li><li>JNZ rel;A≠0则转移（PC+rel→PC）否则程序顺序执行</li></ul><h3 id="减1不等于零转移">减1不等于零转移</h3><ul><li>DJNZ Rn,rel</li><li>DJNZ dir,rel</li></ul><p>本指令有自动减1功能。</p><h3 id="比较转移指令">比较转移指令</h3><ul><li>CJNE A , dir , rel</li><li>CJNE A , #data , rel</li><li>CJNE Rn , #data , rel</li><li>CJNE <span class="citation" data-cites="Ri">@Ri</span> , #data , rel</li></ul><p>CJNE指令都是3字节指令，作减操作，不回送结果，影响CY标志。若第一操作数大于或等于第二操作数，则标志CY=0。若第一操作数小于第二操作数，则CY=1——因此这几条指令除实现两操作数相等与否的判断外，利用对CY的判断，还可完成两数大小的比较。</p><h1 id="位操作指令">位操作指令</h1><p>位操作指令的对象只能是C和直接位地址，共17条，位的逻辑运算指令的目的操作数只能是C，而位地址有多种表达方式，以下D4H、PSW.4、RS1和ABC表示相同的位：</p><ul><li>用直接位地址表示，如D4H。</li><li>用“·”操作符号表示，如PSW.4，或D0H.4</li><li>用位名称表示，如RS1。</li><li>用BIT自定义名表示。如ABC BIT D4H，其中ABC定义为D4H位的位名。</li></ul><h2 id="位清零">位清零</h2><ul><li>CLR C</li><li>CLR bit</li></ul><h2 id="位置壹">位置壹</h2><ul><li>SETB C</li><li>SETB bit</li></ul><h2 id="位取反">位取反</h2><ul><li>CPL C</li><li>CPL bit</li></ul><h2 id="位与">位与</h2><ul><li>ANL C，bit ;CY∧（bit）→CY</li><li>ANL C，/bit ;CY∧（/bit）→CY</li></ul><h2 id="位或">位或</h2><ul><li>ORL C，bit ;CY∨（bit）→CY</li><li>ORL C，/bit ;CY∨（/bit）→CY</li></ul><h2 id="位传送">位传送</h2><ul><li>MOV C，bit</li><li>MOV bit,C</li></ul><h2 id="位转移">位转移</h2><p>根据位的值决定转移，均为相对转移指令。</p><ul><li>JC rel;CY=1，则转移（PC+rel→PC），否则程序顺序执行</li><li>JNC rel;CY=0,则转移（PC+rel→PC），否则程序顺序执行</li><li>JB bit，rel;(bit)=1,则转移（PC+rel→PC），否则程序顺序执行</li><li>JNB bit,rel;(bit)=0,则转移（PC+rel→PC），否则程序顺序执行</li><li>JBC bit,rel;(bit)=1,则转移（PC+rel→PC）且该位清零，否则程序顺序执行</li></ul><p>注意，没有位异或，如果要用位操作指令实现X=X0⊕X1，设X为ACC.0，X0为P1.0，X1为P1.1。</p><p>可以利用X0⊕X1=X0(/X1)+(/X0)X1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">X   BIT  ACC.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">X0  BIT   P1.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">X1  BIT   P1.1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOV  C,   X0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">ANL  C,   &#x2F;X1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">MOV  20H, C</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">MOV  C,   X1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ANL  C,   &#x2F;X0 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">ORL  C,   20H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">MOV  X,   C</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">SJMP $</span></pre></td></tr></table></figure><p>或根据异或规则——一数与“0”异或值不变；与“1”异或值变反：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ORG   0000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV   C  , X0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">JNB   X1 , NCEX    ;X1&#x3D;0，X&#x3D;C&#x3D;X0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">CPL   C</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">NCEX:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">MOV   X  , C       ;X1&#x3D;1，X&#x3D;C&#x3D;X0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">SJMP  $</span></pre></td></tr></table></figure><h1 id="空操作指令-nop">空操作指令 NOP</h1><p>机器码为00，该指令经取指、译码后不进行任何操作（空操作）而转到下一条指令，常用于生产一个机器周期的延时，或上机修改程序时作填充指令，以方便增减指令。</p><h1 id="伪指令">伪指令</h1><p>伪指令是为汇编程序（汇编器）提供信息的指令，它没有机器码，不被计算机执行。</p><h2 id="起始指令">起始指令</h2><p>ORG addr16</p><p>定义程序或数据块的起始地址。指示后面的程序或数据块以addr16为起始地址，存放在程序存储器中。</p><h2 id="字节定义">字节定义</h2><p>标号： DB （字节常数，或字符或表达式）</p><p>指示以标号为起始地址的单元里存放的数为字节数据 （8位二进制数）,例如<code>LN：DB  32，’C’，25H，-1</code>。</p><h2 id="字定义">字定义</h2><p>标号：DW （字常数或表达式）</p><p>指示在以标号为起始地址的单元里存放的数为字数据 （16位二进制数），例如<code>GH：DW 1234H,5678H,08</code>。</p><h2 id="保留字节">保留字节</h2><p>标号：DS （数值表达式）</p><p>指示在程序存储器中保留以标号为起始地址的若干字节单元，其单元个数由数值表达式指定，例如<code>L1：DS 32</code>：从L1地址开始保留32个存储单元。</p><h2 id="等值指令">等值指令</h2><p>标号 EQU （数值表达式）</p><p>表示EQU两边的量等值，用于为标号或标识符赋值。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">X1 EQU 2000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">X2 EQU 0FH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MAIN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">MOV  DPTR，#X1  ;DPTR&#x3D;2000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">ADD  A   ，#X2  ;A&#x3D;A+0FH</span></pre></td></tr></table></figure><h2 id="位定义">位定义</h2><p>标号 BIT [位地址]</p><p>同EQU指令，不过定义的是位操作地址，前面用到过。</p><h2 id="汇编结束-end">汇编结束 END</h2><p>指示源程序段结束，放在程序的最后。</p><h1 id="示例程序">示例程序</h1><h2 id="将内部ram26h单元的高4位清0">将内部RAM26H单元的高4位清0</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ANL  26H，#0FH</span></pre></td></tr></table></figure><h2 id="将外部ram2000h单元的高4位清0">将外部RAM2000H单元的高4位清0</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV  DPTR, #2000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOVX A, @DPTR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ANL  A, #0FH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR, A</span></pre></td></tr></table></figure><h2 id="若程序执行前40h3则执行后50h">若程序执行前(40H)=3则执行后(50H)=?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV  A,40H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV  DPTR,#TAB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOVC A,@DPTR+A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOV  50H,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">SJMP $</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">TAB: DB 1,4,9,16,25,36,49,64,81</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">;16</span></pre></td></tr></table></figure><h2 id="若程序执行前30h65则执行后40h41h">若程序执行前(30H)=65则执行后(40H)=?(41H)=?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV R0，#30H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV R1，#40H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOV A，@R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOV B，#10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">DIV AB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">MOV @R1，A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">INC R1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">MOV @R1，B</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">;6,5</span></pre></td></tr></table></figure><h2 id="位逻辑运算">位逻辑运算</h2><p>实现某种位逻辑运算，比如下图：</p><p><img src="" /></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV C    , P1.1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ANL C    , TF1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOV F0   , C</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">MOV C    , 22H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">ORL C    , &#x2F;P3.4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">ANL C    , &#x2F;F0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">MOV P1.2 , C</span></pre></td></tr></table></figure><h2 id="用djnz指令循环将片外ram区600h608h中的数传送到单片机片内ram区60h68h单元中">用DJNZ指令循环将片外RAM区600H<sub>608H中的数传送到单片机片内RAM区60H</sub>68H单元中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV DPTR，#600H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MOV R0，#60H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOV R7，#9</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">LOP：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">MOVX A，@DPTR </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">MOV  @R0，A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">INC  R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">INC  DPTR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">DJNZ R7，LOP</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;/center&gt;
    
    </summary>
    
    
      <category term="51单片机" scheme="http://mechanicalmind.cn/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>第一章：51单片机基础</title>
    <link href="http://mechanicalmind.cn/posts/386c1aa8.html"/>
    <id>http://mechanicalmind.cn/posts/386c1aa8.html</id>
    <published>2020-06-06T07:04:04.000Z</published>
    <updated>2020-06-06T07:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center>51单片机型号介绍与内部结构。</center><a id="more"></a><h1 id="单片机">单片机</h1><p>单片微型计算机(Single-Chip Microcomputer)，又称微控制器MCU(Micro Controller Unit)，是将计算机的基本部分微型化，使之集成在一块芯片上的微机。片内含有CPU、ROM、RAM、并行I/O、串行I/O、定时器/计数器、中断控制、系统时钟及系统总线等，它本身就是一个嵌入式系统。</p><p>市场占有最高的是8051系列单片机。51单片机最早由Intel公司推出，称为MCS-51。</p><p>51系列单片机有多种型号的产品，<strong>普通型主要有8031、 8051、8751、89C51、89S51</strong>等：</p><ul><li>8031片内没有ROM程序存储器(老产品，已被淘汰)；</li><li>8051内部设有4KB的掩模ROM程序存储器；</li><li>8751是将8051片内的ROM换成EPROM</li><li>89C51则换成4KB的闪速EEPROM；</li><li>89S51结构同89C51(可在线编程)；</li></ul><p>增强型的存储容量为普通型的一倍，名字是XXX52。</p><h1 id="单片机内部结构">51单片机内部结构</h1><ul><li>一个8位的CPU：<ul><li>运算器：可执行算术、逻辑、位运算，状态信息送PSW；</li><li>计数器PC：16位自动加一寄存器，存放指令地址，执行指令时，PC内容的低8位经P0口输出，高8位经P2口输出；</li><li>指令寄存器：从程序存储器读取指令代码至此；</li></ul></li><li>一个片内振荡器及时钟电路：<ul><li>内部震荡方式：在引脚XTAL1和XTAL2外接晶体振荡器，由于单片机内部有一个高增益运算放大器，当外接晶振后，就构成了自激振荡器并产生振荡时钟脉冲；</li><li>外部震荡方式：适宜用于使单片机的时钟与外部信号保持一致，外部信号接XTAL1即可，XTAL2悬空。</li><li>注：单片机的时序单位有：<ul><li>振荡周期：晶振的振荡周期，又称时钟周期，为最小的时序单位；</li><li>机器周期（MC）：<strong>1个机器周期由12个振荡周期组成。</strong>是计算机执行一种基本操作的时间单位；</li><li>指令周期：执行一条指令所需的时间。一个指令周期由1～4个机器周期组成，依据指令不同而不同。</li></ul></li></ul></li><li>复位电路，初始化单片机至一个确定的状态并从此状态开始工作，给复位引脚RST加5ms以上高电平时触发（如果系统不能工作，可尝试检查复位信号，若持续高电平则循环复位不执行），分为<strong>上电复位</strong>和<strong>开关复位</strong>，主要特殊功能寄存器复位状态归纳如下：<ul><li><strong>PC=0000H</strong>：表明程序从0000H地址单元开始执行（所以程序必须从0000H开始存放）。</li><li><strong>A=00H</strong>：表明累加器已被清零。</li><li><strong>PSW=00H</strong>：表明选寄存器0组为工作寄存器组。</li><li><strong>SP=07H</strong>：表明堆栈指针指向片内RAM07H单元，根据堆栈操作的先加后压法则，第一个被压入的数据被写入08H单元中。</li><li><strong>P0～P3=FFH</strong>：表明已向各端口线写入１，各端口既可用于输入又可用于输出。</li></ul></li><li>存储器（哈佛结构编址）：<ul><li>统一编址的4KBROM程序存储器和64KB外部程序存储器（0000H-FFFFH，0000H从程序存储器开始还是从外部程序存储器取决于EA的电平，EA接高电平时这个0000H是片内开始算否则片外），其中一些地址有专门作用：<ul><li>0000H：复位操作后的程序入口</li><li>0003H：外部中断0服务程序入口</li><li>000BH：定时器0中断服务程序入口</li><li>0013H：外部中断1服务程序入口</li><li>001BH：定时器1中断服务程序入口</li><li>0023H：串行口中断服务程序入口</li><li>002BH：定时器2中断服务程序入口（增强型）</li></ul></li><li>128BRAM数据存储器（00H-7FH，对于加强型，有256B，后半截使用寄存器间接寻址访问，直接寻址访问的是SFR），<strong>其中一些地址有专门作用</strong>：<ul><li>00H-1FH：共四组通用寄存器R0-R7，其中R0、R1可做间址寄存器，使用时通过PSW的RS1和RS0选择一组使用，默认0组，其它组作为数据存储器使用；</li><li>20H-2FH：可用于位寻址或字节寻址；</li><li>堆栈及数据存储区。</li></ul></li><li>特殊功能存储器SFR（Special Fuction Register），21个特殊功能寄存器不连续的分布在内部RAM的80H～FFH128个字节地址空间，对于加强型，使用直接寻址访问，间接寻址的话访问的是数据寄存器的后128B；</li><li>64KB外部数据存储器（0000H-FFFFH，与外部I/O口统一编址，使用相同的控制信号、寄存器间址和MOVX指令）。</li></ul></li><li>32条可编程的I/O线（四个8位并行I/O端口）；</li><li>两个16位定时器/计数器；</li><li>一个可编程全双工串行口；</li><li>五个中断源、两个优先级嵌套中断结构。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
51单片机型号介绍与内部结构。
&lt;/center&gt;
    
    </summary>
    
    
      <category term="51单片机" scheme="http://mechanicalmind.cn/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>实验三：键盘与电子管</title>
    <link href="http://mechanicalmind.cn/posts/5588866d.html"/>
    <id>http://mechanicalmind.cn/posts/5588866d.html</id>
    <published>2020-05-26T17:38:29.000Z</published>
    <updated>2020-05-26T17:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center>使用8255芯片拓展51单片机。</center><a id="more"></a><h1 id="环境">环境</h1><ul><li>Keil µVision3</li><li>ISIS 7 Pro</li></ul><h1 id="代码唐都单片机文档资料">代码（唐都单片机文档资料）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">; 文件名称: KeyScan.Asm</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">; 功能描述: 8255扩展IO, 完成键盘及数码管显示实验，按下按键, 数码管显示相应键值。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">;8255端口定义</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">A_8255EQU 7F00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">B_8255EQU 7F01H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">C_8255EQU 7F02H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">CON_8255EQU 7F03H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">ORG 0000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">LJMP MAIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">ORG 0100H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">MAIN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">MOV 50H,#00H;键值缓冲</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">MOV 51H,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">MOV 52H,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">MOV 53H,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">MOV R5, #53H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">MOV  A, #81H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">MOV  DPTR, #CON_8255;8255控制端口</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR, A;写入控制字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">BEGIN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">LCALL DIS;调用显示子程序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">LCALL CLEAR;清屏</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">LCALL CCSCAN;调用键扫子程序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">JNZ INK1;判是否有键按下</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">LJMP BEGIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">INK1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">LCALL DIS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">LCALL DL1MS;消除按键抖动</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">LCALL DL1MS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">LCALL CLEAR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">LCALL CCSCAN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">JNZ INK2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">AJMP BEGIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">INK2:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">MOV R2,#0FEH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">MOV R4,#00H;从第0列开始扫描</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">COLUM:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#A_8255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">MOV A,R2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR,A;写入列扫描值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">MOV DPTR, #C_8255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">MOVX A,@DPTR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">JB ACC.0,LINE1;判第0行的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">MOV A,#00H;第0行</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">AJMP KCODE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">LINE1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">JB ACC.1,LINE2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">MOV A,#04H;第1行</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">AJMP KCODE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">LINE2:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">JB ACC.2,LINE3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">MOV A,#08H;第2行</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">AJMP KCODE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">LINE3:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">JB ACC.3,NEXT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">MOV A, #0CH;第3行</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">KCODE:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">ADD A,R4;得到键值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">ACALL PUTBUF</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">PUSH ACC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">KON:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">ACALL DIS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">ACALL CLEAR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">ACALL CCSCAN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">JNZ KON</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">POP ACC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">NEXT:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">INC R4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">MOV A,R2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">JNB ACC.4,KERR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">RL A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">MOV R2,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">AJMP COLUM</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">KERR:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">AJMP BEGIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">CCSCAN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#A_8255;按键扫描</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">MOV A,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#C_8255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">MOVX A,@DPTR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">CPL A;取反</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">ANL A,#0FH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">CLEAR:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">MOV DPTR, #B_8255;清屏（共阴极段码送00H时，全灭）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">MOV A,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">DIS:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">PUSH ACC;显示</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">PUSH 00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">PUSH 03H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">MOV R0,#50H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">MOV R3,#0F7H;(显示4位时)11110111</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">MOV A,R3 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">AGAIN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#A_8255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">MOV A,@R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#DSEGS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line">MOVC A,@A+DPTR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#B_8255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line">ACALL DL1MS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line">INC R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">MOV A,R3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line">JNB ACC.0,OUT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">RR A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">MOV R3,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">AJMP AGAIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line">OUT:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line">POP 03H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line">POP 00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line">POP ACC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line">;数码管段显示值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line">DSEGS:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line">DB 03FH, 06H,05BH,04FH,066H,06DH,07DH, 07H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line">DB 07FH,06FH,077H,07CH,039H,05EH,079H,071H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line">DL1MS:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line">MOV R7,#01H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line">DL0:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line">MOV R6,#0FFH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">138</span></pre></td><td class="code"><pre><span class="line">DL1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">139</span></pre></td><td class="code"><pre><span class="line">DJNZ R6,DL1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">140</span></pre></td><td class="code"><pre><span class="line">DJNZ R7,DL0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">141</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">142</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">143</span></pre></td><td class="code"><pre><span class="line">PUTBUF:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">144</span></pre></td><td class="code"><pre><span class="line">PUSH 00H;保存键值到缓冲RAM中</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">145</span></pre></td><td class="code"><pre><span class="line">PUSH ACC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">146</span></pre></td><td class="code"><pre><span class="line">MOV A,R5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">147</span></pre></td><td class="code"><pre><span class="line">MOV R0,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">148</span></pre></td><td class="code"><pre><span class="line">POP ACC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">149</span></pre></td><td class="code"><pre><span class="line">MOV @R0,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">150</span></pre></td><td class="code"><pre><span class="line">DEC R5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">151</span></pre></td><td class="code"><pre><span class="line">CJNE R5,#04FH,GOBACK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">152</span></pre></td><td class="code"><pre><span class="line">MOV R5,#53H;重置缓冲地址</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">153</span></pre></td><td class="code"><pre><span class="line">GOBACK:POP 00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">154</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">155</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr></table></figure><h1 id="代码修改为按某键后显示特定内容">代码（修改为按某键后显示特定内容）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">;8255端口定义</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">A_8255EQU 7F00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">B_8255EQU 7F01H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">C_8255EQU 7F02H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">CON_8255EQU 7F03H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ORG 0000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">LJMP MAIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">ORG 0100H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">MAIN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">MOV 50H,#00H;键值缓冲清0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">MOV 51H,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">MOV 52H,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">MOV 53H,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">mov 54h,#00h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">mov 55h,#00h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">MOV R5, #55H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">MOV  A, #81H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">MOV  DPTR, #CON_8255;8255控制端口</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR, A;写入控制字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">BEGIN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">LCALL DIS;调用显示子程序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">LCALL CLEAR;清屏</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">LCALL CCSCAN;调用键扫子程序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">JNZ INK1;判是否有键按下</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">LJMP BEGIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">;键值缓冲</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">INK1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">MOV 50H,#06H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">MOV 51H,#05H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">MOV 52H,#04H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">MOV 53H,#03H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">mov 54h,#02h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">mov 55h,#01h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">LCALL DIS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">;LCALL DL1MS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">;LCALL DL1MS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">;LCALL CLEAR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">;LCALL CCSCAN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">;JNZ INK2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">AJMP BEGIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">;按键扫描</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">CCSCAN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#A_8255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">MOV A,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#C_8255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">MOVX A,@DPTR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">CPL A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">ANL A,#0FH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">;清屏</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">CLEAR:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">MOV DPTR, #B_8255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">MOV A,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">;显示</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">DIS:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">PUSH ACC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">PUSH 00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">PUSH 03H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">MOV R0,#50H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">MOV R3,#0DFH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">MOV A,R3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">AGAIN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#A_8255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">MOV A,@R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#DSEGS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">MOVC A,@A+DPTR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">MOV DPTR,#B_8255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">MOVX @DPTR,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">ACALL DL1MS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">INC R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">MOV A,R3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">JNB ACC.0,OUT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">RR A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">MOV R3,A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">AJMP AGAIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">OUT:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">POP 03H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">POP 00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">POP ACC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">;数码管段显示值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">DSEGS:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">DB 3FH,06H,5BH,4FH,66H,6DH,7DH,07H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">DB 7FH,6FH,77H,7CH,39H,5EH,79H,71H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">DL1MS:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">MOV R7,#01H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">DL0:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">MOV R6,#0FFH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">DL1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">DJNZ R6,DL1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">DJNZ R7,DL0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr></table></figure><h1 id="步骤">步骤</h1><p>实验电路如图，编程、编译、链接，在ISIS中载入<code>.HEX</code>和<code>.ASM</code>，调试程序，会弹出源程序（如果没弹出再添加一次<code>.ASM</code>），按F12即可：</p><p><img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/11.png" /></p><p><img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/12.png" /></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
使用8255芯片拓展51单片机。
&lt;/center&gt;
    
    </summary>
    
    
      <category term="51单片机" scheme="http://mechanicalmind.cn/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>实验二：跑马灯</title>
    <link href="http://mechanicalmind.cn/posts/6c782387.html"/>
    <id>http://mechanicalmind.cn/posts/6c782387.html</id>
    <published>2020-05-26T08:29:18.000Z</published>
    <updated>2020-05-26T08:29:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center>主要是熟悉单片机的集成功能模块，包括中断与计数器。</center><a id="more"></a><h1 id="环境">环境</h1><ul><li>Keil µVision3</li><li>ISIS 7 Pro</li></ul><h1 id="中断">中断</h1><h2 id="代码">代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &quot;SST89x5x4.h&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ORG 0000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">LJMP START</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ORG 0003H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">LJMP EINT0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">ORG 0013H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">LJMP EINT1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">START:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">MOV P1,#00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">SETB IT0;定义外部中断0为边沿触发</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">SETB EX0;使能外部中断0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">SETB IT1;定义外部中断1为边沿触发</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">SETB EX1;使能外部中断1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">SETB EA;使能总中断</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">SJMP $</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">;外部中断0中断服务程序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">EINT0:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">MOV R4, #04H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">ELP0:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">MOV P1, #0FFH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">ACALL DELAY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">MOV P1, #00H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">ACALL DELAY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">DJNZ R4, ELP0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">RETI</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">;外部中断1中断服务程序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">EINT1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">MOV A, #80H;初始状态为1000 0000</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">MOV R7, #28H;执行28H&#x3D;40次</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">ILP1:MOV P1, A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">RR A</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">ACALL DELAY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">DJNZ R7, ILP1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">RETI</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">;延时子程序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">DELAY:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">MOV R6, #0FFH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">DLP1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">MOV R5, #0FFH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">DLP2:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">DJNZ R5, DLP2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">DJNZ R6, DLP1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">RET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr></table></figure><h2 id="步骤">步骤</h2><ol type="1"><li><p>实验电路如图，编程、编译、链接，在ISIS中载入<code>.HEX</code>和<code>.ASM</code>； <img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/03.png" /></p></li><li><p>在ISIS中调试程序，会弹出源程序（如果没弹出再添加一次<code>.ASM</code>），按F12即可； <img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/04.png" /></p></li><li><p>两个开关都能按，可以看到效果，分别是全闪和从左向右跑马： <img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/05.png" /> <img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/06.png" /> <img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/07.png" /></p></li></ol><h1 id="定时计数器">定时/计数器</h1><h2 id="查询方式代码">查询方式代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &quot;SST89x5x4.h&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ORG 0000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">AJMP START</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ORG 0100H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">START:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">MOV TMOD, #60H;设置定时器&#x2F;计数器1为计数器方式, 且为方式2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">MOV TH1, #0F6H;装入计数初值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">MOV TL1, #0F6H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">SETB TR1;启动计数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">MLP1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">JNB TF1, MLP1;判溢出标志</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">CPL P1.0;取反P1.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">CLR TF1;清溢出标志</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">AJMP MLP1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr></table></figure><h2 id="中断方式代码">中断方式代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &quot;SST89x5x4.h&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ORG 0000h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">AJMP START</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ORG 001BH</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">AJMP MLP1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">START:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">MOV TMOD,#60H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">MOV TH1,#0F6H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">MOV TL1,#0F6H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">SETB TR1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">SETB ET1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">SETB EA</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">AJMP $</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">MLP1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">CPL P1.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">CLR TF0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">MOV TH1,#0F6H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">MOV TL1,#0F6H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">RETI</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr></table></figure><h2 id="步骤-1">步骤</h2><ol type="1"><li><p>实验电路如图，编程、编译、链接，在ISIS中载入<code>.HEX</code>和<code>.ASM</code>； <img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/08.png" /></p></li><li><p>在ISIS中调试程序，会弹出源程序（如果没弹出再添加一次<code>.ASM</code>），按F12即可； <img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/09.png" /></p></li><li><p>两个开关都能按，可以看到效果，每按10次最右的灯反转一次： <img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/10.png" /></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
主要是熟悉单片机的集成功能模块，包括中断与计数器。
&lt;/center&gt;
    
    </summary>
    
    
      <category term="51单片机" scheme="http://mechanicalmind.cn/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>实验一：数据排序</title>
    <link href="http://mechanicalmind.cn/posts/ad5f8869.html"/>
    <id>http://mechanicalmind.cn/posts/ad5f8869.html</id>
    <published>2020-05-25T07:40:20.000Z</published>
    <updated>2020-05-25T07:40:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center>在Keil中调试冒泡，主要是熟悉Keil的使用。</center><a id="more"></a><h1 id="环境">环境</h1><ul><li>Keil µVision3</li></ul><h1 id="代码">代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ORG 0000H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">LJMP MAIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ORG 0100H</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">MAIN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">MOV R0, #30H;R0&#x3D;数据起始地址</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">MOV R7, #09H;R7&#x3D;数据个数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">LP1:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">MOV A, R7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">MOV R6, A;R6&#x3D;R7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">MOV A, R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">MOV R1, A;R1&#x3D;R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">INC R1;++R1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">LP2:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">MOV A, @R0;A&#x3D;(R0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">CLR C;清进位标志</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">SUBB A, @R1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">JC LP3;if(A&lt;&#x3D;(R1)) goto LP3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">MOV A, @R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">XCH A, @R1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">MOV @R0, A;swap((R0),(R1))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">LP3:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">INC R1;++R1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">DJNZ R6, LP2;if(--R6) goto LP2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">INC R0;++R0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">DJNZ R7, LP1;if(--R7) goto LP1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">SJMP $</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">END</span></pre></td></tr></table></figure><h1 id="步骤">步骤</h1><ol type="1"><li>编程，编译，链接，调试；</li><li><p>为30H～39H赋初值：在命令行中键入<code>E CHAR D:30H＝10个数逗号隔开</code>后回车； <img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/01.png" /></p></li><li><p>将光标移到语句行SJMP $处，点击命令，将程序运行到该行，可在右下（如果没有就在视图还是哪里调出来）观察排序结果。 <img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/%E5%8D%95%E7%89%87%E6%9C%BA/02.png" /></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
在Keil中调试冒泡，主要是熟悉Keil的使用。
&lt;/center&gt;
    
    </summary>
    
    
      <category term="51单片机" scheme="http://mechanicalmind.cn/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>51单片机开发环境配置</title>
    <link href="http://mechanicalmind.cn/posts/d5919c41.html"/>
    <id>http://mechanicalmind.cn/posts/d5919c41.html</id>
    <published>2020-05-06T08:03:28.000Z</published>
    <updated>2020-05-06T08:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center>Keil µVision3/4 + Proteus ISIS.</center><a id="more"></a><h1 id="环境">环境</h1><p>一开始打算通过安装native Linux的软件来配置开发环境，例如SDCC等，但最后发现还是通过wine安装windows的软件最方便。环境如下：</p><ul><li>wine 5.7-1</li><li>winetricks 20200412-1</li></ul><p>开发环境主要有两个部分，一是Keil µVision，为ARM旗下的KEIL公司开发的一个IDE；二是Proteus，为Lab Center Electronics公司推出的电子设计自动化（EDA）软件，主要用到其ISIS组件的仿真功能。</p><h1 id="keil">Keil</h1><p>本来是打算安装官方的面向学习者的Lite版本，但是官网的下载页面打不开……</p><p>Keil的安装包有“MDK”后缀和“C51”后缀两种，分别对应ARM的芯片和8051的芯片。一开始搞错了，使用了<code>MDK412</code>的版本。</p><p>首先正常安装安装包（wine挺慢的，要等很久才能打开），然后正常打开，进入<code>File</code>-&gt;<code>License Management</code>，复制CID，打开注册码生成机，输入CID，选ARM，生成注册码再输回去即可。</p><p>之后才发现这个版本的uVision貌似不带51单片机相关的开发套件，于是又找到了<code>c51v802</code>版本来安装，两次安装到一个文件夹，完成后发现生成了新的<code>c51v802</code>的快捷方式，但再次打开原先<code>MDK412</code>的快捷方式，发现已经可以建立51单片机相关的工程了，但在<code>MDK412</code>中调试会提示不兼容，如果有P1等寄存器连编译都通不过。</p><p>关于Keil的使用，先新建一个页面，写入代码，保存（汇编就<code>.asm</code>后缀、c51就<code>.c</code>后缀），在项目上右键添加到项目，就可以编译了。</p><p>编译的时候要注意设置，一是在<code>Device</code>选项卡中把两个框都勾上，否则报错“FATAL ERROR L210”；二是在<code>Output</code>选项卡中勾上“Create HEX File”。</p><h1 id="proteus">Proteus</h1><p>笔者所使用的安装包来自<a href="http://www.pc6.com/softview/SoftView_55565.html" target="_blank" rel="noopener">这里</a>，按说明安装即可（但是汉化完后少部分字符会乱码，似乎是wine的问题，注意备份原文件）。</p><p>安装完成后可以导入<code>.DSN</code>工程文件，导入工程文件后可在其单片机上双击调出属性窗口，导入<code>.HEX</code>文件；工程文件可能指定了<code>.ASM</code>文件的路径，需要在<code>源代码</code>-&gt;<code>添加/删除源文件</code>处删除之。</p><p>开始调试后在<code>调试</code>菜单最下面几行可以打开看内存的值。</p><h1 id="小结">小结</h1><p>至此，51单片机开发环境配置完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
Keil µVision3/4 + Proteus ISIS.
&lt;/center&gt;
    
    </summary>
    
    
      <category term="51单片机" scheme="http://mechanicalmind.cn/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>弱小的人，才习惯嘲讽和否定</title>
    <link href="http://mechanicalmind.cn/posts/18d24c8.html"/>
    <id>http://mechanicalmind.cn/posts/18d24c8.html</id>
    <published>2020-05-06T08:02:38.000Z</published>
    <updated>2020-05-06T08:02:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center>最近两天都在思考这句话，再抬头看，发现整个世界都不一样了。</center><a id="more"></a><blockquote><p>在自然语言和形式语言中，如果一句句子直接或间接提及自身，就称为自指（Self-reference）。</p></blockquote><p>生活中经常见到自指，比如“我随手一打就是这么标准的十五字”。这个自指很安全，但是许多情况下自指是危险的，比如“弱小的人，才习惯嘲讽和否定”，如果说话的人认为这句话是对的，那么他将不得不（当然，这里忽略了“习惯”二字）承认自己是弱小的。</p><p>一个更熟悉的例子，“停机问题”：能否写出这样一个判断程序，输入一个程序及其传入参数时，这个判断程序能够判断此时输入程序是否陷入死循环？</p><p>不难证明，答案是否定的：假如写出了这样一个程序<code>bool isLoop(func input_func, para input_para)</code>，当输入程序<code>input_func()</code>在接受<code>input_para</code>后将陷入死循环时返回<code>1</code>，否则返回<code>0</code>——现在不妨将其改写一个很hack的程序<code>void hack(func input)</code>，在其中调用一次<code>isLoop()</code>，其中的两个参数均为<code>input</code>，当<code>isLoop()</code>返回<code>true</code>即<code>input()</code>在传入<code>input()</code>时会陷入死循环时，<code>hack()</code>返回，否则进入一段类似<code>while(true)</code>的代码。</p><p>现调用一次<code>isLoop(hack,hack)</code>：</p><ul><li>若返回<code>true</code>，则<code>hack()</code>在输入<code>hack()</code>时将陷入死循环，则<code>hack(hack)</code>中调用的<code>isLoop(hack,hack)</code>返回了<code>false</code>，矛盾；</li><li>若返回<code>false</code>，则<code>hack()</code>在输入<code>hack()</code>时不会陷入死循环，则<code>hack(hack)</code>中调用的<code>isLoop(hack,hack)</code>返回了<code>true</code>，矛盾。</li></ul><p>故写不出这样的程序。</p><p>这个例子比让B站和背后站台的一票大媒体承认自己是弱小的危险一点，但还好。现在用类似的方法构造一个更危险的命题，也就是著名的罗素悖论：</p><p>假设有一个集合，该集合为全体非本身子集构成的集合。现给定该集合的一个子集，问后者是否属于前者？</p><ul><li>后者是前者的子集，则后者不应当属于前者；</li><li>假如后者不属于前者，则后者不是前者的子集。</li></ul><p>故这样的集合不存在——但它应当是存在的。给定一个性质，符合该性质的元素归入一个集合，这不是理所应当的么？集合的定义就是这样的啊！</p><p>对于这个悖论的处理，数学大佬们是修改了集合的定义，比如罗素本人的类型论和现在主流的公理化集合论，在笔者看来都是用很hack的手法排除了这些涉及自我指涉的情况，笔者作为一个数学的门外汉觉得……emmm，好像这种不算解决吧？类似假装看不见的行为……</p><p>很容易从这上面联想到哥德尔不完备定理。虽然笔者并未研究过其推导等，但对结论的了解应该偏差不大，即不能从一个足够复杂的形式化系统中推导出它应当包含的所有命题，笔者不清楚“自指”一类的问题相关的结论是否属于这一类，但显然“集合论”这一系统无力处理这一情况。</p><p>在今天之前，笔者一直坚信没有什么是数学无法处理的，只要数学家能搞明白，程序员就能给它整得服服贴贴。当初转专业时曾看过许多知乎上的经验贴，印像最深的是一位国际关系的学长转数学系，立志要写出一本《社会科学的数学原理》。现在想来，恐怕他的志向比想象中还要难得多吧，现在的数学工具对于如此复杂的系统真的能进行足够好的描述么？最著名的无解的就是三体问题了吧，这还只是三个球而已。</p><p>——提到三体，突然想到有些科幻小说中有所谓“数学武器”的设定，可以修改区域内的数学规律使敌人的武器等失去理论基础而失效。看似荒谬至极的设定现在看来也有那么点道理——数学规律真的是宇宙内秉的么？还是只是人类发明的？</p><p>当然，哥德尔可没说“人类是有极限的”，只是说一个形式化的系统是有极限的，而人类可以构建很多不同的形式化系统，在一个形式化系统中不可证明的命题在另一个形式化系统中便可能可以证明，所以笔者的信仰并没有完全破碎，哈哈。哥德尔只是说不能仅仅根据公理通过推导得出所有结论——回到题目的这句话，不论这句话本身意义如何，试图用一句话讲明白某个道理（因为“弱小……”这句话冲突性不够强，再举个例子：没有什么是绝对的。这只是“自指”这一种难以处理的情况，谁知道有多少其它情况？）本身就是错误的思想——如此错综复杂的世界，显然超出了一句话加上简单推理所能判断的能力范围。</p><p>我们不能只用有限的、形式化的方式给这世界下判断，无论是数学的、程序的还是自然语言的——想到这里再抬头看这世界，顿感广袤无垠。</p><p>上一段用一句话下了个判断，矛盾，所以上一句话是伪命题，散了吧。</p><p>我知道为啥哲学家自杀的多了。</p><p>其实就是学得少，想得多。不想了，还是开心最重要～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
最近两天都在思考这句话，再抬头看，发现整个世界都不一样了。
&lt;/center&gt;
    
    </summary>
    
    
      <category term="地球Online加载Tips" scheme="http://mechanicalmind.cn/categories/%E5%9C%B0%E7%90%83Online%E5%8A%A0%E8%BD%BDTips/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="http://mechanicalmind.cn/posts/49618a82.html"/>
    <id>http://mechanicalmind.cn/posts/49618a82.html</id>
    <published>2020-05-04T08:40:10.000Z</published>
    <updated>2020-05-04T08:40:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center>Socket的TCP和UDP通信相关函数的使用。</center><a id="more"></a><h1 id="socket">Socket</h1><blockquote><p>socket 是计算机网络中用于在节点内发送或接收数据的内部端点。具体来说，它是网络软件（协议栈）中这个端点的一种表示，包含通信协议、目标地址、状态等，是系统资源的一种形式。</p></blockquote><p>即socket将除应用层之外的四个网络层次封装，应用层的程序员只需调用其提供的方法即可实现网络通信；socket的原意是插座，一边连接供电网络，用电器的工程师只需在设计电器时设计好插头就行了，一个道理。一个插座有三个主要属性：在谁家里、在哪个房间以及能插什么电器（USB充电口还是三个脚的插口还是两个脚的插口，是国标220V还是多少），同样Socket的属性也是一个三元组：<code>(IP,protocol,port)</code>，使用以下数据结构表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family; <span class="comment">//协议域</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">//协议地址（14字节形式）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述结构使用较少，实际常用如下等价形式：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> sin_family;<span class="comment">//协议域</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port;<span class="comment">//端口号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">//地址，见下</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">//留空以使该结构的大小与sockaddr统一</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//此数据结构表示一个32位的IPv4地址。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">in_addr_t</span> s_addr<span class="comment">//ipv4地址</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure><p>另外在传输数据时，不同机器内部对变量的字节存储顺序不同，因此要对数据进行转换统一一下：</p><ul><li><code>htons()</code>：“Host to Network Short”，主机字节顺序转换为网络字节顺序（对无符号短型进行操作2bytes）；</li><li><code>htonl()</code>：“Host to Network Long ”，主机字节顺序转换为网络字节顺序（对无符号长型进行操作4bytes）；</li><li><code>ntohs()</code>：“Network to Host Short”，网络字节顺序转换为主机字节顺序（对无符号短型进行操作2bytes）；</li><li><code>ntohl()</code>：“Network to Host Long ”，网络字节顺序转换为主机字节顺序（对无符号长型进行操作4bytes）；</li></ul><p>具体的协议有关的内容是计网的内容，王道的计网小姐姐声音真好听……</p><p>以一个聊天室程序演示之。</p><h1 id="tcp编程示例">TCP编程示例</h1><h2 id="服务器">服务器</h2><ol type="1"><li>创建一个socket：<code>int socket(int domain, int type, int protocol)</code>，传入协议域、socket类型和协议，该函数返回一个socket标识符（可能需要设置其属性：<code>setsockopt()</code>）；</li><li>设置自己的IP地址、端口等信息并绑定：<code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)</code>，传入一个socket标识符、要绑定的地址（根据socket的协议域不同而不同）和这个地址的长度，将该socket与一个地址绑定。服务器需要这么绑定一下，客户端的话让系统自动分配就行了；</li><li>开启监听：<code>int listen(int sockfd, int backlog)</code>，第二个参数是可以排队的最大数量；</li><li>接收客户端的连接请求：<code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)</code>，传入服务器本身的socket、协议地址及其长度（因为要返回给客户端这些信息），返回一个与接入的客户端的链接的socket；</li><li>收发数据：<code>ssize_t send(int sockfd, const void *buf, size_t len, int flags)</code>和<code>ssize_t recv(int sockfd, void *buf, size_t len, int flags)</code>（或一些其它函数）；</li><li>关闭socket：<code>int close(int fd)</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 1234</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKLOG 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1024</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[MAXSIZE];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; client_list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret_recv, listenfd, fd;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>, <span class="title">client</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_service</span><span class="params">(<span class="keyword">void</span> *sfd)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> fd = *(<span class="keyword">int</span> *)sfd;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        bzero(buf, MAXSIZE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        ret_recv = recv(fd, buf, MAXSIZE, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (ret_recv &lt;= <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            client_list.erase(fd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"client "</span> &lt;&lt; fd &lt;&lt; <span class="string">" quited."</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = client_list.begin(); it != client_list.end(); ++it)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (*it != fd)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                    send(*it, buf, ret_recv, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"from "</span> &lt;&lt; fd &lt;&lt; <span class="string">" to "</span> &lt;&lt; *it &lt;&lt; <span class="string">" forwarded."</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    close(fd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"starting server..."</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        perror(<span class="string">"socket creating failed."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    server.sin_family = AF_INET;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    server.sin_port = htons(PORT);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    server.sin_addr.s_addr = htonl(INADDR_ANY);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (bind(listenfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(struct sockaddr)) == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        perror(<span class="string">"Bind error."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (listen(listenfd, BACKLOG) == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        perror(<span class="string">"listen() error\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"success!"</span>&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//一开始accept()第三个参数写的是(socklen_t*)sizeof(struct sockaddr_in)，跟正确写法不等价！</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">socklen_t</span> size = <span class="keyword">sizeof</span>(struct sockaddr_in);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((fd = accept(listenfd, (struct sockaddr *)&amp;client, &amp;size)) == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">            perror(<span class="string">"accept() error\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        client_list.insert(fd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">pthread_t</span> tid;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, pthread_service, &amp;fd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">    close(listenfd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="客户端">客户端</h2><ol type="1"><li><code>socket()</code>（可选<code>setsockopt()</code>、<code>bind()</code>，参见服务器）；</li><li>设置要连接的对方的IP地址和端口等属性并连结：<code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)</code>，类似<code>accept()</code>地，传入的是客户端自己的标识符，返回一个连接的标识符；</li><li>收发数据：<code>send()</code>和<code>recv()</code>;</li><li>关闭：<code>close()</code>；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 1234</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1024</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOST <span class="meta-string">"127.0.0.1"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> sendbuf[<span class="number">1024</span>], recvbuf[<span class="number">1024</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> msg, usrname;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_recv</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((recv(fd, recvbuf, MAXN, <span class="number">0</span>)) == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            perror(<span class="string">"recv() error\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, recvbuf);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(recvbuf));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no username inputed."</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    usrname = argv[<span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"link start..."</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        perror(<span class="string">"socket() error\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    server.sin_family = AF_INET;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    server.sin_port = htons(PORT);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    server.sin_addr = *((struct in_addr *)gethostbyname(HOST)-&gt;h_addr);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (connect(fd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(struct sockaddr)) == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        perror(<span class="string">"connect() error\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"success!"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    msg = usrname + <span class="string">" has entered.\n"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    send(fd, msg.c_str(), msg.length(), <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">pthread_t</span> tid;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, pthread_recv, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(sendbuf));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        fgets(sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">///用cin好像会导致不能输出东西……</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        msg = sendbuf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (msg == <span class="string">"q\n"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"quited.\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">            msg = usrname + <span class="string">" has quited.\n"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">            send(fd, msg.c_str(), msg.length(), <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">            close(fd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">            msg = usrname + <span class="string">" : "</span> + msg;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">            send(fd, msg.c_str(), msg.length(), <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h1 id="udp编程示例">UDP编程示例</h1><h2 id="服务器-1">服务器</h2><ol type="1"><li>创建一个socket：<code>socket()</code>，可选<code>setsockopt()</code>；</li><li>设置与绑定IP地址、端口等信息：<code>bind()</code>；</li><li>循环接收数据：<code>recvfrom()</code>；</li><li>关闭网络连接；</li></ol><h2 id="客户端-1">客户端</h2><ol type="1"><li><code>socket()</code>（可选<code>setsockopt()</code>、<code>bind()</code>，参见服务器）；</li><li>设置对方的IP地址和端口等属性;</li><li>发送数据：<code>sendto()</code>;</li><li>关闭网络连接；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
Socket的TCP和UDP通信相关函数的使用。
&lt;/center&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://mechanicalmind.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux多线程</title>
    <link href="http://mechanicalmind.cn/posts/293980e9.html"/>
    <id>http://mechanicalmind.cn/posts/293980e9.html</id>
    <published>2020-05-04T08:40:00.000Z</published>
    <updated>2020-05-04T08:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center></center><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;/center&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://mechanicalmind.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux进程间通信</title>
    <link href="http://mechanicalmind.cn/posts/e0738fea.html"/>
    <id>http://mechanicalmind.cn/posts/e0738fea.html</id>
    <published>2020-05-04T08:39:41.000Z</published>
    <updated>2020-05-04T08:39:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center></center><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;/center&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://mechanicalmind.cn/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title> 蓝桥杯2020模拟赛</title>
    <link href="http://mechanicalmind.cn/posts/33d846cd.html"/>
    <id>http://mechanicalmind.cn/posts/33d846cd.html</id>
    <published>2020-03-16T09:24:55.000Z</published>
    <updated>2020-03-16T09:24:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center>2020年蓝桥杯因为疫情延期，搞了个线上模拟赛。讲真，完全没有也不想准备这比赛了，要是干脆取消这一届退钱就好了……</center><a id="more"></a><h1 id="单位换算">单位换算</h1><p>侮辱智商，拒绝作答。</p><h1 id="约数统计">约数统计</h1><p>暴力。</p><h1 id="在1至2019中有多少个数的数位中包含数字9">在1至2019中，有多少个数的数位中包含数字9？</h1><p>因为是各自在家比赛，其实是可以百度的。想找找stl里有没有啥逃课的方法，果然找到了个<code>find()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2019</span>;++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">string</span> cur=to_string(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(cur.find(<span class="string">'9'</span>)!= cur.npos)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            ++cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>注意如果找不到返回的是<code>string.npos</code>而不是0或-1之类。</p><h1 id="树的结点数">树的结点数</h1><p>总觉得这题做过好多好多次了……</p><h1 id="寻找数位递增的数">寻找数位递增的数</h1><p>写的转string暴力一位一位比。不过事后一想可能会超时？最多的样例会有百万次判断，按每次判断进行4次比较算一秒钟应该也OK……</p><p>看到有大佬用DP：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, a[<span class="number">11</span>], dp[<span class="number">11</span>][<span class="number">10</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> pre, <span class="keyword">bool</span> limit)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!limit &amp;&amp; dp[pos][pre] != <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[pos][pre];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> up = limit ? a[pos] : <span class="number">9</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pre; i &lt;= up; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        ans += dfs(pos - <span class="number">1</span>, i, limit &amp;&amp; i == a[pos]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!limit)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        dp[pos][pre] = ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//注意数组和原数相反了，现在是找递减。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        a[k++] = n % <span class="number">10</span>,n /= <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; dfs(k - <span class="number">1</span>, <span class="number">0</span>, <span class="literal">true</span>) - <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h1 id="寻找hello这样的单词">寻找hello这样的单词</h1><p>字符串判断的题。</p><h1 id="寻找递增三元组的中心">寻找递增三元组的中心</h1><p>上来先写了判断是否存在递增三元组的代码，每找到一个就记录这个三元组的中心，看最后有多少个中心：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,num[N],min1,min2,idx_min2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cin</span>&gt;&gt;num[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    min1=min2=INF;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (num[i]&lt;=min1) min1 = num[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[i] &lt; min2) min2 = num[i],idx_min2=i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt; min2) s.insert(idx_min2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.size();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>写完发现不对，这个算法是判断是否存在三元组的，不是找到所有三元组，对于有许多递增三元组的数列它找不全，例如数列<code>1 2 5 3 5</code>，它只会给出<code>1 2 5</code>、<code>1 2 3</code>和<code>1 2 5</code>，<code>1 3 5</code>不会给出，所以对这个样例来说会少掉“3”这一中心。</p><p>最后用的笨方法，对每个数判断之前、之后的最小、最大值，不过使用两个数组保存某位置之前的最小值、之后的最大值，只需一遍遍历，其实很快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, num[N], max_after_cur_idx[N], min_befor_cur_idx[N], ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    min_befor_cur_idx[<span class="number">0</span>] = num[<span class="number">0</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    max_after_cur_idx[n - <span class="number">1</span>] = num[n - <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        min_befor_cur_idx[i] = min(min_befor_cur_idx[i - <span class="number">1</span>], num[i]),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        max_after_cur_idx[n - <span class="number">1</span> - i] = max(max_after_cur_idx[n - i], num[n - <span class="number">1</span> - i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (min_befor_cur_idx[i - <span class="number">1</span>] &lt; num[i] &amp;&amp; max_after_cur_idx[i + <span class="number">1</span>] &gt; num[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            ++ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h1 id="满足条件的数列">满足条件的数列</h1><p>DFS。</p><h1 id="草坪扩张">草坪扩张</h1><p>BFS，跟淹海岛的题一样。</p><h1 id="组织晚会">组织晚会</h1><p>小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。</p><p>小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。</p><h2 id="输入格式">输入格式：</h2><p>输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。</p><p>第二行包含 n 个整数，依次为每个节目的好看值。</p><h2 id="输出格式">输出格式：</h2><p>输出一行包含 m 个整数，为选出的节目的好看值。</p><h2 id="样例输入">样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">5 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">3 1 2 5 4</span></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">3 5 4</span></pre></td></tr></table></figure><h2 id="样例说明">样例说明</h2><p>选择了第1, 4, 5个节目。</p><h2 id="评测用例规模与约定">评测用例规模与约定</h2><p>对于 30% 的评测用例，1 &lt;= n &lt;= 20；</p><p>对于 60% 的评测用例，1 &lt;= n &lt;= 100；</p><p>对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。</p><h2 id="解">解</h2><p>这题想了好久……后来网上找到解法发现极为简单，好吧，这么简单的代码居然是最后一道题，不知道是不是预料到大家会往复杂了想。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, cur;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> idx, val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;node&gt; ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_val</span><span class="params">(node a, node b)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a.val &gt; b.val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_idx</span><span class="params">(node a, node b)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a.idx &lt; b.idx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; <span class="built_in">cin</span> &gt;&gt; cur; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        ans.push_back(&#123;i, cur&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//从大到小排列节目</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    sort(ans.begin(), ans.end(), cmp_val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//最大的m个再按编号从小到大排列</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    sort(ans.begin(), ans.begin() + m, cmp_idx);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>].val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[i].val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
2020年蓝桥杯因为疫情延期，搞了个线上模拟赛。讲真，完全没有也不想准备这比赛了，要是干脆取消这一届退钱就好了……
&lt;/center&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://mechanicalmind.cn/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="蓝桥杯" scheme="http://mechanicalmind.cn/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="蓝桥杯" scheme="http://mechanicalmind.cn/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>沉痛悼念李文亮医生</title>
    <link href="http://mechanicalmind.cn/posts/a37770e.html"/>
    <id>http://mechanicalmind.cn/posts/a37770e.html</id>
    <published>2020-02-07T11:37:24.000Z</published>
    <updated>2020-02-07T11:37:24.000Z</updated>
    
    <content type="html"><![CDATA[<center>R.I.P.</center><a id="more"></a><p><img src="https://blog-1256194686.cos.ap-shanghai.myqcloud.com/lwl.jpg" /></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;
R.I.P.
&lt;/center&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PAT (Advanced Level) Practice 1003 Emergency</title>
    <link href="http://mechanicalmind.cn/posts/224301ee.html"/>
    <id>http://mechanicalmind.cn/posts/224301ee.html</id>
    <published>2020-01-17T14:10:26.000Z</published>
    <updated>2020-01-18T12:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="" /></p><center></center><a id="more"></a><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p><p>Input Specification:</p><p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: <span class="math inline">\(N (≤500)\)</span> - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers <span class="math inline">\(c_1\)</span>, <span class="math inline">\(c_2\)</span> and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from <span class="math inline">\(C_1\)</span> to <span class="math inline">\(C_2\)</span>.</p><p>Output Specification: For each test case, print in one line two numbers: the number of different shortest paths between <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> , and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p><p>Sample Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">5 6 0 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1 2 1 5 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">0 1 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">0 2 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">0 3 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">1 2 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">2 4 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">3 4 1</span></pre></td></tr></table></figure><p>Sample Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">2 4</span></pre></td></tr></table></figure><p>看题目第一反应呀Dijkstra稍微改改，简单，一想诶Dijkstra咋写的来着忘掉了，这尼玛就很尴尬了。</p><p>首先存储顶点间边的关系，以样例为例：</p><table><thead><tr class="header"><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr class="odd"><td><strong>0</strong></td><td>0</td><td>1</td><td>2</td><td>1</td><td></td></tr><tr class="even"><td><strong>1</strong></td><td></td><td>0</td><td>1</td><td></td><td></td></tr><tr class="odd"><td><strong>2</strong></td><td></td><td></td><td>0</td><td></td><td>1</td></tr><tr class="even"><td><strong>3</strong></td><td></td><td></td><td></td><td>0</td><td>1</td></tr><tr class="odd"><td><strong>4</strong></td><td></td><td></td><td></td><td></td><td>0</td></tr></tbody></table><p>因为是无向图，所以反过来也成立：</p><table><thead><tr class="header"><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr class="odd"><td><strong>0</strong></td><td>0</td><td>1</td><td>2</td><td>1</td><td></td></tr><tr class="even"><td><strong>1</strong></td><td>1</td><td>0</td><td>1</td><td></td><td></td></tr><tr class="odd"><td><strong>2</strong></td><td>2</td><td>1</td><td>0</td><td></td><td>1</td></tr><tr class="even"><td><strong>3</strong></td><td>1</td><td></td><td></td><td>0</td><td>1</td></tr><tr class="odd"><td><strong>4</strong></td><td></td><td></td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>其它到不了，距离为无穷：</p><table><thead><tr class="header"><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr class="odd"><td><strong>0</strong></td><td>0</td><td>1</td><td>2</td><td>1</td><td><span class="math inline">\(\infin\)</span></td></tr><tr class="even"><td><strong>1</strong></td><td>1</td><td>0</td><td>1</td><td><span class="math inline">\(\infin\)</span></td><td><span class="math inline">\(\infin\)</span></td></tr><tr class="odd"><td><strong>2</strong></td><td>2</td><td>1</td><td>0</td><td><span class="math inline">\(\infin\)</span></td><td>1</td></tr><tr class="even"><td><strong>3</strong></td><td>1</td><td><span class="math inline">\(\infin\)</span></td><td><span class="math inline">\(\infin\)</span></td><td>0</td><td>1</td></tr><tr class="odd"><td><strong>4</strong></td><td><span class="math inline">\(\infin\)</span></td><td><span class="math inline">\(\infin\)</span></td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>再用一个数组存储始点到其余点的路程：<span class="math inline">\(0,1,2,1,\infin\)</span>。</p><p>接下来不停贪心，每次取距起点最近的点，并判断能否由这个点到其它点使距离变短。例如现在1和3距起点0最近，所以取1，判断到除起点0和当前点1之外其它点的距离有没有变短：</p><ul><li><code>1-&gt;2</code>为1加<code>0-&gt;1</code>为2没变；</li><li><code>1-&gt;3</code>为无穷加<code>0-&gt;1</code>为无穷变大了；</li><li><code>1-&gt;4</code>为无穷加<code>0-&gt;1</code>为无穷变大了。</li></ul><p>再取下一个点3，判断到除起点0和判断过的点1和当前点3之外其它点的距离有没有变短：</p><ul><li><code>3-&gt;2</code>为无穷加<code>0-&gt;3</code>为无穷变大了；</li><li><code>3-&gt;4</code>为1加<code>0-&gt;3</code>为2变小了。</li></ul><p>新的数组为<span class="math inline">\(0,1,2,1,2\)</span>。</p><p>因为这题的目标点是2，而现在2已经是没判断过的点中距离最小的了，所以可以结束。若想知道起点到所有点的最短距离只需对2和4进行类似的判断。</p><p>然后这题还需要记录有几个最小以及分别的权数，难度不大。</p><p>首先写出基本的Dijstra：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 512</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, c1, c2, tmpc1, tmpc2, min_dis, cur_c, tmp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> team_num[MAX], roads[MAX][MAX], dis[MAX];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[MAX];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(roads, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(roads));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; team_num[i], roads[i][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; <span class="built_in">cin</span> &gt;&gt; tmpc1 &amp;&amp; <span class="built_in">cin</span> &gt;&gt; tmpc2; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; roads[tmpc1][tmpc2], roads[tmpc2][tmpc1] = roads[tmpc1][tmpc2];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化dis</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">dis[i] = roads[c1][i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//起点到起点距离已确定</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">vis[c1] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环直至到c2的最短路被确定</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!vis[c2])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到未被确定最短路的城市中路径最短的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">min_dis = INF;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vis[i] &amp;&amp; dis[i] &lt; min_dis)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">min_dis = dis[i], cur_c = i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//标明起点到该城市最短距离已确定</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">vis[cur_c] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断由此城市到其它城市会不会更近</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//若当前所选城市能到达某城市i且未被确定</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (roads[cur_c][i] &lt; INF &amp;&amp; !vis[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果从当前城市到某城市i更近</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tmp = dis[cur_c] + roads[cur_c][i], dis[i] &gt; tmp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改从起点到i的最短距离</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">dis[i] = tmp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[c2];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>然后加上两个数组<code>cnt</code>和<code>team_sum</code>，记录道路组合数目和队伍数。最开始不是把cnt作为数组而是作为一个整型，当发现到达目标城市有相同长度的路径时自增，有更短路径时置为1。牛客网AC但PAT测试点只过了两三个的亚子。研究了好久发现这种方法下如果到某中间城市有多种最短路径，该中间城市到目标城市有一条路径，且由此中间城市到目标城市所需总计最短距离与其它方式的最短距离相等时cnt会自增，但实际上应当增加由起点到该中间城市的最短路径的数目，所以cnt应当是个数组，记录到所有城市的最短路径数目，当发现经由当前城市到达某城市的最短路径与其它方式到达某城市有相同长度的路径时不是自增，而是增加到达当前城市的最短路径数。这个问题困扰了我大概三四个小时。</p><p>所以最后应该是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 512</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, c1, c2, tmpc1, tmpc2, min_dis, cur_c, tmp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt[MAX], team_num[MAX], roads[MAX][MAX], dis[MAX], team_sum[MAX];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[MAX];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(roads, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(roads));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; team_num[i], roads[i][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; <span class="built_in">cin</span> &gt;&gt; tmpc1 &amp;&amp; <span class="built_in">cin</span> &gt;&gt; tmpc2; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; roads[tmpc1][tmpc2], roads[tmpc2][tmpc1] = roads[tmpc1][tmpc2];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化dis、team_sum和cnt</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为肯定要收集初始点的队伍，所以可以先都加上初始点队伍数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果起点可直达某点，则通路数记为1，否则记为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">dis[i] = roads[c1][i], team_sum[i] = team_num[c1], cnt[i] = team_sum[i] == INF ? <span class="number">0</span> : <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//起点到起点距离已确定</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">vis[c1] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环直至到c2的最短路被确定</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!vis[c2])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到未被确定最短路的城市中路径最短的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">min_dis = INF;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vis[i] &amp;&amp; dis[i] &lt; min_dis)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">min_dis = dis[i], cur_c = i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//标明起点到该城市最短距离已确定，并加上该城市具有的队伍数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">vis[cur_c] = <span class="literal">true</span>, team_sum[cur_c] += team_num[cur_c];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断由此城市到其它城市会不会更近</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//若当前所选城市能到达某城市i且未被确定</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (roads[cur_c][i] &lt; INF &amp;&amp; !vis[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果从当前城市到某城市i更近</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tmp = dis[cur_c] + roads[cur_c][i], dis[i] &gt; tmp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改从起点到i的最短距离和路径数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">dis[i] = tmp, cnt[i] = cnt[cur_c];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改以最小距离到达i可获得的队伍数为以最小距离到当前城市可获得的队伍数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">team_sum[i] = team_sum[cur_c];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果从当前城市到某城市i距离相同</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dis[i] == tmp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是当前城市到目的城市距离与原先相同则通路数加当前城市最短路径数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">cnt[i] += cnt[cur_c];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果从当前城市到目的城市可获得的队伍数更多则修改之</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">team_sum[i] = team_sum[i] &gt; team_sum[cur_c] ? team_sum[i] : team_sum[cur_c];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[c2] &lt;&lt; <span class="string">' '</span> &lt;&lt; team_sum[c2];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>AC。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;/center&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://mechanicalmind.cn/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="http://mechanicalmind.cn/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/PAT/"/>
    
      <category term="甲级" scheme="http://mechanicalmind.cn/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/PAT/%E7%94%B2%E7%BA%A7/"/>
    
    
      <category term="PAT甲级" scheme="http://mechanicalmind.cn/tags/PAT%E7%94%B2%E7%BA%A7/"/>
    
  </entry>
  
</feed>
