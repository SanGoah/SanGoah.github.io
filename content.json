{"meta":{"title":"Mech_Mind‘s blog","subtitle":null,"description":"敲键盘 按快门 巡星空","author":null,"url":"http://mechanicalmind.cn","root":"/"},"pages":[{"title":"about","date":"2019-09-23T10:13:29.000Z","updated":"2019-10-16T06:22:05.207Z","comments":true,"path":"about/index.html","permalink":"http://mechanicalmind.cn/about/index.html","excerpt":"","text":"欢迎您，访客。 本博客为Mech_Mind备份个人笔记等的空间。 本博客存在的意义既不是帮助他人，也不是分享生活，因此也不会提交给搜索引擎收录。如果您偶然点击进来，便是我们的缘分。如果其中的内容对您有些许帮助，欢迎您常来看看；当然，本人能力一般、水平有限，所写内容多是粗浅鄙陋之零碎，望能博君一笑。 这方小天地分为以下一些归档： 戏法：这里记录着必要环境的配置——譬如法师之手的法术模型。虽然没什么技术含量，但总归是个开始。 前端：虽然不打算从事相关工作，不过还是认真接触一下吧。 丧志：玩物。"},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2019-12-06T15:34:19.153Z","comments":false,"path":"categories/index.html","permalink":"http://mechanicalmind.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2019-12-06T15:32:04.247Z","comments":false,"path":"tags/index.html","permalink":"http://mechanicalmind.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"连接数据库增删改查的练习","slug":"表世界/JSP/连接数据库增删改查的练习","date":"2020-01-05T16:00:00.000Z","updated":"2020-01-05T16:00:00.000Z","comments":true,"path":"2020/01/06/表世界/JSP/连接数据库增删改查的练习/","link":"","permalink":"http://mechanicalmind.cn/2020/01/06/%E8%A1%A8%E4%B8%96%E7%95%8C/JSP/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E7%9A%84%E7%BB%83%E4%B9%A0/","excerpt":"JSP+Servlet+MySQL实现图书管理系统。","text":"JSP+Servlet+MySQL实现图书管理系统。 12add3&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;4&lt;%5String path = request.getContextPath();6String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";7%&gt;89&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;10&lt;html&gt;11 &lt;head&gt;12 &lt;base href=\"&lt;%=basePath%&gt;\"&gt;13 14 &lt;title&gt;My JSP 'add.jsp' starting page&lt;/title&gt;15 16 &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;17 &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;18 &lt;meta http-equiv=\"expires\" content=\"0\"&gt; 19 &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt;20 &lt;meta http-equiv=\"description\" content=\"This is my page\"&gt;21 &lt;!--22 &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\"&gt;23 --&gt;2425 &lt;/head&gt;26 27 &lt;body&gt;28 &lt;center&gt;29 &lt;h1&gt;添加书籍&lt;/h1&gt;30 &lt;form action=\"Servlet?action=add\" method=\"post\"&gt;31 &lt;p&gt;编号：&lt;input name=\"id\" /&gt;32 &lt;p&gt;名字：&lt;input name=\"name\" /&gt;33 &lt;p&gt;备注：&lt;input name=\"info\" /&gt;34 &lt;p&gt;&lt;input id=\"sub\" type=\"submit\" value=\"添加\"&gt;&lt;/p&gt;35 &lt;/form&gt;36 &lt;p&gt;&lt;a href=\"index.jsp\"&gt;[返回主界面]&lt;/a&gt;&lt;/p&gt;37 &lt;/center&gt;38 &lt;/body&gt;39&lt;/html&gt;4041index4243&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;44&lt;%45String path = request.getContextPath();46String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";47%&gt;4849&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;50&lt;html&gt;51 &lt;head&gt;52 &lt;base href=\"&lt;%=basePath%&gt;\"&gt;53 54 &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt;55 &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;56 &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;57 &lt;meta http-equiv=\"expires\" content=\"0\"&gt; 58 &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt;59 &lt;meta http-equiv=\"description\" content=\"This is my page\"&gt;60 &lt;!--61 &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\"&gt;62 --&gt;63 &lt;/head&gt;64 65 &lt;body&gt;66 &lt;center&gt;&lt;div id=\"wel\"&gt;67 &lt;h1&gt;欢迎&lt;/h1&gt;68 &lt;p&gt;&lt;a href=\"search.jsp\"&gt;查看书籍&lt;/a&gt;&lt;/p&gt;69 &lt;p&gt;&lt;a href=\"add.jsp\"&gt;添加书籍&lt;/a&gt;&lt;/p&gt;70 &lt;/div&gt;&lt;/center&gt;71 &lt;/body&gt;72&lt;/html&gt;7374search7576&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;77&lt;%@ page import=\"com.mechmind.model.*\" %&gt;78&lt;jsp:useBean id=\"courseDao\" class=\"com.mechmind.dao.DAO\" /&gt;79&lt;%80String path = request.getContextPath();81String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";82%&gt;8384&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;85&lt;html&gt;86 &lt;head&gt;87 &lt;base href=\"&lt;%=basePath%&gt;\"&gt;88 89 &lt;title&gt;My JSP 'search.jsp' starting page&lt;/title&gt;90 91 &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;92 &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;93 &lt;meta http-equiv=\"expires\" content=\"0\"&gt; 94 &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt;95 &lt;meta http-equiv=\"description\" content=\"This is my page\"&gt;96 &lt;!--97 &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\"&gt;98 --&gt;99100 &lt;/head&gt;101 102 &lt;body&gt;103 &lt;%104 request.setCharacterEncoding(\"utf-8\"); 105 response.setContentType(\"text/html;charset=UTF-8\");106 %&gt;107 &lt;center&gt;108 &lt;h1&gt;查看书籍&lt;/h1&gt; 109 &lt;table border=\"1px\" cellspacing=\"0px\"&gt;110 &lt;tr&gt;111 &lt;td&gt;书号&lt;/td&gt;112 &lt;td&gt;名称&lt;/td&gt;113 &lt;td&gt;简介&lt;/td&gt;114 &lt;td&gt;更新&lt;/td&gt;115 &lt;td&gt;删除&lt;/td&gt;116 &lt;/tr&gt;117 &lt;%118 int cutpage = 1;119 final int cntPrePage = 7;120 if (request.getParameter(\"cutpage\") != null) &#123;121 cutpage = Integer.parseInt(request.getParameter(\"cutpage\"));122 &#125;123 String[] color = &#123;\"yellow\", \"green\"&#125;;124 ArrayList&lt;Book&gt; list = (ArrayList&lt;Book&gt;)courseDao.getAllBook();125 int count = list.size();126 int prepage = cutpage - 1;127 int nxtpage = cutpage + 1;128 if (prepage &lt;= 0) prepage = 1;129 if (cutpage * cntPrePage &gt;= count) nxtpage = cutpage;130 131 if (list != null &amp;&amp; list.size() &gt; 0) &#123;132 for (int i = (cutpage-1)*cntPrePage; i &lt; cutpage*cntPrePage &amp;&amp; i &lt; count; i++) &#123;133 Book book = list.get(i);134 %&gt;135 &lt;tr bgcolor=\"&lt;%=color[i%2] %&gt;\" &gt;136 &lt;td&gt;&lt;%=book.getId()%&gt;&lt;/td&gt;137 &lt;td&gt;&lt;%=book.getName() %&gt;&lt;/td&gt;138 &lt;td&gt;&lt;%=book.getInfo() %&gt;&lt;/td&gt;139 &lt;td&gt;&lt;a href=\"update.jsp?id=&lt;%=book.getId() %&gt;\"&gt;更新&lt;/a&gt;&lt;/td&gt;140 &lt;td&gt;&lt;a href=\"Servlet?action=delete&amp;id=&lt;%=book.getId() %&gt;\"&gt;删除&lt;/a&gt;&lt;/td&gt;141 &lt;/tr&gt;142 &lt;%143 &#125;144 &#125;145 %&gt;146 &lt;/table&gt;147 &lt;p&gt;148 &lt;a href=\"search.jsp?cutpage=&lt;%=prepage%&gt;\"&gt;[上一页]&lt;/a&gt;149 &amp;nbsp;(&lt;%=cutpage %&gt;/&lt;%=(count-1)/cntPrePage+1 %&gt;)&amp;nbsp;150 &lt;a href=\"search.jsp?cutpage=&lt;%=nxtpage%&gt;\"&gt;[下一页]&lt;/a&gt;151 &lt;/p&gt;152 &lt;p&gt;153 &lt;a href=\"index.jsp\"&gt;[返回主页]&lt;/a&gt;154 &lt;/p&gt;155 &lt;/center&gt;156 &lt;/body&gt;157&lt;/html&gt;158159update160161&lt;%@ page language=\"java\" import=\"java.util.*,com.mechmind.model.Book\" pageEncoding=\"UTF-8\"%&gt;162&lt;jsp:useBean id=\"DAO\" class=\"com.mechmind.dao.DAO\" /&gt;163&lt;%164String path = request.getContextPath();165String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";166%&gt;167168&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;169&lt;html&gt;170 &lt;head&gt;171 &lt;base href=\"&lt;%=basePath%&gt;\"&gt;172 173 &lt;title&gt;My JSP 'update.jsp' starting page&lt;/title&gt;174 175 &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;176 &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;177 &lt;meta http-equiv=\"expires\" content=\"0\"&gt; 178 &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt;179 &lt;meta http-equiv=\"description\" content=\"This is my page\"&gt;180 &lt;!--181 &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\"&gt;182 --&gt;183184 &lt;/head&gt;185 186 &lt;body&gt;187 &lt;%188 request.setCharacterEncoding(\"utf-8\"); 189 response.setContentType(\"text/html;charset=UTF-8\");190 int id = Integer.parseInt(request.getParameter(\"id\"));191 Book book = DAO.getById(id);192 %&gt;193 &lt;center&gt;&lt;form action=\"Servlet?action=update&amp;id=&lt;%=id %&gt;\" method=\"post\"&gt;194 &lt;h1&gt;&lt;label&gt;修改编号 &lt;%=id %&gt;的书籍&lt;/label&gt;&lt;/h1&gt;195 &lt;p&gt;196 &lt;label&gt;书名：&lt;/label&gt;197 &lt;input type=\"text\" name=\"name\" value=\"&lt;%=book.getName() %&gt;\"&gt;198 &lt;/p&gt;199 &lt;p&gt;200 &lt;label&gt;简介：&lt;/label&gt;201 &lt;input type=\"text\" name=\"info\" value=\"&lt;%=book.getInfo() %&gt;\"&gt;202 &lt;/p&gt;203 &lt;p&gt;204 &lt;input type=\"submit\" value=\"更新\"&gt;205 &lt;/p&gt;206 &lt;/form&gt;&lt;/center&gt;207 208 &lt;/body&gt;209&lt;/html&gt; 12servlet34package com.mechmind.controller;56import java.io.IOException;78import javax.servlet.ServletException;9import javax.servlet.http.HttpServlet;10import javax.servlet.http.HttpServletRequest;11import javax.servlet.http.HttpServletResponse;1213import com.mechmind.dao.DAO;14import com.mechmind.model.Book;1516public class Servlet extends HttpServlet &#123;1718 /**19 * 20 */21 private static final long serialVersionUID = -7078893322239794049L;2223 /**24 * Constructor of the object.25 */26 public Servlet() &#123;27 super();28 &#125;2930 /**31 * Destruction of the servlet. &lt;br&gt;32 */33 public void destroy() &#123;34 super.destroy(); // Just puts \"destroy\" string in log35 // Put your code here36 &#125;3738 /**39 * The doGet method of the servlet. &lt;br&gt;40 *41 * This method is called when a form has its tag value method equals to get.42 * 43 * @param request the request send by the client to the server44 * @param response the response send by the server to the client45 * @throws ServletException if an error occurred46 * @throws IOException if an error occurred47 */48 public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;49 doPost(request,response);50 &#125;5152 /**53 * The doPost method of the servlet. &lt;br&gt;54 *55 * This method is called when a form has its tag value method equals to post.56 * 57 * @param request the request send by the client to the server58 * @param response the response send by the server to the client59 * @throws ServletException if an error occurred60 * @throws IOException if an error occurred61 */62 public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;63 request.setCharacterEncoding(\"utf-8\");64 response.setContentType(\"text/html;charset=utf-8\");65 66 String action = request.getParameter(\"action\");6768 DAO dao = new DAO();69 if (\"delete\".equals(action)) &#123;70 dao.delete(Integer.parseInt(request.getParameter(\"id\")));71 response.sendRedirect(\"search.jsp\");72 &#125; else if (\"update\".equals(action)) &#123;73 Book book = new Book();74 book.setId(Integer.parseInt(request.getParameter(\"id\")));75 book.setName(request.getParameter(\"name\"));76 book.setInfo(request.getParameter(\"info\"));77 dao.update(book);78 response.sendRedirect(\"search.jsp\");79 &#125; else if (\"add\".equals(action)) &#123;80 Book book = new Book();81 book.setInfo(request.getParameter(\"info\"));82 book.setName(request.getParameter(\"name\"));83 book.setId(Integer.parseInt(request.getParameter(\"id\")));84 dao.add(book);85 response.sendRedirect(\"search.jsp\"); 86 &#125;87 &#125;88 89 public void init() throws ServletException &#123;90 // Put your code here91 &#125;9293&#125;9495dao9697package com.mechmind.dao;9899import com.mechmind.model.Book;100import com.mechmind.util.DButil;101102import java.sql.Connection;103import java.sql.PreparedStatement;104import java.sql.ResultSet;105import java.sql.SQLException;106import java.util.ArrayList;107108public class DAO &#123;109 110 public ArrayList&lt;Book&gt; getAllBook() &#123;111 112 ArrayList&lt;Book&gt; list = new ArrayList&lt;&gt;();113 Connection conn = null;114 PreparedStatement pstmt = null;115 ResultSet rs = null;116 117 try &#123;118 conn = DButil.getConnection();119 String sql = \"select * from books\";120 pstmt = conn.prepareStatement(sql);121 rs = pstmt.executeQuery();122 while (rs != null &amp;&amp; rs.next()) &#123;123 Book book = new Book();124 book.setId(rs.getInt(1));125 book.setInfo(rs.getString(3));126 book.setName(rs.getString(2));127 list.add(book);128 &#125;129 &#125; catch (SQLException ex) &#123;130 ex.printStackTrace();131 &#125; finally &#123;132 if (pstmt != null) &#123;133 try &#123;134 pstmt.close();135 &#125; catch (SQLException e) &#123;136 e.printStackTrace();137 &#125;138 &#125;139 if (rs != null) &#123;140 try &#123;141 rs.close();142 &#125; catch (SQLException e) &#123;143 e.printStackTrace();144 &#125;145 &#125;146 &#125;147 148 return list;149 &#125;150 151 public void add(Book book) &#123;152 Connection conn = null;153 PreparedStatement pstmt = null;154 155 try &#123;156 conn = DButil.getConnection();157 String sql = \"insert into books(id, name, info) values(?, ?, ?)\";158 System.out.println(\"1\");159 pstmt = conn.prepareStatement(sql);160 pstmt.setInt(1, book.getId());161 pstmt.setString(2, book.getName());162 pstmt.setString(3, book.getInfo());163 pstmt.executeUpdate();164 &#125; catch (SQLException ex) &#123;165 ex.printStackTrace();166 &#125; finally &#123;167 if (pstmt != null) &#123;168 try &#123;169 pstmt.close();170 &#125; catch (SQLException e) &#123;171 e.printStackTrace();172 &#125;173 &#125;174 &#125;175 &#125;176 177 public void delete(int id) &#123;178 Connection conn = null;179 PreparedStatement pstmt = null;180 181 try &#123;182 conn = DButil.getConnection();183 String sql = \"delete from books where id=?\";184 pstmt = conn.prepareStatement(sql);185 pstmt.setInt(1, id);186 pstmt.executeUpdate();187 &#125; catch (SQLException ex) &#123;188 ex.printStackTrace();189 &#125; finally &#123;190 if (pstmt != null) &#123;191 try &#123;192 pstmt.close();193 &#125; catch (SQLException e) &#123;194 e.printStackTrace();195 &#125;196 &#125;197 &#125;198 &#125;199 200 public void update(Book book) &#123;201 Connection conn = null;202 PreparedStatement pstmt = null;203 204 try &#123;205 conn = DButil.getConnection();206 String sql = \"update books set name=?,info=? where id=?\";207 pstmt = conn.prepareStatement(sql);208 pstmt.setString(1, book.getName());209 pstmt.setString(2, book.getInfo());210 pstmt.setInt(3, book.getId());211 pstmt.executeUpdate();212 &#125; catch (SQLException ex) &#123;213 ex.printStackTrace();214 &#125; finally &#123;215 if (pstmt != null) &#123;216 try &#123;217 pstmt.close();218 &#125; catch (SQLException e) &#123;219 e.printStackTrace();220 &#125;221 &#125;222 &#125;223 &#125;224 225 public Book getById(int id) &#123;226227 Connection conn = null;228 PreparedStatement pstmt = null;229 ResultSet rs = null;230 231 try &#123;232 conn = DButil.getConnection();233 String sql = \"select * from books where id = ?\";234 pstmt = conn.prepareStatement(sql);235 pstmt.setInt(1, id);236 rs = pstmt.executeQuery();237 if (rs != null &amp;&amp; rs.next()) &#123;238 Book book = new Book();239 book.setId(rs.getInt(1));240 book.setName(rs.getString(2));241 book.setInfo(rs.getString(3));242 return book;243 &#125;244 &#125; catch (SQLException ex) &#123;245 ex.printStackTrace();246 &#125; finally &#123;247 if (pstmt != null) &#123;248 try &#123;249 pstmt.close();250 &#125; catch (SQLException e) &#123;251 e.printStackTrace();252 &#125;253 &#125;254 if (rs != null) &#123;255 try &#123;256 rs.close();257 &#125; catch (SQLException e) &#123;258 e.printStackTrace();259 &#125;260 &#125;261 &#125;262 263 return null;264 &#125;265&#125;266267model268269package com.mechmind.model;270271public class Book &#123;272 private int id;273 private String name;274 private String info;275 276 public int getId() &#123;277 return id;278 &#125;279 public void setId(int id) &#123;280 this.id = id;281 &#125;282 public String getName() &#123;283 return name;284 &#125;285 public void setName(String name) &#123;286 this.name = name;287 &#125;288 public String getInfo() &#123;289 return info;290 &#125;291 public void setInfo(String info) &#123;292 this.info = info;293 &#125;294&#125;295296util297298package com.mechmind.util;299300import java.sql.Connection;301import java.sql.DriverManager;302import java.sql.SQLException;303304public class DButil &#123;305 static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\"; 306 static final String DB_URL = \"jdbc:mysql://localhost:3306/bookdb?useSSL=false&amp;serverTimezone=UTC\";307 static final String USER = \"root\";308 static final String PASS = \"root\";309 310 private static Connection conn;311312 static &#123;313 try &#123;314 Class.forName(JDBC_DRIVER);315 &#125; catch (Exception ex) &#123;316 ex.printStackTrace();317 &#125;318 &#125;319320 public static Connection getConnection() throws SQLException &#123;321 if (conn == null) &#123;322 conn = DriverManager.getConnection(DB_URL, USER, PASS);323 return conn;324 &#125;325 return conn;326 &#125;327&#125; 1&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt;2&lt;servlet&gt;3 &lt;description&gt;This is the description of my J2EE component&lt;/description&gt;4 &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;5 &lt;servlet-name&gt;Servlet&lt;/servlet-name&gt;6 &lt;servlet-class&gt;com.mechmind.controller.Servlet&lt;/servlet-class&gt;7&lt;/servlet&gt;8&lt;servlet-mapping&gt; 9 &lt;servlet-name&gt;Servlet&lt;/servlet-name&gt; 10 &lt;url-pattern&gt;/Servlet&lt;/url-pattern&gt; 11&lt;/servlet-mapping&gt; 12&lt;welcome-file-list&gt;13 &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;14 &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;15 &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;16 &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;17 &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;18 &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;19&lt;/welcome-file-list&gt;20&lt;/web-app&gt;","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"JSP","slug":"表世界/JSP","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://mechanicalmind.cn/tags/JSP/"}]},{"title":"组成原理・肆・I/O系统","slug":"组成原理/组成原理・肆・I-O系统","date":"2020-01-02T09:12:58.000Z","updated":"2020-01-02T09:12:58.000Z","comments":true,"path":"2020/01/02/组成原理/组成原理・肆・I-O系统/","link":"","permalink":"http://mechanicalmind.cn/2020/01/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%83%BB%E8%82%86%E3%83%BBI-O%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"组成原理・叁・控制器系统","slug":"组成原理/组成原理・叁・控制器系统","date":"2020-01-02T09:12:32.000Z","updated":"2020-01-02T09:12:32.000Z","comments":true,"path":"2020/01/02/组成原理/组成原理・叁・控制器系统/","link":"","permalink":"http://mechanicalmind.cn/2020/01/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%83%BB%E5%8F%81%E3%83%BB%E6%8E%A7%E5%88%B6%E5%99%A8%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"机器指令的基本格式 最简单的指令包括操作码和地址码两个字段。其长度可以固定，称为定长指令字结构，其结构简单、译码时间短但平均比较长且不宜扩展；也可以因指令功能不同而异，称为可变长指令字结构，其结构灵活、冗余少且易于扩展，但取指令时可能需要多次访存，使不同指令的执行时间不一致。不管怎么样，方便起见，指令长度应为机器字长（通常也是字节）的整数倍。长度等于机器字长的指令称为单字长指令，等于两个字长的叫双字长，还有更多的也有半长的。 地址码 对于有两个操作数的指令，通常需要指出两个操作数的地址、运算结果的地址和下条指令的地址。四地址指令就是给出以上所有，但通常不给出下条指令的地址，而是由PC计数器给出，即三地址指令。中小型和微型机中还会省略结果的存放地址，因为源操作数经常运算过后就不需要了，即二地址指令，其中两个操作数均为存储器地址的叫存储器-存储器型（S-S）、均为寄存器地址的叫寄存器-寄存器型（R-R）、一个存储器一个寄存器的叫寄存器-存储器型（R-S）。 另外还有一地址指令如自加自减和零地址指令如NOP。 地址码可以给出操作数本身，叫立即寻址；也可以给出操作数的地址，叫直接寻址；也可以给出操作数的地址的地址，叫间接寻址，这使得短地址码也可以访问大的存储空间；也可以有一个变址寄存器存一个地址，与指令中的数相加得到有效地址；还有很多其它的，为区分地址码采用的寻址方式，地址码中还需要专门分出来几位指明寻址方式。 例如某机器字长24位，有15个24位通用寄存器，采用R-S型单字长指令格式，共60条指令，使用了5种寻址方式。则60条指令需要占用6个位作为操作码，剩下18位可以放地址码；由于是R-S型，所以第一个操作数肯定是15个寄存器之一，4个位即可表示，剩下14位可以放第二个操作数的地址；有五种寻址方式，需要用3个位来指明，所以还剩11个位放具体的地址。所以直接寻址范围为211=2K；间接寻址的话就可以先跳到2K范围内的某个存储器空间，这个存储器空间的24个位都是可以放地址的，范围位224=16M。如果是给出立即数的话，也是有11位可用，采用补码整数方式共计2K个数即-1024~1023。 操作码 根据操作码部分的长度是否相同分定长和变长编码。假如某机器字长16位，采用单字长指令，四位为操作码，剩下为地址码，则只能表示16种指令，而有些单零地址、一地址和二地址指令的地址码区域被浪费。因此通常采用变长编码。 首先前四位0000-1110可用于表示15种三地址指令，CPU遇到1111开头就知道哦这是二或一或零地址指令；同理1111000011111110可用于表示15种二地址指令，CPU遇到11111111就知道哦这是一或零地址指令；同理111111110000111111111110可表示15种一地址指令，CPU遇到111111111111就知道哦这是零地址指令；最后可有16种零地址指令。 实际上未必四种指令都是十五六条，例如现在只需要11条三地址指令，但需要72条二地址指令、64条零地址指令，怎么编码？首先11条三地址指令可占用前四位0000~1010的情况，而遇到其它的五种情况CPU知道哦这是二或一或零地址指令；这五种情况乘上接下来四位可表示的16种情况一共可以表示80条二地址指令，用去72种情况，还有8种情况；同理八成十六得可表示128条一地址指令，但这里要为64条零地址指令留出64/16=4种情况，还可以再编124条一地址指令。","categories":[],"tags":[]},{"title":"组成原理・贰・存储器系统","slug":"组成原理/组成原理・贰・存储器系统","date":"2020-01-02T09:12:23.000Z","updated":"2020-01-02T09:12:23.000Z","comments":true,"path":"2020/01/02/组成原理/组成原理・贰・存储器系统/","link":"","permalink":"http://mechanicalmind.cn/2020/01/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%83%BB%E8%B4%B0%E3%83%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"简介 按与CPU的连接方式分主存、辅存和高速缓冲存储器，按存取方式分RAM、ROM、SAM、DAM和CAM等。容量、速度、价格是人们购买时主要关心的参数。 半导体存储单位电路有如下两种： 静态RAM（Static RAM，SRAM），其中每个存储单位由一个由多个MOS管构成的触发器构成。性能稳定。断电数据会丢失。 动态RAM（Dynamic RAM，DRAM），其中每个存储单位由一个MOS管和一个电容构成，提高了存储密度，但电容会很快漏电，需要经常刷新。断电数据会丢失。 其中，动态RAM主要有集中式刷新（一段时间内禁止访问，所有单元统一刷新）、分散式刷新（每个存取周期后刷新一行单元，在CPU看来就是存取周期变为两倍，但不会出现集中式刷新的“死区”）和最常用的异步式刷新（每多个存取周期后刷新一行单元，不会像分散式那样过于频繁地刷新）。 主存 大量存储单位组成存储阵列，并与外围电路（地址译码与驱动电路、读写放大电路及时序控制电路等）集成在一块硅片上，构成一个存储器组件。一般存储单位的组织形式有字片式（单译码）和位片式（双译码）。 只使用一个地址译码器的称为单译码方式： 每行构成一个存储单元，对单译码，有多少个存储单元就需要多少个译码驱动电路。 使用两个地址译码器的称为双译码方式： 存储单元同时在行和列上排列，因此只需2*sqrt(存储单元数)个译码驱动电路。 内存条由多个存储器组件组成。比方说，CPU有A11-A0共12根地址引线，D7-D0共8根数据总线，想要用Intel2114芯片（1K*4bit）组成4KB的内存，就需要4*8/4=8片芯片。 4K即2^12，所以12根地址线刚刚好。 注意这里芯片每单元4bit，而CPU有8根地址总线，所以存储器应当是每单元8bit，因此需要对芯片进行位扩展，每两个芯片构成一个适合CPU的单元，8片芯片分为四组，即每组1KB。方法是并联2个芯片的地址线、选片信号线和读写控制线，将各芯片数据线分别接到CPU数据总线对应位。 将所有组读写控制线并联，接到CPU对应引脚；所有组同一位置的地址线并联，接在CPU地址线，例如这里每组1K即2^10个单元，即每组有10根地址线，每组对应位置的地址线并联接在A0A9。将每组并联过的选片信号线分别接在选片译码器上，一共4组即2^2，所以选片译码器需要两个引脚，接在A10A11上。将所有组的8个位的同位置数据输入输出引线并联，接在D0~D7。 实际使用时，用选片地址线选芯片（组），用其余地址引线选单元（字），使用地址总线传输数据。 辅存 常见的是机械硬盘，由多片磁盘构成，每片的两个面都可以记录信息（上下两个面不用因为没有磁臂），每面分一些同心圆称为磁道，每个磁道分几个扇区。有效面数*每面磁道数*每道扇区数*每扇区字节数即为磁盘容量，找信息时给出磁道号+盘面号+扇区号即可将磁臂移动到对应位置（将磁道号放在前面是为了在例如一个盘面的某磁道写满了的情况时不是移动磁臂去写该盘面下一个磁道而是写下一个盘面的同一磁道，即减少磁臂移动）。扇区是基本访问单位。磁道密度即盘面内外径之差除以磁道数，位密度即一道的位数除以周长，最外磁道位密度最小最内最大，数据传输速率为每道容量乘转速，平均访问时间为平均寻道时间加平均旋转时间（转半圈所需毫秒数）加传送一个扇区所需时间。 高速缓冲存储器 作用如其名。容量小，速度快，编址方式、单元长度等与主存相同，通常是SRAM。常用组织结构有三种： 直接映像方式：每个主存块固定地只能加载进一个Cache块，电路简单，命中率低。 全联映像方式：任意主存块可加载进任意Cache块，命中率高但电路较前者复杂。 组相联映像方式：将Cache分组，每个主存块只能固定地加载进一个组，但可加载进该组的任意Cache块。","categories":[],"tags":[]},{"title":"组成原理・壹・运算器系统","slug":"组成原理/组成原理・壹・运算器系统","date":"2020-01-02T09:12:15.000Z","updated":"2020-01-02T09:12:15.000Z","comments":true,"path":"2020/01/02/组成原理/组成原理・壹・运算器系统/","link":"","permalink":"http://mechanicalmind.cn/2020/01/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%83%BB%E5%A3%B9%E3%83%BB%E8%BF%90%E7%AE%97%E5%99%A8%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"数据的表示 无符号数 就是没有符号（包括正负号和小数点）的数，容易表示。 带符号定点数 现实中的带符号数叫真值，电脑里其二进制形式叫机器数。 原码 对于纯小数，约定一串二进制码，第一位为正负号，之后为有效数字，小数点在正负号后、有效数字前，即表示范围为正负零点几几。 例如，对+0.1010110，原码为01010110；对-0.1010110，原码为11010110。 只能表示这种数字的计算机叫小数定点机。 对于整数，约定一串二进制码，第一位为正负号，之后为有效数字，小数点在有效数字最后，即表示范围为正负整数。 例如，对+1010110，原码为01010110；对-1010110，原码为11010110。 对8位寄存器来说就是00000000和10000000表示0加上正数2^7-1=127加上负数2^7-1=127的范围。只能表示这种数字的计算机叫整数定点机。 其中第一位0表示正1表示负。零有两种方式来表示。纯小数不能表示-1，整数不能表示-2^位数。 补码 原码很简单，但我们希望做减法时能使用加法方式以简化电路。 假如每次运算结果都取模，可以做到这一点。即，在每次运算都取模的时候，减一个数和加模与此数之差是等价的。称这两个数互为补数。 计算机中的每次运算的结果都会自然地被取模，因为溢出时溢出的部分会被丢弃，这等价为一次取模操作。 例如，在四位寄存器中，1011-1011和1011+0101结果均为0000，即-1011和+0101在模2^4时等价。 对于正纯小数，补码与原码相同；对于负纯小数，补码为二加真值即真值的有效数字部分取反加一再添上符号位。 例如，对+0.1010110，补码为01010110；对-0.1010110，补码为10101010。 对于正整数，补码与原码相同；对于负整数，补码为模加真值即真值取反加一再添上符号位。 例如，对+1010110，补码为01010110；对-1010110，补码为10101010。 无论纯小数或纯整数，零只有00000000一种形式，而多出来的10000000在纯小数中表示-1，整数中表示-2^位数。 反码 类似补码，但模比补码的模小一。即： 对于正纯小数，反码与原码相同；对于负纯小数，反码为二加真值即真值的有效数字部分取反再添上符号位。 对于正整数，反码与原码相同；对于反整数，补码为模加真值即真值取反再添上符号位。 无论是纯小数还是整数，零有两种表示方式，00000000和11111111。其表示范围与原码相同。 移码 挖坑。 浮点数 浮点数包括正负号（数符）、阶符、阶码和尾数四部分，表示的数字就是数符*尾数*进制^(阶符*阶码)，容易理解。具体一串一定长度的二进制串中哪些位是什么有各种标准，其中尾数的尾数决定精度、阶码的位数决定范围，容易理解。 例如一台计算机，使用一位数符+5位阶码+6位尾数表示补码浮点数，则+0.110101*2^(+0011)表示为0 00011 110101；-0.111010*2^(+0010)表示为1 00010 000110。 同一个数有不同的表示方法。例如100.1可表示为0.0010010*25或000010012^-1。为使表示唯一化，规定所有尾数表示按纯小数表示，且使用原码表示时尾数最高位为1或使用补码表示时尾数最高位与符号位相反，这样的话在不丢失信息的前提下都是把有效信息（原码中是1、补码正数是1、补码负数是0）尽可能往高位挪，起到了保持唯一性、保留尽可能多有效数字的作用。所以100.1应当表示为0.100100023。 数据的校验 奇偶校验码 为数据加一个校验位，存储数据中1的数目的奇偶性，如果有奇数个1则该位为0，否则为1，这样的话算上这个校验位，这串数据里有奇数个1，叫奇校验；反过来叫偶校验。 如果有奇数个位出错，就可以发现。由于通常就算有错也只会有一个位出错，所以很有效。但不能确定位置。 海明校验码 增加奇偶校验位的个数可以提高纠错能力。设有k个位用于奇偶校验，则共表述2k种状态，除全对状态外，有2k-1种状态可指示出错位置，故对于一串长度为n的数据，只要2^k-1&gt;n+k就可以在只有一个位出错时找出出错位置，取反即可自动纠正。 例如，对于一串长7位的数据，2^3-1=7&lt;7+3，2^4-1=15&gt;7+4，故可使用4位奇偶校验码确定出错位置，共计11位。规定位于2的幂次的位置上的位为奇偶校验位，即1、2、4和8，规定每二个及以上校验位共同校验位于为其位数和指示的位的数据。例如，先看由两个校验位校验的数据位：校验位1和校验位2共同校验数据位3，校验位1和校验位4共同校验数据位5，校验位1和校验位8共同校验数据位9，校验位2和校验位4共同校验数据位6，校验位2和校验位8共同校验数据位10，校验位4和校验8就超出下标范围了；再看由三个校验位校验的数据位，校验位1、2、4共同校验数据位7，校验位1、2、8共同校验数据位11，再往后就超了。现在所有数据位都唯一地被某些校验位所校验了。 以ASCII码中'M'1001101为例： 校1 校2 数3 校4 数5 数6 数7 校8 数9 数10 数11 1 0 0 1 1 0 1 其中被校验位1所校验的有数据位3、5、9、7和11，分别为1、0、1、1和1，若采用奇校验，校验位1应当为1。被校验位2所校验的有3、6、10、7和11，分别为1、0、0、1和1，若采用奇校验，校验位2应当为0。依此类推可得最终结果为10100011101。 现在只能应对只有一个错误的情况，扩展的海明校验码，即在海明校验码基础上再加一位单纯的奇偶校验，可检测有两个错误的情况（但此时不知道具体位置）。 循环冗余校验码（CRC） 在要发送的二进制串后面附加一个二进制串，使所生成的新串能与某个特定数使用“模2除法”整除。根据除操作后有无余数判断是否出错。 模2加法即二进制数相加后对二取模：1+1=0，0+1=1，0+0=0，无进位，无借位；类似地，模2减法运算为：1-1=0，0-1=1，1-0=1，0-0=0，无进位，无借位（相当于逻辑异或运算）。 模二乘除法就是基于此的除法，如1101000除以1011： 1 11112 _______31011&#x2F;11010004 10115 -------6 11007 10118 -------9 111010 101111 -------12 101013 101114 ------15 0001 因为模二减法的特点，即使被减数小于减数也能减。结果是1111余1。 给定一串数据，例如1101，类似海明校验法地可知需要增加三个位能确定出错位置。现在约定一个特定数作为除数，因为要得到位置需要三个位表示1种正确情况加七种出错情况，所以约定数应为4位，例如为1011，这样余数是三位的。将原数据左移三位并除以约定数得到一个余数，此处结果见上，余数是1，因此如果1101000加上1就刚好可以整除，所以新的编码就是1101001。 数据的逻辑运算 逻辑移位 逻辑移位即把数据当成无符号数的移位。 逻辑左移即左移、右侧补零；逻辑右移即右移、左侧补零。 数据的算术运算 算术移位 算术移位即把数据当成带符号数如原码或补码的移位。 算术左移即左移、右侧补零；算术右移即右移、左侧补充与符号位相同的符号。 符号位改变说明已将有效位移出。例如对补码来说0011即3左移没问题，变成0110即6，但0110即6左移变成1100即0100即4为出错。 定点补码加减 两数之和之补码等于两数补码之和，因此运算时正常进行二进制加法运算（包括符号位）即可；两数之差之补码等于被减数之补码与减数相反数之补码之和，因此运算时将减数求补后进行加法运算即可。 例如定点小数01001即0.1001和00101即0.0101之和，直接相加即可得到01110即0.1110；求差的话00101求补为11011，求和结果为100100，即00100，即0.0100，结果均正确。 但是补码表示范围有限。例如，定点小数01010即0.1010和01001即0.1001求和，正确结果为1.0011，但实际为10011即-0.1101，这就是因为结果超过了最大正定点小数表示范围0.1111。同理对10011即-0.1101和10101即-0.1011求和，正确结果为-10.1000，但实际为101000即01000即0.1000，也是因为结果超出了最小负定点小数表示范围-1.0000。前者叫正溢出，后者叫负溢出。 只有两正数或两负数相加时可能产生溢出，故可根据两操作数符号与结果符号对比判断溢出情况。 另外，溢出时是尾数向符号位进位、符号位向更高位进位（如果有），如果进位情况不同则说明溢出，例如0.1010+0.1001中符号位进位0、尾数最高位进位1，又如-0.11001-0.1011符号位进位1、尾数最高位进位0。 另一种判断方法是采用变形补码进行运算，这是一种有两个符号位的补码。例如0.1010的变形补码为001010、-0.1011的变形补码为110101等。运算时方法与补码相同，但根据上一段中的原理，如果产生溢出，则两个符号位不同。并且，两符号位不同时，如果高位的符号位为1，则说明结果为负溢出；如果高位的符号位为0，则说明结果为正溢出。 浮点加减运算 浮点数小数点不一定在哪里，要先对齐，称为对阶。求阶码之差可判断小数点位置，相等即为对齐了，否则就是没对齐。将阶码小的浮点数的尾数向右移位（阶码小说明小数点更左，例如1*10^-1即000.1和1*10^(-3)即0.001）直到阶码相等（右移一位阶码加一，例如\\(11\\times 10^{-2}\\)是00.11，右移一位得到000.1，即\\(1\\times 10^{-1}\\)）为止，之所以不把阶码大的浮点数的尾数向左移是因为这样做丢掉的是整数部分最高位，相比丢掉小数部分最低位肯定误差爆炸。 例如浮点数中的例子0 00011 110101和1 00010 000110，00011-00010=00011+11110=100001=00001，故两者小数点相差一位，将阶码小的即00010右移一位即可，得到0 00011 110101和1 00011 100011（注意补符号位）。 接下来对数符和尾数部分进行正常求和或差，例如求和时0 110101 + 1 100011=10 011000=0 011000，再把阶码塞进去即0 00011 011000；求差时0 110101 - 1 100011 = 0 110101 + 0 011101 = 1 010010，结果为1 00011 010010。 注意前面的第一个计算结果不是规格化数，第二个计算两正数相加结果符号位为1，发生溢出。这两种情况叫规格化被破坏，前者叫向右破坏，因为可看作是规格化数右移，此时应左移尾数、减阶码，即上例中将0 00011 011000变为0 00010 110000；后者叫向左破坏，因为是溢出向左进位，此时应右移尾数、加阶码即上例中将1 00011 010010变为0 00100 101001，注意，此处位移结果按变形补码的来。 对阶和规格化过程中都可能出现导致最右数据丢弃的右移（不会出现导致数据丢弃的左移，因为对阶不左移、规格化左移到刚好数据不丢弃），可以类似十进制中保留有效数字的方法降低误差，例如类似四舍五入的零舍一入法（补码负数先减一再舍）、末位恒置一法（冯・诺依曼法）等，也可以设置一些保护位存储被移出的值，与尾数一同参与运算，根据运算结果决定舍入情况等。 另外，浮点数的阶码也可能溢出。 算术逻辑运算部件（ALU） 是运算器的核心，由加法器增加输入控制功能扩展而来。","categories":[],"tags":[]},{"title":"组成原理・〇・总论","slug":"组成原理/组成原理・〇・总论","date":"2020-01-02T09:09:32.000Z","updated":"2020-01-02T09:09:32.000Z","comments":true,"path":"2020/01/02/组成原理/组成原理・〇・总论/","link":"","permalink":"http://mechanicalmind.cn/2020/01/02/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E3%83%BB%E3%80%87%E3%83%BB%E6%80%BB%E8%AE%BA/","excerpt":"","text":"冯・诺依曼计算机系统 现今计算机普遍采用由冯・诺依曼提出的结构体系，其要点如下： 计算机由运算器、存储器、控制器和I/O设备五大部件组成，其中运算器和控制器是最重要的，现在人类技术比较NB了把它俩集成为CPU了； 使用二进制表示数据和指令； 采用存储程序方式，即将程序和数据预先准备好载入主存，运行时自动从程序中一条条取出指令执行，这是现今计算机能高速自动运行的基础。 既然指令和数据都在主存里，计算机是如何区分它们的呢？主要有两个方面： 时间上，程序运行时，首先进入取指周期，由指定的寄存器如PC给出一个地址，将该地址内的二进制代码当作指令执行。指令分两部分，一部分为操作码，指明要执行的操作，一部分为地址码，指明要操作的数据的地址。经过分析周期后进入执行周期，执行周期内取操作数时将地址内的二进制代码当作数据操作； 空间上，由PC提供存储单元地址的取出的是指令，由指令地址码部分提供存储单元地址的取出的是操作数。 如果取出的是指令，送控制器；指令执行周期从内存中取的数据，送运算器（往内存写入的数据也是来自于运算器）。 总线 计算机部件间通过总线传递信息。总线为多个部件共享，多个部件可同时接收总线上的信息，但必须分时地发送信息，否则会冲突。主要分为： 内部总线：连接CPU内部各寄存器和算术逻辑部件； 系统总线：连接计算机系统各部件，一般生活中说总线指的就是这玩意，例如常说的PCI和PCIe；系统总线的连接方式有单总线和双总线，单总线就是所有部件都连在系统总线上，如ARM，双总线就是额外用一个存储总线连接CPU和存储器，例如x86； 外部总线：连接该计算机系统和其它计算机系统或其它非计算机系统的系统的总线。 还可按照信息传输方向分为单向总线和双向总线。 总线结构可以减少线路数简化结构，并可减少信息发送部件的负载（因为不用选择线路了？）及方便拓展系统。 计算机层次结构 为了为不同层次的用户提供不同级别对计算机系统的抽象，将计算机划分为多个层次。有许多种划分方法，仅介绍如下一种： 虚机器/软件 第六级，应用语言层：由为某个领域专门开发的SDK支持，直接面向该领域开发者； 第五级，高级语言层：由高级语言编译程序支持，面向高级语言应用程序编写者； 第四级，汇编语言层：由汇编程序支持，面向汇编语言程序编写者； 第三级，操作系统层：由OS定义和实现一些软件指令，实现对机器指令的扩充，从这一层开始就和程序员没啥关系了； 实机器/硬件 第二级，传统机器语言层：由微程序解释机器指令； 第一级，微程序机器层：由机器硬件执行微指令； 第零级，机器语言时序。 例如一个某领域开发者写软件，第五级及以下的计算机系统对他是抽象掉的，他不用了解这些东西，只要会用自己领域的SDK就行了，写完程序（应用语言层代码）后SDK会给他翻译成高级程序语言（高级语言层代码），高级程序语言被编译器翻译成汇编（汇编语言层代码），汇编程序将汇编代码翻译为指令（操作系统层代码），操作系统将操作系统提供的的广义的那部分指令解释为传统的机器语言（传统机器语言层代码），再由微程序解释为微指令（微程序机器层代码），就可以由硬件执行了。","categories":[],"tags":[]},{"title":"操作系统・壹・处理机管理","slug":"操作系统/操作系统・壹・处理机管理","date":"2019-12-24T07:35:40.000Z","updated":"2019-12-24T16:00:00.000Z","comments":true,"path":"2019/12/24/操作系统/操作系统・壹・处理机管理/","link":"","permalink":"http://mechanicalmind.cn/2019/12/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%83%BB%E5%A3%B9%E3%83%BB%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86/","excerpt":"包括进程、死锁和作业调度相关内容。","text":"包括进程、死锁和作业调度相关内容。 顺序与并发执行的描述 说一个程序是顺序执行的，意味着其每个程序段是依次执行的，且每个程序段内的所有指令也是依次执行的。这种程序运行时独占全机资源，执行结果不受外界影响。 使用前驱图描述程序执行的先后顺序。前驱图是一个有向图，节点为一个程序或语句（或进程），如果一个节点必须在另一个节点执行后才能执行，就从后者引一条边至前者。称后者是前者的前驱。前驱图应当是无环的。 如果两节点间没有前驱关系（直接或间接），它们就可以并发地执行。 并发执行的程序为了满足同时段内执行的内容没有前驱关系，进程间可能要相互等一等之类，会有执行的“间断性”；由于是多个程序并发地在跑，因此全机资源不是被独占的，一个程序跑的时候可能修改了另一个程序的数据之类，失去了封闭性，也意味着可能两次输入相同的运行的输出不一样，出现不可再现的、与时间有关的错误。 进程的基本概念 传统意义上，进程是程序在一个数据集上的运行过程，是系统进行资源分配和调度的一个独立单位。其实体由程序段、相关的数据段和进程控制块（PCB）构成。 与程序不同，程序只是一堆死的代码，是静态的；而进程是“运行过程”，讲的是个动态的概念（就是因为动态所以才会出不可再现的错误，一般意义上不会认为程序会出不可再现的错误对吧）。这是它最本质的特征。 多个进程互相独立地运行、分配资源、接受调度，共同存在于内存中，且可以并发执行。但执行是异步的。 如果一个进程万事俱备只欠处理机资源，就叫它是就绪（Ready）的；给了处理机资源跑起来了，就叫它在执行（Running），规定的时间片结束后回到就绪态等待下一次进程调度；前面说了并发执行有间断性，一个进程等的时候就叫阻塞（Blocked），一般是执行态时进入阻塞态，此时处理机去执行其它进程，这个进程等好后进入就绪态。 除以上三种基本状态外，进程在创建时叫创建状态，此时申请并填写PCB、分配资源，完成后进入就绪状态；终止时叫终止状态，善后处理，清零PCB之类；还有种挂起状态。 OS对进程的描述 OS使用进程控制块记录一个进程。包含如下信息： 进程标识符，包括编号（OS根据这个使用进程，其它都是给用户看的）、名字、对应父进程子进程的标识和用户标识（谁拥有此进程）等； 处理机状态，保存各寄存器的内容，中断后好恢复； 进程调度信息，进程当前状态、优先级和其它信息，例如现在阻塞了为啥阻塞的、进程等了多久、总共跑了多久之类； 进程控制信息，程序和数据的地址、有关进程同步和通信的信息、该进程需要哪些资源已经分配了哪些资源、指向PCB中下一个进程的指针。 一般OS用链接方式或索引方式组织PCB。链接方式即弄三个队列，分别对应就绪的、阻塞的和空白的PCB，还有一个指针指向正在执行的进程；索引就是用表来实现。 进程控制 进程控制包括创建进程、终止进程和进程状态转换 是进程管理最基本的功能，由OS内核完成。 创建进程（Create） 一个进程创建另一个进程，有如下情况： 用户登录，用户登录OS时OS内核为该用户创建一个进程，插入就绪队列； 作业调度，多道批处理里面该调度个新程序开始跑时OS内核就给它创建一个进程； 提供服务，用户程序要求某种请求时OS内核为这个服务创建一个进程，这样这个服务和用户程序也是可以并发的，比方说Word，并不是说打印的时候就不能操作了； 应用请求，应用程序可以请求创建进程。 Unix中把创建进程的进程称为父进程，被创建的进程称为子进程，子进程继承父进程的资源，销毁父进程时子进程一并销毁。Windows中不存在此概念，每个进程有一个句柄决定它可以控制哪些其它进程。 创建进程时，OS调用进程创建原语创建进程。首先申请空白PCB，然后为新进程分配内存等，然后初始化PCB，最后插入就绪队列。 终止进程（） 一个进程被终止，有如下情况： 正常结束，程序里专门有条指令调用系统中端告诉OS我好了； 异常，程序试图越界访问资源、调用非法指令、运行或等待超时、算术运算错误等情况； 外界干预，例如发生系统死锁，就只好由OS或操作者看看能不能救，或父进程被销毁于是子进程被株连，或父进程清理门户。 终止进程时，OS调用进程终止原语终止进程。首先找到它，确定状态，要是还在执行就先停掉并置调度标志为真待会下一个就绪的进程好跑；看看有没有子进程，有的话一并终止；归还资源，移出队列。 进程的阻塞与唤醒（block/wakeup） 一个进程被阻塞，有如下情况： 请求系统服务，但系统暂时无法提供； 启动某种操作，某种必须做完才能继续的操作，例如等待I/O； 等数据之类； 无事可做。 阻塞进程时，进程主动调用阻塞原语把自己阻塞。首先停止执行，接下来修改PCB状态为阻塞，并将PCB插入阻塞队列，保存现场，重分配处理机。 唤醒进程时，将之移出阻塞队列，修改PCB状态为就绪，插入就绪队列。 进程的挂起与激活（suspend/active） 挂起进程时，调用挂起原语。首先检查其状态。若处于活动就绪或执行状态，则将其转为静止就绪；若处于活动阻塞,则将其转为静止阻塞。将PCB放到特定内存区域，如果之前该进程在执行，就重新调度。 激活进程时，将进程从外存调入内存，检查其状态，若是静止就绪，则改为活动就绪；若是静止阻塞，则改为活动阻塞。若采用的是抢占式调度策略，则还应检查被激活就绪进程的优先级，若其优先级比先行执行进程高，则应将处理机分配给被激活进程。 进程同步 为避免异步，需要进程同步。 多个进程间可能存在制约关系导致异步。对于多个进程的共享资源，如打印机，各进程应当互斥地访问，一般必须向系统提出申请，由OS分配，叫间接制约；对于不许经过系统直接就能访问的资源的制约关系，如两个进程都需用到某个缓冲区，叫直接制约。 在一段时间内只能由一个进程访问的资源（硬或软）叫临界资源。访问临界资源的循环进程描述如下： 1while(true)2&#123;3 非临界区，其它代码；4 进入区，检查资源是否正被访问；5 临界区，访问临界资源；6 退出区，将正被访问标志恢复至未被访问；7 非临界区，其它代码。8&#125; 一个同步机制，应当保证临界资源未被访问时可以被访问，正被访问时无法被访问；要求访问临界资源的进程在有限时间内可以访问得到，进程等待访问临界区时处理机给其它进程用（否则叫“忙等”）。 常用进程同步机制 硬件同步机制 利用特殊的硬件指令解决临界区问题。 关中断 利用Test-and-Set指令 利用 Swap指令 缺陷： 忙等 难于解决进程同步问题 信号量机制 Dijkstra提出了整型信号量机制，后来慢慢发展，先是记录型信号量，然后AND型信号量，再然后信号量集，卓有成效且应用广泛。 最初信号量是一个整型S，表示资源数目。被用一个就减一，释放一个就加一。当有程序想访问资源时就死循环地看还剩几个资源，直到资源数大于零时跳出循环使用资源。这里如果得不到资源无法让出处理机给其它进程用，会导致忙等。 记录（即结构体）型信号量由一个代表临界资源数目的整型变量value和该资源上阻塞的队列（链表）指针L构成。value和整型信号量中的S意义相同。当发现资源数小于等于零时，不是一直死循环地看资源数直到大于零，而是调用阻塞原语自我阻塞，并把自己插入至L，value自减。也就是说，value为负数时，其相反数为被阻塞的进程数。释放资源时如果发现value小于零，就唤醒一个阻塞队列中的进程。 把资源的请求和释放写成函数，大致如下： 1struct Semaphore2&#123;3 int value;4 PCB* list;5&#125;S;67void wait(S)8&#123;9 S.value = S.value – 1 ;10 if ( S.value &lt; 0 ) 11 block (S.list) ;12 /* 让权等待 */13&#125;1415void signal (S)16&#123;17 S.value = S.value + 1 ;18 if ( S.value &lt;= 0 )19 wakeup (S.list) ;20 /*唤醒第一个等待的进程 */21&#125; 若有n个进程m个资源，信号量的可能范围就是m~(m-n)。 利用信号量机制实现进程互斥地访问临界资源，只需将S.value初值设为1，将wait(S)作为进入区、signal(S)作为退出区。 除了利用信号量机制控制资源的访问、实现进程互斥外，还可以用来实现前驱关系。 管程机制 略。 经典进程同步问题 生产者-消费者问题 生产者生产东西，放到缓冲区，消费者从缓冲区拿东西。生产者放东西到缓冲区前会先看一眼，如果满了，就不放；消费者拿东西前也会看一眼，如果没了，就不拿。 看起来没什么问题。写成程序就有问题了。 用一个cnt记录缓冲区的东西数量，生产者或消费者先读cnt的值，再改变它。改变cnt值的过程通常是如下的命令： 1MOV 存储器,寄存器2INC 寄存器3MOV 寄存器,存储器 或 1MOV 存储器,寄存器2DEC 寄存器3MOV 寄存器,存储器 如果第二个MOV前插入了其它指令比如另一个进程的第一个MOV指令，就会出错。 比如初值为1时，如果并发地执行这两坨指令，有可能得到0或1或2三种结果。 回到生产者-消费者问题，由简单到复杂有多种情况： 一个生产者、一个消费者、缓冲区可以放一个东西的问题； 一个生产者、一个消费者、缓冲区可以放若干东西的问题； 若干生产者、若干消费者、缓冲区可以放若干东西的问题。 对于最简单的情况，为同步双方设置各自的信号量，初值为其初始状态可用的资源数；增加进入区和退出区，同步双方任一进程在进入临界区之前，应先对自己的信号量执行wait(&lt;己方信号量&gt;)操作，以测试是否有自己可用的资源，若有资源可用，则进入临界区，否则阻塞；同步双方任一进程离开临界区后，应对对方的信号量执行signal(&lt;对方信号量&gt;)操作，以通知对方已有资源可用： 1item buffer;2//生产者和消费者的信号量3semaphore empty,full;4//生产者最初信号量为1，可以向缓冲池放一个产品5empty.value=1;6//消费者最初信号量为0，没有东西可拿7full.value=0;8cobegin9 process Producer()10 &#123;11 ...12 produce an item in nextp;13 ...14 //测试能不能放东西15 wait(empty);16 //nextp放入buffer17 buffer=nextp;18 //通知被阻塞的消费者19 signal(full);20 &#125;21 process Consumer()22 &#123;23 //测试能不能拿东西24 wait(full);25 //buffer内的东西拿到nextc26 nextc=buffer;27 //通知被阻塞的生产者28 signal(empty);29 ...30 consume the item in nextc;31 ...32 &#125;33coend 若缓冲区可放k个东西，只需将生产者的初值记为k即可。另外为生产者和消费者分别提供一个下标指定其访问的缓冲区位置： 1item buffer[n];2//生产者和消费者的信号量3semaphore empty,full;4//生产者最初信号量为k，可以向缓冲池放k个产品5empty.value=k;6//消费者最初信号量为0，没有东西可拿7full.value=0;8//当前下标都是09int in=0,out=0;10cobegin11 process Producer()12 &#123;13 ...14 produce an item in nextp;15 ...16 //测试能不能放东西17 wait(empty);18 //nextp放入buffer[in]19 buffer[in]=nextp;20 //计算下一个位置21 in=(in+1)%k;22 //通知被阻塞的消费者23 signal(full);24 &#125;25 process Consumer()26 &#123;27 //测试能不能拿东西28 wait(full); 29 //buffer[out]内的东西拿到nextc30 nextc=buffer[out];31 //计算下一个位置32 out=(out+1)%k;33 //通知被阻塞的生产者34 signal(empty);35 ...36 consume the item in nextc;37 ...38 &#125;39coend 对于最复杂的情况，连下标的in和out都会出现冲突了，因为不止一个生产者、不止一个消费者，所以访问in和out也需要。 1item buffer[n] ;2//in和out的信号量、生产者和消费者的信号量3semaphore mutex,empty,full;4//当前下标都是05int in = 0，out = 0 ；6//两个下标最初信号量为1，可以被一个生产者或消费者访问7mutex.value = 1;8//生产者最初信号量为k，可以向缓冲池放k个产品9empty.value=k;10//消费者最初信号量为0，没有东西可拿11full.value = 0;12cobegin13 process produceri()//(i=1,2,…,k)14 &#123;15 item nextp ；16 while (TRUE)17 &#123; ...18 produce an item in nextp；19 ...20 wait(empty)；21 wait(mutex)；22 buffer[in] = nextp ；23 in = (in + 1)% n ；24 signal(mutex)；25 signal(full)；26 &#125;27 &#125;28 process consumerj()//(j=1,2,…,m)29 &#123; item nextc ；30 while (TRUE)31 &#123;32 wait(full)；33 wait(mutex)；34 nextc = buffer[out] ；35 out = (out + 1)% n ；36 signal(mutex)；37 signal(empty)；38 ...39 consume the item in nextc ；40 ...41 &#125;42 &#125;43coend 哲学家就餐问题 有5个哲学家共用一张圆桌，分别坐在周围的5张椅子上，在圆桌上有5个碗和5只筷子（每人面前一只碗，左右手边各一双筷子），他们的生活方式是交替地进行思考和进餐。平时，每个哲学家进行思考，饥饿时便试图拿起其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐完毕，放下筷子继续思考。 5个筷子用五个信号量表示即可。 1semaphore chopstick[5]；2chopstick[0].value=1;3chopstick[1].value=1;4chopstick[2].value=1;5chopstick[3].value=1;6chopstick[4].value=1;78cobegin9 process Pi()//(i = 0，1，2，3，4)10 &#123;11 while (true)12 &#123;13 //拿起左边筷子14 wait(chopstick[i])；15 //拿起右边筷子16 wait(chopstick[(i + 1)%5])；17 eating；18 //放下左边筷子19 signal(chopstick[i])；20 //放下右边筷子21 signal(chopstick[(i+1)%5])；22 thinking；23 &#125;24 &#125;25coend 问题在于如果所有人都拿着左边筷子，就陷入了死锁。 解决办法法很多： 至多允许4个哲学家同时取左边的筷子，这样能至少保证一个哲学家能就餐，并在用毕后释放他用过的两只筷子，从而使更多的哲学家能够进餐； 仅当哲学家左右两只筷子均可用时（AND信号量机制），才允许他拿起筷子进餐； 规定奇数号哲学家先拿左边筷子，然后再拿右边筷子；而偶数号哲学家先拿右边筷子，然后再拿左边筷子； 规定每个哲学家先拿序号小的筷子——按序号分配。 以第一种方法为例，再加一个关于左边筷子能否取用的信号量即可。 1semaphore chopstick[5],S；2chopstick[0].value=1;3chopstick[1].value=1;4chopstick[2].value=1;5chopstick[3].value=1;6chopstick[4].value=1;7S.value=4;89cobegin10 process Pi()//(i = 0，1，2，3，4)11 &#123;12 while (true)13 &#123;14 //能否拿筷子15 wait(S);16 //拿起左边筷子17 wait(chopstick[i])；18 //拿起右边筷子19 wait(chopstick[(i + 1)%5])；20 eating；21 //放下左边筷子22 signal(chopstick[i])；23 //放下右边筷子24 signal(chopstick[(i+1)%5])；25 //释放能否拿筷子标记26 signal(S);27 thinking；28 &#125;29 &#125;30coend 读者-写者问题 一个数据文件或记录，可被多个进程共享，我们把只要求读该文件的进程称为“读者进程”，其他进程称为“写者进程”。显然，只要有一个写者进程正访问文件，就不能有其它进程访问。 因此可设置一个初值为1的信号量，表示当前允许的写者数，同时用一个普通变量记录读者数。由于可能同时有多个进程尝试访问读者数，还需为这个访问设置一个信号量。 1semaphore Wmutex，Rmutex;2int Rcounter = 0;3Wmutex.value=Rmutex.value=1; 4cobegin5 process Readeri()//(i = 1，2，…)6 &#123;7 wait(Rmutex);8 if(Rcounter==0)9 //等写者信号10 wait(Wmutex);11 Rcounter = Rcounter + 1;12 signal(Rmutex);13 …14 Reading;15 …16 wait(Rmutex);17 Rcounter = Rcounter – 1;18 if(Rcounter==0)19 signal(Wmutex);20 signal(Rmutex);21 &#125; 22 process Writerj()//(j=1，2，…)23 &#123;24 wait(Wmutex);25 Writing;26 signal(Wmutex);27 &#125;28coend 问题在于，如果一个读者正在读时来了写者，然后读者还没读完，又来一个读者。现在假设第一个读者读完了，但计数器显示仍有读者，于是写者标记未被释放，新读者反而早于更早来的写者访问文件。一直如此则写者将被饿死。 考虑再增加一个信号量，如果有写者到达，则晚于此写者的读者将无法访问： 1semaphore Wmutex,Rmutex,w;2int Rcounter = 0;3Wmutex.value=Rmutex.value=w.value=1; 4cobegin5 process Readeri()//(i = 1，2，…)6 &#123;7 //有写者的话之后的w就不能访问了8 wait(w);9 wait(Rmutex);10 if(Rcounter==0)11 //等写者信号12 wait(Wmutex);13 Rcounter = Rcounter + 1;14 signal(Rmutex);15 signal(w);16 …17 Reading;18 …19 wait(Rmutex);20 Rcounter = Rcounter – 1;21 if(Rcounter==0)22 signal(Wmutex);23 signal(Rmutex);24 &#125; 25 process Writerj()//(j=1，2，…)26 &#123;27 //有写者的话之后的w就不能访问了28 wait(w);29 wait(Wmutex);30 Writing;31 signal(Wmutex);32 signal(w);33 &#125;34coend 这个算法解决了读者读完后除非已经没有读者否则被唤醒的一定是读者的问题。现在在写者写完后被唤醒的不一定是读者或写者，随缘。如果想要被唤醒的一定是写者，可以： 1//Wmutex用于写进程互斥访问Wcounter2//Wsem用于封锁有写者时封锁后续写进程3semaphore Wmutex=Wsem= 1；4//Rmutex用于读进程互斥访问Rcounter5//Rsem1用于在有写者时封锁后续第一个读者6//Rsem2用于在Rsem1起效后封锁后续所有读者7semaphore Rmutex=Rsem1=Rsem2=1;8int Rcounter = Wconuter = 0;9cobegin10 process Reader_i (i = 1，2，…)11 &#123;12 //是否是写者后的读者后的读者13 wait(Rsem2);14 //是否是写者后的读者15 wait(Rsem1);16 //是否有人正在访问计数器17 wait(Rmutex);18 Rcounter = Rcounter + 1;19 //如果当前仅有自己一个读者在访问文件20 //则判断是否有写者21 if(Rcounter==1)22 wait(Wsem);23 signal(Rmutex);24 signal(Rsem1);25 signal(Rsem2);26 Reading;27 wait(Rmutex);28 Rcounter = Rcounter - 1;29 //如果当前仅有自己一个读者在访问文件并且刚刚关上30 //则判断是否有写者31 if(Rcounter==0)32 signal(Wsem);33 signal(Rmutex);34 &#125; process Writer_j (j=1，2，…)35 &#123;36 wait(Wmutex);37 Wcounter++;38 if (Wcounter==1)39 wait(Rsem1);40 signal(Wmutex);41 wait(Wsem);42 Writing( );43 signal(Wsem);44 wait(Wmutex);45 Wcounter=Wcounter-1;46 if (Wcounter==0) 47 signal(Rsem1);48 signal(Wmutex);49 &#125;50coend 进程通信 信号量机制效率太低了，且对用户不透明，因此需要设计允许透明地传送大量信息的方式，主要有： 共享存储器通信，类似生产者消费者问题中的缓冲区，但效率更高； 管道通信（共享文件）； 消息传递通信，以上两个只适合单机，这个还适合网络通信： 直接通信方式 间接通信方式——信箱通信 客户机-服务器系统，仅适合网络通信。 作业与进程的调度 就绪队列用中有许多进程，然而穷比只得起四核CPU，该让哪个进程先跑呢？要靠进程调度或作业调度。调度时有以下几种级别： （作业是比程序更广泛的概念，但仍可以使用类似PCB的方式描述，称为JCB。类似进程地，作业也有一些基本状态，收容、运行和完成状态。） 高级调度，或者叫作业调度，决定把哪些作业由外存调至内存，要考虑调几个、分别是谁； 中级调度，或者叫内存调度，主要负责进程的挂起和激活； 低级调度，或者叫进程调度，决定哪个进程使用处理机，分抢占式——某个进程跑着跑着可以被其它进程顶下去——和非抢占式。 我们希望有合适的调度算法，使处理机利用率（有效工作时间和有效工作时间加空闲时间之比）和I/O设备利用率尽可能高且对各进程公平、一些重要进程能立即被强制执行。 有以下几种常用调度算法： 先来先服务（FCFS） 顾名思义。适合有很多耗时比较长、没什么I/O的作业或进程的情况。非抢占式。 短作业优先/短进程优先（SJF/SPF） 顾名思义。可以降低平均周转时间（到达到完成的时间），但长作业可能被饿死。而且用户给的预计运行时间未必准。非抢占式。 优先级调度（PSA） 前两种算法的加强版。即前两种算法分别是单纯以到达时间或作业预计时间为优先级。如果做成抢占式的，还可以用在实时系统中。 可以静态或动态地确定优先级，通过进程类型（是I/O还是别的什么？）、资源耗费（包括时间内存等）和用户的指定等。动态确定时，可以提高一个等了很久的进程的优先级，慢慢降低正在执行的进程的优先级等。 高响应比优先调度算法（HRRN） 一种求动态优先级的方式。等待时间与要求服务时间之和与要求服务时间的比例作为优先级，谁高调用谁。 基于时间片的轮转调度法（RR） 按FCFS排列就绪队列，当处理机空闲时，将处理机分配给队首进程，等一个时间片过去，将正处理的进程排至队尾。 多级反馈队列调度算法（MFQ） 设置多个优先级不同的就绪队列，每个队列时间片长度不同，优先级越高的队列时间片越长。当一个进程到达时，将它加入优先级最高的队列的末尾。处理机执行完时间片后如果当前进程未完成，则放到低一级的队列最后。最低优先级的队列内部使用RR算法调度。当最高优先级的队列为空时才执行低一级优先的队列，依次类推。如果正在执行时有高于当前进程优先级的进程到达（即执行非最高优先级进程时有进程到达），则将当前执行的进程放至原优先级对应队列的队尾，首先执行新来的进程。 这种算法无需知道预期运行时间，比较NB。 示例 有一个具有两道作业的批处理系统（最多可有两道作业同时装入内存执行）,作业调度采用计算时间短的作业优先调度算法,进程调度采用以优先数为基础的抢占式调度算法,今有如下作业序列（表中所列作业优先数即为进程优先数,数值越小优先级越高）: 作业名 到达时间 估计运行时间 优先数 J1 10:10 20分钟 5 J2 10:20 30分钟 3 J3 10:30 25分钟 4 J4 10:50 20分钟 6 显然J1在10:10先到，装入内存并运行了10min，10:20J2到达，装入内存，由于优先级更高，抢占J1直到执行完毕即10:50，此时J3和J4都到达了。作业调度遵循短作业优先，即J4又被装入内存，其优先级低于J1，于是J1执行完毕。此时是11:00，J3也被装入内存，其优先级更高，到11:25J3执行完毕，J4最后执行。 死锁 一组进程处于死锁状态是指：如果在一个进程集合中的每一个进程都在等待只能由该集合中的其它一个进程才能引发的事件，则称一组进程或系统发生了死锁。（孙钟秀主编《操作系统教程》） 之前哲学家进餐问题有提过。主要出现原因是多个进程对某类资源有竞争、这些进程每次还不止要一个资源、且没规定好它们访问资源的顺序，就可能出现死锁。典型的情况是进程访问了一个资源，又去访问另一个，但另一个不可用，于是他在那等，又抓着已经拿到的资源不放手，导致产生一个循环，一个进程拿着另一个进程要的资源不放手，他要的资源又被另一个进程拿着不放手…… 预防 使临界资源不再临界，或一次性分配好资源而不是一个一个给，或允许进程释放已抢占的资源，或指定好访问顺序即可。 第一种情况限制太大，一般还是想让临界资源互斥的；第二种情况会拖慢系统；第三种方式不好实现；第四种方式规定太死，实际使用哪能这么巧有个顺序。 避免 既然从原理上预防死锁不太可行，于是考虑在分配资源时动态地预防。 有些时候是不会进入死锁的，例如有三个进程，分别要10、4、9个资源，已分配5、2、2个，还剩3个。这时可以分2个给第二个进程让它跑完，还剩6个；再分5个给第一个进程，最后再满足最后一个进程。这时是安全的。 有些时候会进入死锁，例如上例中的三个进程，分别要10、4、10个资源，已分配5、2、3个，还剩2个。这时可以分2个给第二个进程让它跑完，还剩4个；无论如何也找不到可以让剩下两个进程跑起来的方法了。这是不安全的。 有个银行家算法可对此进行判断，其设计之初是为了防止银行的钱（剩余资源）不够放贷（进程请求资源）的： 对有n个进程m类资源的情况，设置一个有m个元素的数组Availabe记录每个资源的剩余可用数，用三个n*m的矩阵Max、Allocation和Need表示每个进程对每种资源的需求数、已有数和还需要的数。 一个进程发出资源请求Request后进行如下检查： Requset中的元素是否不大于Need中对应元素？否则报错； Request中的元素是否不大于Available中对应元素？否则让进程等待； 尝试模拟分配完成的情况，即Avalible中元素减去Request中对应元素，Allocation中元素加上Request中对应元素，Need中元素减去Request中对应元素。 复制一个Available，名为Work。即分配完后的剩余资源数。建立一个布尔型数组Finish，对应每个进程的完成情况，初值均为false。 找哪个尚未Finish的进程的Need小于等于Work，有的话意味着剩余资源足够它执行完并释放。假装释放了，把被占用的资源Alloction加到Work上，标记这个进程为完成。重复，直到所有进程都完成，或没有进程可以被完成。 如果都能完成，说明安全，可以分配；否则不能分配。 例如现有5个进程P0~P4，三类资源A、B和C分别共有10、5和7个，当前资源分配如下： Max A/B/C Allocation A/B/C Need A/B/C P0 7/5/3 0/1/0 7/4/3 P1 3/2/2 2/0/0 1/2/2 P2 9/0/2 3/0/2 6/0/0 P3 2/2/2 2/1/1 0/1/1 P4 4/3/3 0/0/2 4/3/1 也就是说剩余如下： Avalibale A/B/C 3/3/2 比方说现在P1请求Request1(1/0/2)，先与Need比较，OK；再与Avalible比较，OK。于是模拟分配。 Max A/B/C Allocation A/B/C Need A/B/C P0 7/5/3 0/1/0 7/4/3 P1 3/2/2 3/0/2 0/2/0 P2 9/0/2 3/0/2 6/0/0 P3 2/2/2 2/1/1 0/1/1 P4 4/3/3 0/0/2 4/3/1 剩余如下： Avalibale A/B/C 2/3/0 接下来检查安全性。 最早的Work就是Avaliable，P0的Need太多，P1的够，于是有： Work A/B/C Allocation A/B/C Need A/B/C Work+Allocation A/B/C Finish P1 2/3/0 3/0/2 0/2/0 5/3/2 true 现在我们的资源变成5、3和2了，P0仍然不够，P2也不够，P3够了，于是： Work A/B/C Allocation A/B/C Need A/B/C Work+Allocation A/B/C Finish P1 2/3/0 3/0/2 0/2/0 5/3/2 true P3 5/3/2 2/1/1 0/1/1 7/4/3 true 依此类推发现所有进程都OK，于是可以分配资源。 检测 资源分配图。 解除 回收资源/撤销进程。","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/"},{"name":"操作系统","slug":"深蓝/操作系统","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://mechanicalmind.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"进程","permalink":"http://mechanicalmind.cn/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"死锁","slug":"死锁","permalink":"http://mechanicalmind.cn/tags/%E6%AD%BB%E9%94%81/"}]},{"title":"apk文件的反编译","slug":"戏法/apk文件的反编译","date":"2019-12-22T11:06:10.000Z","updated":"2019-12-22T11:06:10.000Z","comments":true,"path":"2019/12/22/戏法/apk文件的反编译/","link":"","permalink":"http://mechanicalmind.cn/2019/12/22/%E6%88%8F%E6%B3%95/apk%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%8D%E7%BC%96%E8%AF%91/","excerpt":"dex2jar、jd-GUI和apktool的简单介绍。","text":"dex2jar、jd-GUI和apktool的简单介绍。 环境： Manjaro Linux 18.1.0 dex2jar 2.1 jd-GUI 1.6.5-min apktool 2.4.1 下载dex2jar，注意下载release版本，解压得一个文件夹，里面有许多.sh，对应不同功能。其中的d2j-dex2jar.sh可以由.dex文件反编译出.jar文件，即apk的源程序字节码。 解压apk，得到文件夹，里面的.dex丢到那堆.sh的同级目录下，sh d2j-dex2jar.sh classes.dex即可得到.jar。 下载jd-GUI（这个网站时好时坏经常404，网速也差，我下的1.6.5的min版），java -jar jd-gui-1.6.5-min.jar（要给权限）可以打开一个GUI，把.jar拖进去即可查看.jar对应的源代码。 源代码之外的配置文件和资源通过apktool查看，官网有详细教程。","categories":[{"name":"戏法","slug":"戏法","permalink":"http://mechanicalmind.cn/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://mechanicalmind.cn/tags/Android/"},{"name":"反编译","slug":"反编译","permalink":"http://mechanicalmind.cn/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"}]},{"title":"操作系统・〇・总论","slug":"操作系统/操作系统・〇・总论","date":"2019-12-20T07:35:40.000Z","updated":"2019-12-19T16:00:00.000Z","comments":true,"path":"2019/12/20/操作系统/操作系统・〇・总论/","link":"","permalink":"http://mechanicalmind.cn/2019/12/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%83%BB%E3%80%87%E3%83%BB%E6%80%BB%E8%AE%BA/","excerpt":"操作系统的历史和基本概念。","text":"操作系统的历史和基本概念。 操作系统（Operating System，OS）是计算机硬件上的第一层软件，是计算机必须配置的最基本、最重要的系统软件。 设计目标与主要功能 我们希望有种东西能让用户通过I/O系统操作计算机而不是从硬件接口输入机器代码（打孔纸带啥的）从而使计算机更易用（方便性），且通过合理调度提高效率（有效性），现在软硬件啥的更新换代都贼快，我们还希望它能具有模块化、层次化、微内核结构等设计以易于升级和扩展（可扩展性），并能遵循一些通用规范使不同软硬件厂商的产品都能跑（开放性）。这个东西就是操作系统。 方便性（用户角度，OS是用户和计算机硬件系统之间的接口）和有效性（资源管理角度，OS是计算机系统资源（软、硬）的管理者）是设计OS的两个最重要的目标（即综合以上两个角度，实现对计算机资源——处理器、存储器、I/O设备、数据和程序——的抽象）。 对四种计算机资源的抽象，或叫管理，再加上方便用户使用的界面，构成了操作系统的主要功能： 处理机管理功能，基本就是对进程的管理，主要是创建和撤销（控制）、协调不同进程（同步）、信息交换（通信）和分配处理机（调度）啥的； 存储器管理功能，分配和保护内存、映射地址、虚拟存储啥的； 设备管理功能，完成I/O请求即提升I/O的效率和用户体验； 文件管理功能，存储空间和目录的管理、读写和保护； 用户接口，命令接口（用户直接控制自己的作业）、程序接口（程序向系统请求服务）。 除此之外，一个现代的操作系统还应具能保护自己的安全、支持多媒体、访问网络等服务。 运行机制 从上面可以看出，操作系统和用户要跑的程序是相对独立的，用户程序该干啥干啥，OS负责进程创建啥啥啥的一堆操作，而恰好这堆操作又是很关键、很危险、消耗资源很多的，所以处理机就搞了个分级制度，例如x86一共有0-3四个级别，0特权级最高，3特权级最低。Windows、Linux/Unix之类仅使用特权级0和特权级3，特权级0叫管态，干啥都行，3叫目态，只有最低级的权限。 自然，用户的程序就是运行在管态下的，OS主要运行在目态下，这部分叫OS内核，主要包括： 时钟管理 中断机制 操作原语 系统控制所需的数据结构及处理 在目态下可通过系统调用、异常、中端三种方式进入管态。 发展过程 最早的计算机没有操作系统，打孔纸带那种；因为太慢，后来可以先从外围机上输入到磁带，主机再从磁带调用；然后有了对磁带里的程序的监督程序，勉强算是操作系统了，但是还是要一个作业完成再调用下一个程序，所以叫“单道”批处理系统。 问题在于，比方说一个作业中间要打印结果，但打印的时候处理机就闲着了。于是有了“多道”批处理系统，打印的时候再调用下一个程序跑。问题又来了，最开始的程序打印完之后的半截就得等鬼知道啥时候再被调用，用户也控制不了，于是资源调度、设备分配、用户接口等原来越复杂与完善，成了真正的OS。 后来人们不满足与多人共用一台计算机，还得等，要是不用等（实时）多好，但世界上只有一种病，自己又买不起，于是有了分时系统。比方说现在有100个进程处于就绪状态，如果让处理机每20ms换一个进程执行的话那最多等两秒自己的程序就能跑了，激不激动。这就叫分时，那20ms就叫时间片的长度。 喝不上牛奶的时候我想喝牛奶，等喝上了牛奶我还想用牛奶泡澡。人的欲望是无止境的，于是后来又有了实时系统。对操作系统各方面要求更高。 结构设计上经历了如下变革： 无结构 模块式结构 层次式结构 微内核结构 微内核最近很火，被牢厂营销起来了。传统的操作系统，例如Linux，其内核包含有前面说的所有功能，但微内核只包含开关机、进程调度等最最基础的功能，而尽可能把其它功能放到目态。这样显然会变慢，所以以前没啥人做，不过现在科技发达了，所以技术实力强的公司开始作出尝试，例如谷歌基于Zircon的微内核的Fuchsia。 不太理解这个东西和“模块化的内核”有啥区别，现在OS内核也都模块化了啊。 还是太菜了。 基本特性 OS最重要的特征是并发（两个或多个事件在同一时段发生，不需要同一时刻，同一时刻叫并行）。OS为每个程序建立一些由一组机器指令、数据和堆栈等组成的活动实体，这些活动实体叫进程，多个进程之间可以并发执行并交换信息，也可以共同使用系统资源（共享性，不一定是同时的，比方说一个打印机打着别的程序的文档呢肯定另一个程序不能用，还有表、栈等数据结构一个道理，这种叫临界资源，其共享方式叫互斥共享；相反就叫同时访问的共享）。也就是说，并发是共享的基础。但共享也影响并发，资源共享都协调不好并个毛线发不死循环就不错了。这俩是最重要的特征。 由于进程的并发及其之间的资源共享，一个进程难免因为其它进程的干扰等了好久才获取资源完成任务，谁也说不准。这个叫异步性。 OS的另一个重要特征是虚拟，想要抽象地表示计算机资源，把物理实体映射为逻辑上的概念就很重要，比如虚拟处理机（一核假装成四核）、虚拟内存（磁盘假装是内存）、虚拟外部设备（共享打印机）和虚拟信道等。","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/"},{"name":"操作系统","slug":"深蓝/操作系统","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://mechanicalmind.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"FFmpeg","slug":"快门工/FFmpeg","date":"2019-12-19T08:47:10.000Z","updated":"2020-01-01T08:47:10.000Z","comments":true,"path":"2019/12/19/快门工/FFmpeg/","link":"","permalink":"http://mechanicalmind.cn/2019/12/19/%E5%BF%AB%E9%97%A8%E5%B7%A5/FFmpeg/","excerpt":"录制、转换以及流化音视频的完整解决方案。","text":"录制、转换以及流化音视频的完整解决方案。 FFmpeg项目由以下几部分组成： FFmpeg，视频文件转换命令行工具； ffserver，多媒体服务器； ffplay，简单的媒体播放器； libavcodec，编解码器库； libavformat，解析器和产生器库。 许多播放器、转码器使用FFmpeg作为内核，例如暴风影音、KMPlayer、QQ影音、格式工厂之类。 安装 Manjaro自带。 使用 【用到啥更新啥】 画面与声音合并：ffmpeg -i 画面 -i 声音 -codec copy 目标视频（参数-i指定这是一个输入项，-codec表示强制使用codec编解码方式。copy表示原始编解码数据必须被拷贝）。 截取音视频：ffmpeg -i 输入 -ss 00:00:00 -t 10 输出，单位为秒，不影响输入内容；输出可以为gif格式。可添加-b 2048k参数指定比特虑，获得高质量gif。 视频缩放：ffmpeg -i 输入视频 -strict -2 -vf scale=-1:480 输出视频（按比例缩放高度至480）或ffmpeg -i 输入视频 -strict -2 -s 640x480 输出视频。 格式转换：ffmpeg -i 输入 -vcodec 指定格式 输出，可以是h264、mpeg4、libxvid、wmv1和wmv2等。 速率调整：ffmpeg -i 输入音画 -filter_complex &quot;[0:v]setpts=速率*PTS[v];[0:a]atempo=速率[a]&quot; -map &quot;[v]&quot; -map &quot;[a]&quot; 输出音画，单独视频是ffmpeg -i 输入视频 -an -filter:v &quot;setpts=速率*PTS&quot; 输出视频，单独音频是ffmpeg -i 输入音频 -filter:a &quot;atempo=2.0&quot; -vn 输出音频。视频的变速范围为4倍（0.25~4），音频为2倍。 将帧合成为视频：ffmpeg -loop 1 -i ./%d.jpg -vcodec libx264 -r 帧率 test.mp4。","categories":[{"name":"快门工","slug":"快门工","permalink":"http://mechanicalmind.cn/categories/%E5%BF%AB%E9%97%A8%E5%B7%A5/"},{"name":"视频后期","slug":"快门工/视频后期","permalink":"http://mechanicalmind.cn/categories/%E5%BF%AB%E9%97%A8%E5%B7%A5/%E8%A7%86%E9%A2%91%E5%90%8E%E6%9C%9F/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://mechanicalmind.cn/tags/FFmpeg/"}]},{"title":"基于区域生长的图像分割","slug":"快门工/基于区域生长的图像分割","date":"2019-12-17T13:13:16.000Z","updated":"2019-12-17T13:13:16.000Z","comments":true,"path":"2019/12/17/快门工/基于区域生长的图像分割/","link":"","permalink":"http://mechanicalmind.cn/2019/12/17/%E5%BF%AB%E9%97%A8%E5%B7%A5/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/","excerpt":"","text":"根据种子选取准则选择种子，根据相似准则加入与种子相似的点，根据终止准则停止生长。 例如对如下图片： \\[ \\begin{matrix} 3&amp;3&amp;4&amp;7&amp;6&amp;4&amp;5&amp;2\\\\ 4&amp;4&amp;8&amp;9&amp;7&amp;4&amp;3&amp;3\\\\ 2&amp;3&amp;4&amp;8&amp;4&amp;4&amp;5&amp;4\\\\ 2&amp;4&amp;3&amp;7&amp;7&amp;4&amp;5&amp;4\\\\ 4&amp;3&amp;4&amp;8&amp;9&amp;8&amp;3&amp;3\\\\ 2&amp;4&amp;4&amp;2&amp;7&amp;2&amp;5&amp;2\\\\ 4&amp;4&amp;3&amp;2&amp;6&amp;2&amp;3&amp;3\\\\ 4&amp;3&amp;3&amp;3&amp;4&amp;4&amp;3&amp;4\\\\ \\end{matrix} \\] 有： 种子选择准则：最亮的点； 相似性准则：新加入像素的灰度值与已生长的区域的平均灰度值之差小于2，且为4连通。 终止准则：没有像素加入。 种子选取： \\[ \\begin{matrix} 3&amp;3&amp;4&amp;7&amp;6&amp;4&amp;5&amp;2\\\\ 4&amp;4&amp;8&amp;(9)&amp;7&amp;4&amp;3&amp;3\\\\ 2&amp;3&amp;4&amp;8&amp;4&amp;4&amp;5&amp;4\\\\ 2&amp;4&amp;3&amp;7&amp;7&amp;4&amp;5&amp;4\\\\ 4&amp;3&amp;4&amp;8&amp;(9)&amp;8&amp;3&amp;3\\\\ 2&amp;4&amp;4&amp;2&amp;7&amp;2&amp;5&amp;2\\\\ 4&amp;4&amp;3&amp;2&amp;6&amp;2&amp;3&amp;3\\\\ 4&amp;3&amp;3&amp;3&amp;4&amp;4&amp;3&amp;4\\\\ \\end{matrix} \\] 以生长区域区域平均值为9。则根据相似性准则，下一步应添加生长区域的点的四邻域内的、灰度值大于7的像素。 \\[ \\begin{matrix} 3&amp;3&amp;4&amp;7&amp;6&amp;4&amp;5&amp;2\\\\ 4&amp;4&amp;(8)&amp;(9)&amp;7&amp;4&amp;3&amp;3\\\\ 2&amp;3&amp;4&amp;(8)&amp;4&amp;4&amp;5&amp;4\\\\ 2&amp;4&amp;3&amp;7&amp;7&amp;4&amp;5&amp;4\\\\ 4&amp;3&amp;4&amp;(8)&amp;(9)&amp;(8)&amp;3&amp;3\\\\ 2&amp;4&amp;4&amp;2&amp;7&amp;2&amp;5&amp;2\\\\ 4&amp;4&amp;3&amp;2&amp;6&amp;2&amp;3&amp;3\\\\ 4&amp;3&amp;3&amp;3&amp;4&amp;4&amp;3&amp;4\\\\ \\end{matrix} \\] 以生长区域区域平均值为(9+8+8)/3=8.33和(9+8+8)/3=8.33。则根据相似性准则，下一步应添加生长区域的点的四邻域内的、灰度值大于6.33的像素。 \\[ \\begin{matrix} 3&amp;3&amp;4&amp;(7)&amp;6&amp;4&amp;5&amp;2\\\\ 4&amp;4&amp;(8)&amp;(9)&amp;(7)&amp;4&amp;3&amp;3\\\\ 2&amp;3&amp;4&amp;(8)&amp;4&amp;4&amp;5&amp;4\\\\ 2&amp;4&amp;3&amp;(7)&amp;(7)&amp;4&amp;5&amp;4\\\\ 4&amp;3&amp;4&amp;(8)&amp;(9)&amp;(8)&amp;3&amp;3\\\\ 2&amp;4&amp;4&amp;2&amp;(7)&amp;2&amp;5&amp;2\\\\ 4&amp;4&amp;3&amp;2&amp;6&amp;2&amp;3&amp;3\\\\ 4&amp;3&amp;3&amp;3&amp;4&amp;4&amp;3&amp;4\\\\ \\end{matrix} \\] 以生长区域区域平均值为(9+8+8+9+8+8+7+7+7+7+7)/11=7.7272。则根据相似性准则，下一步应添加生长区域的点的四邻域内的、灰度值大于5.7272的像素。 \\[ \\begin{matrix} 3&amp;3&amp;4&amp;(7)&amp;(6)&amp;4&amp;5&amp;2\\\\ 4&amp;4&amp;(8)&amp;(9)&amp;(7)&amp;4&amp;3&amp;3\\\\ 2&amp;3&amp;4&amp;(8)&amp;4&amp;4&amp;5&amp;4\\\\ 2&amp;4&amp;3&amp;(7)&amp;(7)&amp;4&amp;5&amp;4\\\\ 4&amp;3&amp;4&amp;(8)&amp;(9)&amp;(8)&amp;3&amp;3\\\\ 2&amp;4&amp;4&amp;2&amp;(7)&amp;2&amp;5&amp;2\\\\ 4&amp;4&amp;3&amp;2&amp;(6)&amp;2&amp;3&amp;3\\\\ 4&amp;3&amp;3&amp;3&amp;4&amp;4&amp;3&amp;4\\\\ \\end{matrix} \\] 以生长区域区域平均值为(9+8+8+9+8+8+7+7+7+7+7+6+6)/13=7.4615。则根据相似性准则，下一步应添加生长区域的点的四邻域内的、灰度值大于5.4615的像素。 找不到。符合终止准则，生长结束。 故得到如下结果： \\[ \\begin{matrix} &amp; &amp;1&amp;1&amp; \\\\ &amp;1&amp;1&amp;1&amp; \\\\ &amp; &amp;1&amp; &amp; \\\\ &amp; &amp;1&amp;1&amp; \\\\ &amp; &amp;1&amp;1&amp;1\\\\ &amp; &amp; &amp;1&amp; \\\\ &amp; &amp; &amp;1&amp; \\\\ &amp; &amp; &amp; &amp; \\\\ \\end{matrix} \\]","categories":[{"name":"快门工","slug":"快门工","permalink":"http://mechanicalmind.cn/categories/%E5%BF%AB%E9%97%A8%E5%B7%A5/"},{"name":"图像处理","slug":"快门工/图像处理","permalink":"http://mechanicalmind.cn/categories/%E5%BF%AB%E9%97%A8%E5%B7%A5/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"http://mechanicalmind.cn/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"区域生长","slug":"区域生长","permalink":"http://mechanicalmind.cn/tags/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF/"},{"name":"图像分割","slug":"图像分割","permalink":"http://mechanicalmind.cn/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"}]},{"title":"二值图像的轮廓提取与边界跟踪","slug":"快门工/二值图像的轮廓提取与边界跟踪","date":"2019-12-17T11:20:25.000Z","updated":"2019-12-17T11:20:25.000Z","comments":true,"path":"2019/12/17/快门工/二值图像的轮廓提取与边界跟踪/","link":"","permalink":"http://mechanicalmind.cn/2019/12/17/%E5%BF%AB%E9%97%A8%E5%B7%A5/%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F%E7%9A%84%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96%E4%B8%8E%E8%BE%B9%E7%95%8C%E8%B7%9F%E8%B8%AA/","excerpt":"","text":"对二值图像，若一亮点周围 8 个点均为黑点，则其为非轮廓点，将之置为黑点。对所有亮点执行此操作即可获得轮廓。 获得轮廓后可由其上一点（一般最左上）跟踪出整个边界，同时记录信息。如对于以下轮廓： \\[ \\begin{matrix} c\\backslash r &amp;_0&amp;_1&amp;_2&amp;_3&amp;_4&amp;_5&amp;_6\\\\ _0&amp;1&amp;1&amp; &amp; &amp; &amp; &amp; \\\\ _1&amp;1&amp; &amp;1&amp;1&amp;1&amp;1&amp;1\\\\ _2&amp;1&amp; &amp; &amp; &amp; &amp; &amp;1\\\\ _3&amp;1&amp;1&amp; &amp; &amp; &amp;1&amp; \\\\ _4&amp; &amp; &amp;1&amp;1&amp; &amp;1&amp; \\\\ _5&amp; &amp; &amp; &amp; &amp;1&amp; &amp; \\\\ \\end{matrix} \\] 类似广搜地，定义一个dir[4][2]={ {0,1},{-1,0},{0,-1},{1,0} };或dir[8][2]={ {0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1},{1,0},{1,1} };。 由于起始点是最左上的角，所以对于四方向的情况，搜索从方向3开始；对于八方向的情况则从5开始（好傻冒的约定，为啥不把开始搜索的作为0……）。 因为这个SB约定，搜索下一个逆时针方向时对应的下标是(i+1)%4或(i+1)%8而非i+1。顺时针类似。 对这个图使用八方向的顺时针搜索方式，第一个点从方向5开始，到方向0找到了下一个点(0,1)。 接下来为了保持顺时针的跟踪方向，应将当前方向也就是0逆时针旋转一个方向再进行顺时针搜索；若是正在进行逆时针搜索就顺时针旋转一个方向再逆时针搜索，即(i+3)%4或(i+7)%8。特别的，对八方向的情况，如果是斜着过来的（方向为奇数），则旋转两个方向。这样可以保证之前走过的点最后被搜索到。 因此对该图的第二次搜索由方向1开始，顺时针到方向7找到下一个点(1,2)。 依次类推，每次的方向分别是：0700006565343422。 这玩意叫8连通方向码，或8方向链码。 每次变到当前方向分别是顺时针旋转了：2170002171271720个方向过来的。 这玩意叫8方向差分链码。 为了统一不同起点的不同情况，引入归一化链码。同一个封闭边界的不同起点的各个链码可以看作是由表示该边界的一串数字循环移位得到的，如果把这一串数看作N位自然数，则不同的起点就形成不同大小的N位自然数，将最小的N位自然数串作为归一化链码。 示例轮廓的归一化链码为：0000656534342207。 链码可以计算周长。斜着走即奇数方向的按根二算，否则按一算，加起来即可。","categories":[{"name":"快门工","slug":"快门工","permalink":"http://mechanicalmind.cn/categories/%E5%BF%AB%E9%97%A8%E5%B7%A5/"},{"name":"图像处理","slug":"快门工/图像处理","permalink":"http://mechanicalmind.cn/categories/%E5%BF%AB%E9%97%A8%E5%B7%A5/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"http://mechanicalmind.cn/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"轮廓提取","slug":"轮廓提取","permalink":"http://mechanicalmind.cn/tags/%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/"},{"name":"边界跟踪","slug":"边界跟踪","permalink":"http://mechanicalmind.cn/tags/%E8%BE%B9%E7%95%8C%E8%B7%9F%E8%B8%AA/"}]},{"title":"HTML与CSS基础知识","slug":"表世界/HTML与CSS/HTML与CSS基础知识","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-15T16:00:00.000Z","comments":true,"path":"2019/12/16/表世界/HTML与CSS/HTML与CSS基础知识/","link":"","permalink":"http://mechanicalmind.cn/2019/12/16/%E8%A1%A8%E4%B8%96%E7%95%8C/HTML%E4%B8%8ECSS/HTML%E4%B8%8ECSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"CSS及其BOX模型简介。","text":"CSS及其BOX模型简介。 CSS基础 CSS，Cascading Style Sheets，层叠样式表单。层叠是指多个样式可以同时应用于同一个页面或网页中的同一个标签，执行的效果按照“层叠规则”；当标签的样式定义发生冲突时，靠近标签的定义将生效。利用CSS可实现内容和形式的分离。 按照加入方式不同，可分为： 行内样式表：&lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt;。优先度最高，可控制一个标签。 内部样式表：将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义。 1&lt;style type=\"text/CSS\"&gt;2 选择器 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;3 ...4&lt;/style&gt; 优先度次之，可控制整个页面。 外部样式表：也是在头文件中写&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;test.css&quot;&gt;&lt;/link&gt;，即，用href属性指定CSS文件位置，type属性设定为&quot;text/css&quot;，rel属性设定为&quot;stylesheet&quot;。优先度最低，但方便。 样式优先级规则可以通过!important关键字进行改变，如div{color:#f00!important;color:#000;}，#f00的优先级被提升，将高于#000，最终显示#f00。 样式定义的基本格式包括选择器、属性和属性值。定义通用样式时，选择器设为*。而p{ font-family: &quot;宋体&quot;; }定义的样式仅作用于HTML文件的&lt;p&gt;标记、font-family属性。形如p.right {text-align:right }定义了属性选择器，这个样式就仅对right类中的p有效。如果想让它作用于作用于HTML中的某个p，就须就须设置为&lt;p class=&quot;right&quot; ... /&gt;。形如p＃green {color:green}定义了id选择器，仅对&lt;p id=&quot;green&quot;&gt;...&lt;/p&gt;有效。 常用的字体CSS属性有font-family、font-size、font-style和font-weight。常用的文本CSS属性有text-indent、text-align、text-decoration、text-transform和color、letter-spacing、line-height。常用的背景CSS属性有background-color、background-image、background-repeat、background-position和background-attchment。 BOX模型 BOX模型制定了元素如何在页面中显示，可以理解为，顶部俯视一些装了东西的盒子，盒子里装的东西即内容（content）；东西与盒子之间的空隙即内边距（padding）；盒子本身的厚度即边框（border）；盒子外与其他盒子之间的间隔即外边距（margin），也就是说，BOX模型有内容、内边距、边框、外边距四要素。 例如{position:absolute;left:20px;top:20px }设置了一个相对位置。 示例 1/*限定作用类是因为不限定的话会与markdown自动生成的html格式冲突*/2&lt;style type=text/css&gt;3 ul.testul&#123;4 list-style-type: none;5 line-height: 200%;6 &#125;7 li.testli&#123;8 padding: 5px;9 margin: 10 10px; /*这个用来调整导航之间的间距*/10 display: inline-block;11 width: 120px;12 height: 40px;13 text-align: center;14 display: inline;15 &#125;16&lt;/style&gt;17&lt;ul class=testul style=\"list-style-type:none;line-height: 200%;\"&gt;18 &lt;li class=testli&gt;&lt;a href=http://www.baidu.com&gt;网站首页&lt;/a&gt;&lt;/li&gt;19 &lt;li class=testli&gt;&lt;a href=http://www.baidu.com&gt;学院概况&lt;/a&gt;&lt;/li&gt;20 &lt;li class=testli&gt;&lt;a href=http://www.baidu.com&gt;机构设置&lt;/a&gt;&lt;/li&gt;21 &lt;li class=testli&gt;&lt;a href=http://www.baidu.com&gt;教学科研&lt;/a&gt;&lt;/li&gt;22 &lt;li class=testli&gt;&lt;a href=http://www.baidu.com&gt;国际交流&lt;/a&gt;&lt;/li&gt;23 &lt;li class=testli&gt;&lt;a href=http://www.baidu.com&gt;党建思政&lt;/a&gt;&lt;/li&gt;24&lt;/ul&gt; 效果如下： ul.testul{ list-style-type: none; line-height: 200%; } li.testli{ padding: 5px; margin: 10 10px; /*这个用来调整导航之间的间距*/ display: inline-block; width: 120px; height: 40px; text-align: center; display: inline; } 网站首页 学院概况 机构设置 教学科研 国际交流 党建思政","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"HTML与CSS","slug":"表世界/HTML与CSS","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/HTML%E4%B8%8ECSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://mechanicalmind.cn/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://mechanicalmind.cn/tags/HTML/"}]},{"title":"Struts2基础知识","slug":"表世界/Struts2/Structs2基础知识","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-15T16:00:00.000Z","comments":true,"path":"2019/12/16/表世界/Struts2/Structs2基础知识/","link":"","permalink":"http://mechanicalmind.cn/2019/12/16/%E8%A1%A8%E4%B8%96%E7%95%8C/Struts2/Structs2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"理解MVC模式与SSH框架。","text":"理解MVC模式与SSH框架。 Struts2对请求的基本处理流程及相关配置文件 Web应用项目启动时会先加载Web.xml配置文件，通过里面指定的过滤器拦截请求，因此开发Struts框架Web应用项目，首先在项目配置文件web.xml中增加核心过滤器配置： 1&lt;filter&gt;2 &lt;filter-name&gt;struts2&lt;/filter-name&gt;3 &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;4&lt;/filter&gt;5&lt;filter-mapping&gt;6 &lt;filter-name&gt;struts2&lt;/filter-name&gt;7 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;8&lt;/filter-mapping&gt; 符合过滤要求的请求将由struts.xml中配置的Struts2拦截器拦截。 自定义拦截器的基类一般是Interceptor，一般至少包括init()、destroy()和intercept()三个函数。在拦截函数中通过invocation.invok()调用Action，程序流转至Action。 例如如下自定义拦截器： 1&lt;package name=\"itcast\" namespace=\"/test\" extends=\"struts-default\"&gt;2 &lt;interceptors&gt;3 &lt;interceptor name=\"定义的拦截器名字\" class=\"定义的拦截器类文件\"/&gt;4 &lt;interceptor-stack name=\"定义的拦截器堆栈名字\"&gt;5 &lt;!--以下给出拦截器堆栈包含的拦截器--&gt;6 &lt;interceptor-ref name=\"defaultStack\" /&gt;7 &lt;interceptor-ref name=\"定义的拦截器名字\" /&gt;8 &lt;/interceptor-stack&gt;9 &lt;/interceptors&gt;10 &lt;action ...&gt;11 ...12 &lt;!--在Action中指出要包含拦截器--&gt;13 &lt;interceptor-ref name=\"定义的拦截器堆栈名字\"/&gt;14 &lt;/action&gt;15&lt;/package&gt; defult-interceptor-ref指定默认拦截器。 转至Action后将从struts.xml中找到动作的处理类执行。struts.xml主要的部分如下： 1&lt;package name=\"包名\" namespace=\"名字空间，可不写\" extends=\"继承的包，可不写\" abstract=\"是否是抽象包，可不写\"&gt;2 &lt;action name=\"请求的动作名\" class=\"处理类的路径，可不写\" method=\"方法名，缺省为execute方法\" converter=\"指定类型转换器，可不写\"&gt;3 &lt;result name=\"动作的返回值，缺省为success\" type=\"返回结果类型，缺省为dispatcher，可转向一个结果页面；redirectAction转向动作；redirect转向动作或url\"&gt;结果页面&lt;/result&gt;4 &lt;/action&gt;5&lt;/package&gt; 可以看出，作为动作的处理类的Java类应当无形参并返回一个String，缺省的映射函数为execute()方法，用其它方法返回的话需要在method中设置一下。默认的基类为ActionSupport。 还可使用include标签导入多个struts-xxx.xml。 Web项目部署路径包括协议名、服务器名、端口号、项目名称、（可能有的）名字空间和动作名，也就是形如http://localhost/8088/struts2/simple/hello.action，可以看出Action缺省的扩展名为.action。这里没有额外的名字空间，所以服务器将在/simple下搜索hello.action；形如http://server/struts2/path1/path2/path3/hello.action，服务器首先在/path1/path2/path3名字空间搜索。 在Action有较多方法（即struts.xml配置中使用了通配符配置、定义Action）时，Struts2支持通过函数名调用Action的方法（函数），即动态方法调用。当多个action中都使用到了相同result，在struts.xml中用globle-results可把result定义为全局结果。 除Web.xml和struts.xml外，还有struts-default.xml、struts-plugin.xml、struts.xml、struts.properties。加载顺序为struts-default.xml &gt; struts-plugin.xml &gt; struts.xml &gt; struts.properties &gt; web.xml。 Action函数所在类文件，用ActionContext的静态成员函数getContext获取Action运行环境及内容。JSP页面可直接使用的内置对象Request所对应的Java类是HttpServletRequest，Response所对应的Java类是HttpServletResponse。 示例，这是一个上传文件的表单，提交该表单后由一个JSP表达式获取Action运行环境及内容，调用Action： 1&lt;!--enctype属性规定在发送到服务器之前应该如何对表单数据进行编码。multipart/form-data即不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。--&gt;2&lt;form enctype=\"multipart/from-data\" action=\"$&lt;%=request.getContextPath()&gt;/upload.action\" method=\"post\"&gt;3 &lt;input type=\"file\" name=\"uploadImage\"&gt;4 &lt;input type=\"submit\"&gt;5&lt;/form&gt; jsp页面效果如下： Action函数所在的Java类UploadAction: 1public class UploadAction&#123;2 //上传的文件3 private File uploadImage;4 //上传文件的类型5 private String uploadImageContentType;6 //上传文件的名称7 private String uploadImageFileName;89 public String upload() throws Exception&#123;10 String realpath =ServletActionContext.getServletContext( ).getRealPath(\"/images\");11 File file = new File(realpath);12 if( !file.exists( ) )13 file.mkdirs( );14 FileUtils.copyFile(uploadImage, new File(file,uploadImageFileName)); 15 return \"success\";16 &#125;17&#125; 除此之外，ActionSupport还提供了一个validate()，可以在执行Action前对所有方法得到的值进行校验。当某个控件数据校验失败时，一般调用addFieldError()向系统的fieldErrors添加校验失败信息，在JSP页面可通过s:fielderror显示失败信息。如果有些方法不需要被校验，则可以在不需要使用校验的方法上注解@SkipValidation或使用形如validateXxx()的重写方法，这将只校验xxx方法。 SSH框架 SSH，Struts+Spring+Hibernate，是古代较为流行的一种Web应用程序开源框架。其设计模式分为表示层（View）、业务层（Service）、DAO层（DAO，Data Access Object，数据访问对象）和工具层（Util）、。实际使用时表示层请求业务层的方法（通过Struts请求动作，由Spring管理调度对象的生命周期——而不是new），业务层通过DAO层调用工具层完成对数据的操作（对数据的操作用到Hibernate，不过下面的例子用的JDBC）。 一个典型的程序如下，程序来自印度国家信息技术学院（？），struts.xml配置如下： 1&lt;package name=\"Login\" namespace=\"/\" extends=\"struts-default\"&gt;2 &lt;action name=\"listAll\" class=\"com.stu.Action.StudentAction\" method=\"listAll\"&gt;3 &lt;result name=\"success\"&gt;main.jsp&lt;/result&gt;4 &lt;/action&gt;5 &lt;action name=\"addStu\" class=\"com.stu.Action.StudentAction\" method=\"addStu\"&gt;6 &lt;result name=\"success\"&gt;index.jsp&lt;/result&gt;7 &lt;result name=\"input\"&gt;addNew.jsp&lt;/result&gt;8 &lt;/action&gt;9 &lt;action name=\"editStu\" class=\"com.stu.Action.StudentAction\" method=\"editStu\"&gt;10 &lt;result name=\"success\"&gt;index.jsp&lt;/result&gt;11 &lt;result name=\"input\"&gt;editStu.jsp&lt;/result&gt;12 &lt;/action&gt;13 &lt;action name=\"deleteStu\" class=\"com.stu.Action.StudentAction\" method=\"deleteStu\"&gt;14 &lt;result name=\"success\"&gt;index.jsp&lt;/result&gt;15 &lt;/action&gt;16 &lt;action name=\"goToEdit\" class=\"com.stu.Action.StudentAction\" method=\"goToEdit\"&gt;17 &lt;result name=\"success\"&gt;editStu.jsp&lt;/result&gt;18 &lt;/action&gt;19 &lt;action name=\"goToUpdate\" class=\"com.stu.Action.UploadAction\" method=\"goToUpload\"&gt;20 &lt;result name=\"success\"&gt;upload.jsp&lt;/result&gt;21 &lt;/action&gt;22 &lt;action name=\"upload\" class=\"com.stu.Action.UploadAction\" method=\"upload\"&gt;23 &lt;param name=\"savePath\"&gt;upload/&lt;/param&gt;24 &lt;result name=\"success\"&gt;/index.jsp&lt;/result&gt;25 &lt;result name=\"input\"&gt;/upload.jsp&lt;/result&gt;26 &lt;interceptor-ref name=\"defaultStack\"&gt;27 &lt;param name=\"fileUpload.maximumSize\"&gt;1048576&lt;/param&gt;28 &lt;param name=\"fileUpload.allowedTypes\"&gt;image/bmp,image/jpeg,image/gif,image/png&lt;/param&gt;29 &lt;/interceptor-ref&gt;30 &lt;/action&gt;31&lt;/package&gt; 首先用一个modle类表示对应的数据库，把表映射为类、记录映射为对象、字段映射为类成员，这种方法叫ORM，Object Relation Mapping： 1package com.stu.model;23public class Student &#123;4 private int id;5 private String StuId;6 private String StuName;7 private int course1;8 private int course2;9 private int course3;10 private String EnterTime;11 private String email;12 private String headImg;1314 public Student() &#123;15 &#125;1617 public Student(String StuId, String StuName, int course1, int course2, int course3, String EnterTime, String email) &#123;18 this.StuId = StuId;19 this.StuName = StuName;20 this.course1 = course1;21 this.course2 = course2;22 this.course3 = course3;23 this.EnterTime = EnterTime;24 this.email = email;25 &#125;2627 public int getId() &#123;28 return id;29 &#125;3031 public void setId(int id) &#123;32 this.id = id;33 &#125;3435 public String getStuId() &#123;36 return StuId;37 &#125;3839 public void setStuId(String stuId) &#123;40 StuId = stuId;41 &#125;4243 public String getStuName() &#123;44 return StuName;45 &#125;4647 public void setStuName(String stuName) &#123;48 StuName = stuName;49 &#125;5051 public int getCourse1() &#123;52 return course1;53 &#125;5455 public void setCourse1(int course1) &#123;56 this.course1 = course1;57 &#125;5859 public int getCourse2() &#123;60 return course2;61 &#125;6263 public void setCourse2(int course2) &#123;64 this.course2 = course2;65 &#125;6667 public int getCourse3() &#123;68 return course3;69 &#125;7071 public void setCourse3(int course3) &#123;72 this.course3 = course3;73 &#125;7475 public String getEnterTime() &#123;76 return EnterTime;77 &#125;7879 public void setEnterTime(String enterTime) &#123;80 EnterTime = enterTime;81 &#125;8283 public String getEmail() &#123;84 return email;85 &#125;8687 public void setEmail(String email) &#123;88 this.email = email;89 &#125;9091 public String getHeadImg() &#123;92 return headImg;93 &#125;94 public void setHeadImg(String headImg) &#123;95 this.headImg = headImg;96 &#125;9798 @Override99 public String toString() &#123;100 return \"Student&#123;\" +101 \"id=\" + id +102 \", StuId='\" + StuId + '\\'' +103 \", StuName='\" + StuName + '\\'' +104 \", course1=\" + course1 +105 \", course2=\" + course2 +106 \", course3=\" + course3 +107 \", EnterTime='\" + EnterTime + '\\'' +108 \", email='\" + email + '\\'' +109 \", headImg='\" + headImg + '\\'' +110 '&#125;';111 &#125;112&#125; 接下来编写DAO层操作数据时使用的工具层： 1package com.stu.Util;23import java.sql.CallableStatement;4import java.sql.Connection;5import java.sql.DriverManager;6import java.sql.PreparedStatement;7import java.sql.ResultSet;8import java.sql.ResultSetMetaData;9import java.sql.SQLException;10import java.util.ArrayList;11import java.util.HashMap;12import java.util.List;13import java.util.Map;1415//DAO层通过该类操作数据库16public class JDBCUtil &#123;17 private static JDBCUtil instance = null;18 private static String driver = null;19 private static String url = null;20 private static String username = null;21 private static String password = null;22 private CallableStatement callableStatement = null;23 24 private Connection conn = null;25 private PreparedStatement pst = null;26 private ResultSet rst = null;27 28 //单例模式的对象生成，JDBCUtil只需要有一个实例29 public static JDBCUtil getInstance() &#123;30 if (instance==null) &#123;31 String driver = \"com.mysql.jdbc.Driver\";32 //数据库连接URL字符串一般情况下包括连接方式、服务器地址（名称）、端口号和数据库名称四部分。33 String url = \"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\";34 String username = \"root\";35 String password = \"niitniit\";36 instance = new JDBCUtil(driver, url, username, password);37 &#125;38 return instance;39 &#125;4041 public JDBCUtil(String driver, String url, String username, String password) &#123;42 this.driver = driver;43 this.url = url;44 this.username = username;45 this.password = password;46 &#125;4748 //创建连接49 public Connection getConnection() &#123;50 try &#123;51 try &#123;52 //动态加载驱动类，此时会自动新建一个Driver的对象并注册到DriverManager53 Class.forName(driver);54 &#125; catch (ClassNotFoundException e) &#123;55 System.out.println(\"...\");56 System.out.println(e.getMessage());57 e.printStackTrace();58 &#125;59 //创建连接60 conn = DriverManager.getConnection(url, username, password);61 &#125; catch (SQLException e) &#123;62 System.out.println(e.getMessage());63 &#125;64 return conn;65 &#125;6667 //数据库的更新操作68 public int executeUpdate(String sql, Object[] params) &#123;69 int affectedLine = 0;70 try &#123;71 conn = this.getConnection();72 //把SQL语句串转换为PreparedStatement对象。73 pst = conn.prepareStatement(sql);74 if (params != null) &#123;75 for (int i = 0; i &lt; params.length; i++) &#123;76 //调用prepareStatement的setObject以绑定参数77 pst.setObject(i + 1, params[i]);78 &#125;79 &#125;80 //更新81 affectedLine = pst.executeUpdate();82 &#125; catch (SQLException e) &#123;83 System.out.println(e.getMessage());84 &#125; finally &#123;85 closeAll();86 &#125;87 return affectedLine;88 &#125;8990 //查询结果集91 private ResultSet executeQueryRS(String sql, Object[] params) &#123;92 try &#123;93 conn = this.getConnection();94 //把SQL语句串转换为PreparedStatement对象。95 pst = conn.prepareStatement(sql);96 if (params != null) &#123;97 for (int i = 0; i &lt; params.length; i++) &#123;98 //调用prepareStatement的setObject以绑定参数99 pst.setObject(i + 1, params[i]);100 &#125;101 &#125;102 //执行查询103 rst = pst.executeQuery();104 &#125; catch (SQLException e) &#123;105 System.out.println(e.getMessage());106 &#125;107 return rst;108 &#125;109110 //查询单个结果111 public Object executeQuerySingle(String sql, Object[] params) &#123;112 Object object = null;113 try &#123;114 conn = this.getConnection();115 //把SQL语句串转换为PreparedStatement对象。116 pst = conn.prepareStatement(sql);117 if (params != null) &#123;118 for (int i = 0; i &lt; params.length; i++) &#123;119 //调用prepareStatement的setObject以绑定参数120 pst.setObject(i + 1, params[i]);121 &#125;122 &#125;123 //执行查询124 rst = pst.executeQuery();125 //但只返回第一个结果126 if (rst.next()) &#123;127 object = rst.getObject(1);128 &#125;129 &#125; catch (SQLException e) &#123;130 System.out.println(e.getMessage());131 &#125; finally &#123;132 closeAll();133 &#125;134 return object;135 &#125;136137 //查询结果集并返回list138 public List&lt;Object&gt; excuteQuery(String sql, Object[] params) &#123;139 //查询结果集140 ResultSet rs = executeQueryRS(sql, params);141 //数据的相关信息142 ResultSetMetaData rsmd = null;143 int columnCount = 0;144 try &#123;145 //获取数据信息146 rsmd = rs.getMetaData();147 //获取行数148 columnCount = rsmd.getColumnCount(); 149 &#125; catch (SQLException e1) &#123;150 System.out.println(e1.getMessage()); 151 &#125;152 List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); 153 try &#123;154 while (rs.next()) &#123;155 Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();156 for (int i = 1; i &lt;= columnCount; i++) &#123;157 map.put(rsmd.getColumnLabel(i), rs.getObject(i));158 &#125;159 list.add(map);160 &#125;161 &#125; catch (SQLException e) &#123;162 System.out.println(e.getMessage()); 163 &#125; finally &#123;164 closeAll();165 &#125;166 return list;167 &#125;168 169 //从前面的结果集中返回单个结果（好像是吧……）170 public Object excuteQuery(String sql, Object[] params,int outParamPos, int SqlType) &#123; 171 Object object = null; 172 conn = this.getConnection(); 173 try &#123; 174 callableStatement = conn.prepareCall(sql);175 if(params != null) &#123; 176 for(int i = 0; i &lt; params.length; i++) &#123; 177 callableStatement.setObject(i + 1, params[i]); 178 &#125;179 &#125;180 callableStatement.registerOutParameter(outParamPos, SqlType);181 callableStatement.execute();182 object = callableStatement.getObject(outParamPos); 183 &#125; catch (SQLException e) &#123; 184 System.out.println(e.getMessage()); 185 &#125; finally &#123;186 closeAll();187 &#125;188 return object;189 &#125;190 191 192 private void closeAll() &#123; 193 if (rst != null) &#123; 194 try &#123; 195 rst.close(); 196 &#125; catch (SQLException e) &#123; 197 System.out.println(e.getMessage()); 198 &#125; 199 &#125;200 if (pst != null) &#123; 201 try &#123; 202 pst.close(); 203 &#125; catch (SQLException e) &#123; 204 System.out.println(e.getMessage()); 205 &#125; 206 &#125;207 if (callableStatement != null) &#123; 208 try &#123; 209 callableStatement.close(); 210 &#125; catch (SQLException e) &#123; 211 System.out.println(e.getMessage()); 212 &#125; 213 &#125;214 if (conn != null) &#123; 215 try &#123; 216 conn.close(); 217 &#125; catch (SQLException e) &#123; 218 System.out.println(e.getMessage()); 219 &#125; 220 &#125; 221 &#125; 222&#125; 接下来是DAO层的代码： 1package com.stu.Util;23import com.stu.model.Student;45import java.sql.Timestamp;6import java.text.SimpleDateFormat;7import java.util.ArrayList;8import java.util.HashMap;9import java.util.List;1011public class StudentDao &#123;1213 //增14 public static void insert(Student student) &#123;15 String sql = \"insert into Student(StuId,StuName,Course1,Course2,Course3,EnterTime,Email) values(?,?,?,?,?,?,?)\";16 JDBCUtil util = JDBCUtil.getInstance();17 util.executeUpdate(sql, new Object[]&#123;student.getStuId(), student.getStuName(), student.getCourse1(),student.getCourse2(), student.getCourse3(), student.getEnterTime(), student.getEmail()&#125;);18 &#125;1920 //删21 public static void delete(int id) &#123;22 String sql = \"delete from Student where id = ?\";23 JDBCUtil util = JDBCUtil.getInstance();24 util.executeUpdate(sql, new Object[]&#123;id&#125;);25 &#125;2627 //选28 public static Student select(int Id) &#123;29 String sql = \"select * from Student where id = ?\";30 JDBCUtil util = JDBCUtil.getInstance();31 List&lt;Object&gt; tmp = util.excuteQuery(sql, new Object[]&#123;Id&#125;);32 HashMap&lt;String, Object&gt; map;33 SimpleDateFormat format = new SimpleDateFormat(\"yyyyMMdd\");34 Student stu;35 String StuId;36 String StuName;37 int course1;38 int course2;39 int course3;40 String EnterTime;41 String email;42 String headImg;43 for (Object obj : tmp) &#123;44 map = (HashMap&lt;String, Object&gt;) obj;45 StuId = (String) map.get(\"StuId\");46 StuName = (String) map.get(\"StuName\");47 course1 = (Integer) map.get(\"Course1\");48 course2 = (Integer) map.get(\"Course2\");49 course3 = (Integer) map.get(\"Course3\");50 EnterTime = format.format((Timestamp) (map.get(\"EnterTime\")));51 email = (String) map.get(\"Email\");52 headImg = (String) map.get(\"headImg\");53 stu = new Student(StuId, StuName, course1, course2, course3, EnterTime, email);54 stu.setHeadImg(headImg);55 stu.setId(Id);56 return stu;57 &#125;58 return null;59 &#125;6061 //查62 public static ArrayList&lt;Student&gt; queryAll() &#123;63 String sql = \"select * from Student\";64 ArrayList&lt;Student&gt; res = new ArrayList&lt;Student&gt;();65 JDBCUtil util = JDBCUtil.getInstance();66 List&lt;Object&gt; tmp = util.excuteQuery(sql, null);67 HashMap&lt;String, Object&gt; map;68 SimpleDateFormat format = new SimpleDateFormat(\"yyyyMMdd\");69 Student stu;70 int Id;71 String StuId;72 String StuName;73 int course1;74 int course2;75 int course3;76 String EnterTime;77 String email;78 String headImg;79 for (Object obj : tmp) &#123;80 map = (HashMap&lt;String, Object&gt;) obj;81 Id = (Integer) map.get(\"id\");82 StuId = (String) map.get(\"StuId\");83 StuName = (String) map.get(\"StuName\");84 course1 = (Integer) map.get(\"Course1\");85 course2 = (Integer) map.get(\"Course2\");86 course3 = (Integer) map.get(\"Course3\");87 EnterTime = format.format((Timestamp) (map.get(\"EnterTime\")));88 email = (String) map.get(\"Email\");89 headImg = (String) map.get(\"headImg\");90 stu = new Student(StuId, StuName, course1, course2, course3, EnterTime, email);91 stu.setHeadImg(headImg);92 stu.setId(Id);93 res.add(stu);94 &#125;95 return res;96 &#125;9798 //更新99 public static void update(Student student) &#123;100 String sql = \"update Student set StuId = ? , StuName = ? , Course1 = ? , Course2 = ? , Course3 = ? , EnterTime = ? , Email = ? , headImg = ? where id = ?\";101 JDBCUtil util = JDBCUtil.getInstance();102 util.executeUpdate(sql, new Object[]&#123;student.getStuId(), student.getStuName(), student.getCourse1(),103 student.getCourse2(), student.getCourse3(), student.getEnterTime(), student.getEmail(), student.getHeadImg(), student.getId()&#125;);104 &#125;105&#125; 接下来是业务层，这里写了两个类，一个对应对记录的各种操作： 1package com.stu.Action;23import com.opensymphony.xwork2.ActionContext;45import com.opensymphony.xwork2.ActionSupport;6import com.stu.Util.StudentDao;7import com.stu.model.Student;8import org.apache.struts2.ServletActionContext;910import java.util.ArrayList;11import java.util.List;12import java.util.regex.Pattern;1314public class StudentAction extends ActionSupport &#123;1516 private static final long serialVersionUID = 1L;1718 private List&lt;Integer&gt; grade;19 private Student student = new Student();20 private ArrayList&lt;Student&gt; students = new ArrayList&lt;Student&gt;();21 private int Id;2223 public StudentAction() &#123;24 grade = new ArrayList&lt;Integer&gt;();25 for (int i = 0; i &lt;= 100; i++)26 grade.add(i);27 &#125;2829 public int getId() &#123;30 return Id;31 &#125;3233 public void setId(int id) &#123;34 Id = id;35 &#125;3637 public Student getStudent() &#123;38 return student;39 &#125;4041 public List&lt;Integer&gt; getGrade() &#123;42 return grade;43 &#125;4445 public void setGrade(List&lt;Integer&gt; grade) &#123;46 this.grade = grade;47 &#125;4849 public void setStudent(Student student) &#123;50 this.student = student;51 &#125;5253 public ArrayList&lt;Student&gt; getStudents() &#123;54 return students;55 &#125;5657 public void setStudents(ArrayList&lt;Student&gt; students) &#123;58 this.students = students;59 &#125;6061 public String listAll() &#123;62 students = StudentDao.queryAll();63 System.out.println(students.size());64 return \"success\";65 &#125;6667 public String addStu() &#123;68 System.out.println(student);69 StudentDao.insert(student);70 return \"success\";71 &#125;7273 public String editStu() &#123;74 System.out.println(student);75 StudentDao.update(student);76 return \"success\";77 &#125;7879 public String goToEdit() &#123;80 System.out.println(Id);81 student = StudentDao.select(Id);82 System.out.println(student);83 ActionContext.getContext().getSession().put(\"headImg\",student.getHeadImg());84 return \"success\";85 &#125;8687 public String deleteStu() &#123;88 StudentDao.delete(Id);89 return \"success\";90 &#125;9192 public void validateAddStu() &#123;93 vali();94 &#125;9596 public void validateEditStu() &#123;97 vali();98 &#125;99100 private void vali() &#123;101 String username = student.getStuName();102 String studentId = student.getStuId();103 String email = student.getEmail();104 if (studentId == null || studentId.isEmpty())105 this.addFieldError(\"error\", \"Student Id cannot be empty\");106 else if (!Pattern.matches(\"^[a-zA-Z][a-zA-Z0-9_]&#123;3,14&#125;$\", studentId))107 this.addFieldError(\"error\", \"Student Id must start with character\\n and can follow with\" +108 \" digital character or underline which length between 4 and 15\");109 else if (username == null || username.isEmpty())110 this.addFieldError(\"error\", \"Student Name cannot be empty\");111 else if (email == null || email.isEmpty())112 this.addFieldError(\"error\", \"email cannot be empty\");113 else if (!Pattern.matches(\"^[A-Za-z0-9\\\\u4e00-\\\\u9fa5]+@[a-zA-Z0-9_-]+(\\\\.[a-zA-Z0-9_-]+)+$\", email))114 this.addFieldError(\"error\", \"email address illegal\");115 &#125;116&#125; 一个专门对应图片的上传： 1package com.stu.Action;23import com.opensymphony.xwork2.ActionContext;4import com.opensymphony.xwork2.ActionSupport;5import com.stu.Util.StudentDao;6import com.stu.model.Student;7import org.apache.struts2.ServletActionContext;89import java.io.*;1011public class UploadAction extends ActionSupport &#123;12 private String savePath;13 private File file;14 private String fileFileName;15 private String fileContentType;16 private int Id;17 private static int id;18 private Student student;1920 public String getSavePath() &#123;21 return savePath;22 &#125;2324 public void setSavePath(String savePath) &#123;25 this.savePath = savePath;26 &#125;2728 public File getFile() &#123;29 return file;30 &#125;3132 public void setFile(File file) &#123;33 this.file = file;34 &#125;3536 public String getFileFileName() &#123;37 return fileFileName;38 &#125;3940 public void setFileFileName(String fileFileName) &#123;41 this.fileFileName = fileFileName;42 &#125;4344 public String getFileContentType() &#123;45 return fileContentType;46 &#125;4748 public void setFileContentType(String fileContentType) &#123;49 this.fileContentType = fileContentType;50 &#125;5152 public int getId() &#123;53 return Id;54 &#125;5556 public void setId(int id) &#123;57 Id = id;58 &#125;5960 public Student getStudent() &#123;61 return student;62 &#125;6364 public void setStudent(Student student) &#123;65 this.student = student;66 &#125;6768 public String upload() throws Exception &#123;69 String path = ServletActionContext.getServletContext().getRealPath(savePath);70 File saveFile = new File(path);71 if (!saveFile.exists())72 saveFile.mkdir();73 String saveFilePath = path+\"/\" + fileFileName;74 System.out.println(saveFilePath);75 BufferedInputStream bis = null;76 BufferedOutputStream bos = null;77 String url = savePath + \"/\" + fileFileName;78 try &#123;79 bis = new BufferedInputStream(new FileInputStream(file));80 bos = new BufferedOutputStream(new FileOutputStream(saveFilePath));81 byte[] buf = new byte[(int) file.length()];82 int len;83 while ((len = bis.read(buf)) != -1)84 bos.write(buf, 0, len);85 student = StudentDao.select(id);86 System.out.println(student);87 System.out.println(id);88 if (student != null) &#123;89 student.setHeadImg(url);90 StudentDao.update(student);91 student = StudentDao.select(id);92 System.out.println(student);93 &#125;94 System.out.println(student);95 &#125; catch (IOException e) &#123;96 e.printStackTrace();97 &#125; finally &#123;98 if (bis != null) bis.close();99 if (bos != null) bos.close();100 &#125;101 return \"success\";102 &#125;103104 public String goToUpload() &#123;105 student = StudentDao.select(Id);106 id = Id;107 ActionContext.getContext().getSession().put(\"headImg\",student.getHeadImg());108 System.out.println(Id);109 return \"success\";110 &#125;111112&#125; 在页面层中，加载完毕后先列出所有记录的函数： 1...2&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;3&lt;% 4 String path = request.getContextPath(); 5 String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\"; 6 pageContext.setAttribute(\"basePath\",basePath); 7%&gt; 8&lt;html&gt;9 &lt;head&gt;...&lt;/head&gt;10 &lt;body&gt;&lt;/body&gt;11 &lt;script type=\"text/javascript\"&gt; 12 window.location.replace(\"$&#123;pageScope.basePath&#125;/listAll\"); 13 &lt;/script&gt;14&lt;/html&gt; 这个过程会跳转到main.jsp： 1...2&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;3&lt;%4 String path = request.getContextPath();5 String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";6 pageContext.setAttribute(\"basePath\", basePath);7%&gt;8&lt;html&gt;9&lt;head&gt;10 &lt;style type=\"text/css\"&gt;11 th &#123;12 width: 1px;13 white-space: nowrap; /* 自适应宽度*/14 word-break: keep-all; /* 避免长单词截断，保持全部 */15 background-color: gray;16 text-color: white;17 &#125;18 td &#123;19 text-align: center;20 &#125;21 table &#123;22 table-layout: fixed;23 width: 100%;24 &#125;25 &lt;/style&gt;26&lt;/head&gt;27&lt;body&gt;28&lt;center&gt;29 &lt;h2&gt;Student Info Manage System&lt;/h2&gt;30 &lt;hr/&gt;31 &lt;span&gt;&lt;a href=\"$&#123;pageScope.basePath&#125;/listAll\"&gt;refresh&lt;/a&gt;&lt;/span&gt;32 &lt;span&gt;&lt;a href=\"$&#123;pageScope.basePath&#125;/addNew.jsp\"&gt;add student&lt;/a&gt;&lt;/span&gt;33 &lt;table align=\"center\" border=\"1\" width=\"50%\" cellspacing=\"0\" cellpadding=\"0\"&gt;34 &lt;tr&gt;35 &lt;th&gt;序列号&lt;/th&gt;36 &lt;th&gt;头像&lt;/th&gt;37 &lt;th&gt;学生学号&lt;/th&gt;38 &lt;th&gt;学生姓名&lt;/th&gt;39 &lt;th&gt;课程1成绩&lt;/th&gt;40 &lt;th&gt;课程2成绩&lt;/th&gt;41 &lt;th&gt;课程3成绩&lt;/th&gt;42 &lt;th&gt;入学时间&lt;/th&gt;43 &lt;th&gt;电子邮箱&lt;/th&gt;44 &lt;th&gt;操作&lt;/th&gt;45 &lt;th&gt;上传头像&lt;/th&gt;46 &lt;/tr&gt;47 &lt;s:iterator value=\"students\" status=\"i\"&gt;48 &lt;tr&gt;49 &lt;td&gt;&lt;s:property value=\"Id\"/&gt;&lt;/td&gt;50 &lt;td&gt;&lt;img style=\"width: 30px;height: 30px;border-radius: 50%\" src=\"&lt;%=basePath%&gt;$&#123;headImg&#125;\"&gt;&lt;/td&gt;51 &lt;td&gt;&lt;s:property value=\"StuId\"/&gt;&lt;/td&gt;52 &lt;td&gt;&lt;s:property value=\"StuName\"/&gt;&lt;/td&gt;53 &lt;td&gt;&lt;s:property value=\"course1\"/&gt;&lt;/td&gt;54 &lt;td&gt;&lt;s:property value=\"course2\"/&gt;&lt;/td&gt;55 &lt;td&gt;&lt;s:property value=\"course3\"/&gt;&lt;/td&gt;56 &lt;td&gt;&lt;s:property value=\"EnterTime\"/&gt;&lt;/td&gt;57 &lt;td&gt;&lt;s:property value=\"email\"/&gt;&lt;/td&gt;58 &lt;td&gt;&lt;a href=\"$&#123;pageScope.basePath&#125;/goToEdit?Id=$&#123;Id&#125;\"&gt;edit&lt;/a&gt;59 &lt;a href=\"$&#123;pageScope.basePath&#125;/deleteStu?Id=$&#123;Id&#125;\"&gt;delete&lt;/a&gt;&lt;/td&gt;60 &lt;td&gt;&lt;a href=\"$&#123;pageScope.basePath&#125;/goToUpdate?Id=$&#123;Id&#125;\"&gt;upload&lt;/a&gt;&lt;/td&gt;61 &lt;/tr&gt;62 &lt;/s:iterator&gt;63 &lt;/table&gt;64&lt;/center&gt;65&lt;/body&gt; 这个页面有俩按钮，可以刷新和添加记录。添加记录页面如下: 1...2&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;3&lt;html&gt;4&lt;head&gt;5 ...6 &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/jquery.datetimepicker.min.css\"/&gt;7 &lt;script src=\"js/jquery.js\"&gt;&lt;/script&gt;8 &lt;script src=\"js/jquery.datetimepicker.full.min.js\"&gt;&lt;/script&gt;9&lt;/head&gt;10&lt;body&gt;11&lt;center&gt;12 &lt;h2&gt;Add New Student Info&lt;/h2&gt;13 &lt;hr/&gt;14 &lt;s:form method=\"post\" action=\"addStu\"&gt;15 &lt;s:fielderror value=\"error\" cssStyle=\"list-style: none;color: red\"/&gt;16 &lt;s:bean id=\"aa\" name=\"com.stu.Action.StudentAction\"/&gt;17 &lt;s:textfield name=\"student.StuId\" label=\"Student ID\"/&gt;18 &lt;s:textfield name=\"student.StuName\" label=\"Student Name\"/&gt;19 &lt;s:select list=\"#aa.grade\" name=\"student.course1\" label=\"Course1 Grade\"/&gt;20 &lt;s:select list=\"#aa.grade\" name=\"student.course2\" label=\"Course2 Grade\"/&gt;21 &lt;s:select list=\"#aa.grade\" name=\"student.course3\" label=\"Course3 Grade\"/&gt;22 &lt;s:textfield readonly=\"true\" value=\"20000101\" cssClass=\"datetimepicker\" name=\"student.EnterTime\"23 label=\"EnterTime\"/&gt;24 &lt;s:textfield name=\"student.email\" label=\"Email\"/&gt;25 &lt;s:reset value=\"重置\" align=\"left\"/&gt;26 &lt;s:submit value=\"登陆\" align=\"left\"/&gt;27 &lt;/s:form&gt;28&lt;/center&gt;29&lt;/body&gt;30&lt;script type=\"text/javascript\"&gt;31 jQuery('.datetimepicker').datetimepicker(&#123;32 timepicker: false,33 format: 'Ymd'34 &#125;);35&lt;/script&gt;36&lt;/html&gt; 每条记录还分别有编辑、删除和上传照片按钮，编辑界面如下： 1...2&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;3&lt;%4 String path = request.getContextPath();5 String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";6 String headImg = (String) session.getAttribute(\"headImg\");7%&gt;8&lt;html&gt;9&lt;head&gt;10 &lt;link rel=\"stylesheet\" type=\"text/css\"11 href=\"css/jquery.datetimepicker.min.css\"/&gt;12 &lt;script src=\"js/jquery.js\"&gt;&lt;/script&gt;13 &lt;script src=\"js/jquery.datetimepicker.full.min.js\"&gt;&lt;/script&gt;14&lt;/head&gt;15&lt;body&gt;16&lt;center&gt;17 &lt;h2&gt;update Student Info&lt;/h2&gt;18 &lt;hr/&gt;19 &lt;form action=\"editStu\" method=\"post\"&gt;20 &lt;s:bean name=\"com.stu.Action.StudentAction\" id=\"aa\"/&gt;21 &lt;s:fielderror value=\"error\" cssStyle=\"list-style: none;color: red\"/&gt;22 &lt;table&gt;23 &lt;tr hidden=\"hidden\"&gt;24 &lt;td&gt;Student ID:&lt;/td&gt;25 &lt;td&gt;&lt;input type=\"text\" name=\"student.Id\" value=\"$&#123;student.id&#125;\"/&gt;&lt;/td&gt;26 &lt;/tr&gt;27 &lt;tr&gt;28 &lt;td&gt;Student ID:&lt;/td&gt;29 &lt;td&gt;&lt;input type=\"text\" name=\"student.StuId\" value=\"$&#123;student.stuId&#125;\"/&gt;&lt;/td&gt;30 &lt;/tr&gt;31 &lt;tr&gt;32 &lt;td&gt;Student Name:&lt;/td&gt;33 &lt;td&gt;&lt;input type=\"text\" name=\"student.StuName\" value=\"$&#123;student.stuName&#125;\"/&gt;&lt;/td&gt;34 &lt;/tr&gt;35 &lt;tr&gt;36 &lt;td&gt;Course1 Grade:&lt;/td&gt;37 &lt;s:select list=\"#aa.grade\" name=\"student.course1\"/&gt;38 &lt;/tr&gt;39 &lt;tr&gt;40 &lt;td&gt;Course2 Grade:&lt;/td&gt;41 &lt;s:select list=\"#aa.grade\" name=\"student.course2\"/&gt;42 &lt;/tr&gt;43 &lt;tr&gt;44 &lt;td&gt;Course3 Grade:&lt;/td&gt;45 &lt;s:select list=\"#aa.grade\" name=\"student.course3\"/&gt;46 &lt;/tr&gt;47 &lt;tr&gt;48 &lt;td&gt;Enter Time:&lt;/td&gt;49 &lt;td&gt;&lt;input readonly id=\"datetimepicker\" type=\"text\"50 name=\"student.EnterTime\" value=\"$&#123;student.enterTime&#125;\"/&gt;&lt;/td&gt;51 &lt;/tr&gt;52 &lt;tr&gt;53 &lt;td&gt;Email:&lt;/td&gt;54 &lt;td&gt;&lt;input type=\"String\" name=\"student.email\" value=\"$&#123;student.email&#125;\"/&gt;&lt;/td&gt;55 &lt;/tr&gt;56 &lt;tr&gt;57 &lt;td&gt;head img:&lt;/td&gt;58 &lt;td&gt;&lt;img style=\"width: 100px;height: 100px;\" src=\"&lt;%=basePath%&gt;&lt;%=headImg%&gt;\"/&gt;&lt;/td&gt;59 &lt;/tr&gt;60 &lt;tr&gt;61 &lt;td colspan=\"2\"&gt;&lt;input type=\"submit\" value=\"submit\"&gt;&lt;/td&gt;62 &lt;/tr&gt;63 &lt;/table&gt;64 &lt;/form&gt;65&lt;/center&gt;66&lt;/body&gt;67&lt;script type=\"text/javascript\"&gt;68 jQuery('#datetimepicker').datetimepicker(&#123;69 timepicker: false,70 format: 'Ymd'71 &#125;);72&lt;/script&gt;73&lt;/html&gt; 上传界面如下： 1&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;2&lt;%3 String path = request.getContextPath();4 String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";5 String headImg = (String) session.getAttribute(\"headImg\");6%&gt;7&lt;html&gt;8&lt;head&gt;...&lt;/head&gt;9&lt;body&gt;10&lt;center&gt;11 &lt;h3&gt;Image Upload&lt;/h3&gt;12 &lt;hr/&gt;13 &lt;form action=\"upload.action\" method=\"post\" enctype=\"multipart/form-data\"&gt;14 &lt;label for=\"file\"&gt;Upload your image :&lt;/label&gt;15 &lt;input type=\"file\" id=\"file\" name=\"file\"/&gt;16 &lt;label style=\"display: block;\" for=\"file\"&gt;17 &lt;img style=\"width: 400px;height: 400px;\" id=\"Img\" src=\"&lt;%=basePath%&gt;&lt;%=headImg%&gt;\"/&gt;18 &lt;/label&gt;19 &lt;input type=\"submit\" value=\"Upload\"/&gt;20 &lt;/form&gt;21&lt;/center&gt;22&lt;/body&gt;23&lt;script type=\"text/javascript\"&gt;24 $('#file').change(function () &#123;25 $('p').css('display', 'none');26 var objUrl = getObjectURL(this.files[0]);27 if (objUrl) &#123;28 $('#Img').attr(\"src\", objUrl);29 &#125;3031 function getObjectURL(file) &#123;32 var url = null;33 if (window.createObjectURL !== undefined) &#123;34 url = window.createObjectURL(file);35 &#125; else window.webkitURL = undefined;36 if (window.URL !== undefined) &#123;37 url = window.URL.createObjectURL(file);38 &#125; else if (window.webkitURL !== undefined) &#123;39 url = window.webkitURL.createObjectURL(file);40 &#125;41 return url;42 &#125;43 &#125;);44&lt;/script&gt;45&lt;/html&gt; Struts感觉好像有点过时，应该只会了解到这里，不会再深入学习了。Spring MVC现在好像用得多？还有以JS为主的那些东西……","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"Struts2","slug":"表世界/Struts2","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/Struts2/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://mechanicalmind.cn/tags/JSP/"},{"name":"Struts2","slug":"Struts2","permalink":"http://mechanicalmind.cn/tags/Struts2/"},{"name":"SSH","slug":"SSH","permalink":"http://mechanicalmind.cn/tags/SSH/"}]},{"title":"JavaScript与jQuery基础知识","slug":"表世界/JavaScript与jQuery/JavaScript与jQuery基础知识","date":"2019-12-14T16:00:00.000Z","updated":"2019-12-15T16:00:00.000Z","comments":true,"path":"2019/12/15/表世界/JavaScript与jQuery/JavaScript与jQuery基础知识/","link":"","permalink":"http://mechanicalmind.cn/2019/12/15/%E8%A1%A8%E4%B8%96%E7%95%8C/JavaScript%E4%B8%8EjQuery/JavaScript%E4%B8%8EjQuery%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JS是JavaScript的缩写，是互联网上被广泛应用的脚本语言。 代码的引入 JS代码一般出现在.html和.js文件中，通过单独写成.js，使用外部代码引用的方式实现JS代码可以增强JS模块化开发程度并且提高代码重用率；在HTML网页中编写JS代码时，推荐出现在head区域。 head和body中插入 通过&lt;script&gt;标签把代码插入到HTML页面，&lt;script type=&quot;text/JavaScript&quot;&gt;和&lt;/script&gt;分别标记了JS代码的开始和结束。也就是说，在HTML页面文件引入JS代码，script标签的type属性要设置为text/JavaScript。 引用外部代码 script src=&quot;xx.js&quot;&gt;&lt;/script&gt;。 代码的编写 使用分号来结束一条语句。 变量名区分大小写。 运算符有赋值、算术、比较、逻辑、连接和条件运算符。 只能在function内部进行访问的变量为局部变量，页面内所有函数都可以访问的变量为全局变量。 条件语句：if、if...else...、if...else if...else...和switch，switch语句要通过break防止代码自动转向到下一个case。 循环语句：while，for，do...while和for...in循环；语句continue会跳出当轮循环进行下一轮循环，语句break会结束整个循环。 常用的字符串操作函数：oncat()、indexOf()、match()、replace()、split()、substr()、substring()等。 八个能从数学对象直接访问的数学值：自然指数E、LN2、LN10、LOG2E、LOG10E、圆周率PI、根二SQRT2、根二分之一SQRT1_2。 用警示框输出信息，语句为alert(&quot;xxx&quot;)。 编写命名函数需要以function关键词开头，return指定JS函数的返回值。通过事件触发和被调用来执行。例如HTML脚本&lt;input type=&quot;text&quot; size=&quot;30“ id=&quot;email&quot; onchange=&quot;checkEmail()&quot;&gt;中，当输入框内容改变时触发事件“onchange”，此时调用JS函数checkEmail()；对一个更复杂些的例子，&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; onblur=&quot;checkusername();checkusername2();&quot; onfocus=&quot;checkusername2();&quot; value=&quot;输入用户名&quot;&gt;，表单中有一控件username为输入用户名，此脚本对username输入框的输入内容调用JS函数checkusername校验——注意，这里有多个函数出现，所以要写分号。常用于表单上的JS事件有onfocus（获得光标）、onblur（失去光标）、onchange和onsubmit等；常用于鼠标动作的JS事件有onclick、ondbclick、onmousedown、onmouseover和onmouseup等。 在HTML文件表单中对其所包含的控件调用JS函数成批校验时，书写的脚本为&lt;form action=&quot;request.jsp&quot; name=&quot;form&quot; onsubmit=&quot;return check();&quot; method=&quot;post&quot;&gt;。 想要生成页面控件对象时，HTML页面INPUT标签的type属性设为text可在页面得到输入框；type属性设为password可在页面得到口令框；type属性设为radio可在页面得到radio button；type属性设为checkbox可在页面得到checkbox；type属性设为submit可在页面得到submit按钮；type属性设为reset可在页面得到reset按钮；ype属性设为textarea可在页面得到多行编辑控件。 想要获取页面控件对象时，如果控件有id属性，如&lt;input id=&quot;username&quot; type=&quot;text&quot; &gt;可以document.getElementById(&quot;username&quot;)；也可以利用name属性，如&lt;label name=&quot;female&quot;&gt;Female&lt;/label&gt;可以document.getElementsByName(&quot;female&quot;)[0]，注意name不唯一所以要以数组形式。 通过try...catch和onerror事件来捕捉错误。 jQuery的导入 jQuery是一个JavaScript库。以在HTML页面文件引用jQuery库jquery-1.3.1.js为例，&lt;script src=&quot;jquery-1.3.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;。 使用jQuery时，先通过选择器$()，即jQuery()，选择jQuery对象——jQuery对象是通过jQuery库包装DOM对象后产生的对象，DOM意为文档对象模型（Document Object Model）——选择好对象后通过.调用jQuery命令，对对象进行修改。 jQuery命令 执行css命令操纵样式、addClass命令设置新样式、removeClass命令删除样式、hasClass命令判断元素是否具有某样式、toggleClass命令切换样式。 执行append命令向DOM追加元素、remove命令删除DOM中元素、clone命令在DOM中复制节点、replacewith命令在DOM中替换内容、wrap命令在DOM中包裹元素。 执行show命令显示隐藏的元素，hide命令隐藏元素。 jQuery的动画函数有animate、slideup、slidedown、fadein、fadeout，以normal、fast、slow三种速度展示动画。 另一个常用命令是$(document).ready(function(){...})，（$(document)是一个选择器，选中的是整个html所有元素的集合）在页面所有元素准备完毕之后，载入页面之前执行自定义函数。例如在HTML页面文件加载（打开）时弹出“Hello World”的alert对话框，可$(document).ready(function() {alert(&quot;Hello World!&quot;);})。 jQuery选择器 基本选择器 id选择器:$(&quot;#id&quot;)； 类选择器:$(&quot;.class&quot;)； 元素选择器：$(&quot;标签名&quot;)； 全选选择器：$(&quot;*&quot;)。 示例： 1&lt;!DOCTYPE html&gt;2&lt;html&gt;3&lt;head&gt;4...5&lt;script src=\"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;6&lt;script&gt;7 $(document).ready(function()8 &#123;9 &lt;!--id选择器--&gt;10 $(\"#a\").click(function()11 &#123;12 $(this).css('color', 'yellow');13 &#125;);14 &lt;!--类选择器--&gt;15 $(\".d\").click(function()16 &#123;17 $(this).css('color', 'red');18 &lt;!--id选择器--&gt;19 $(\"#c\").css('color', 'orange');20 &#125;);21 &lt;!--全选选择器--&gt;22 $(\"*\").css('color', 'green');23 &lt;!--元素选择器--&gt;24 $(\"p\").css('color', 'pink');25 &#125;);26&lt;/script&gt;27&lt;/head&gt;28&lt;body&gt;29 &lt;h1&gt;我是一个粉刷匠&lt;/h1&gt;30 &lt;p id=\"a\"&gt;你是来搞黄色的吗？&lt;/p&gt;31 &lt;p id=\"b\" class=\"d\"&gt;气突苏！&lt;/p&gt;32 &lt;p id=\"c\" class=\"d\"&gt;如果奇迹有颜色，那一定是？&lt;/p&gt;33&lt;/body&gt;34&lt;/html&gt; 层次选择器 通过DOM元素之间的层次关系获取特定元素。 $(&quot;ancestor descendant&quot;)：选取所有子元素。 $(&quot;parent&gt;child&quot;)：同上，但仅包含直接子元素。 $(&quot;prev+next&quot;)：选取下一个元素。 $(&quot;prev~siblings&quot;)：同上，但包含之后的所有满足条件元素。 选择过滤器 jQuery过滤选择器通过指定的过滤器筛选出所需的DOM元素，即在选择器后紧跟:符号，对选取的结果集进行过滤，过滤到的结果通常会有单个元素和集合两种类型。 jQuery过滤选择器包括_____、______、______、_____、_____和___。 基本过滤器 $('p:first')：选取页面元素内的第一个p元素； $('p:last')：选取页面元素内的最后一个p元素； $('p:not(.select)')：选取选择器不是select的p元素； $('p:even')：选取索引是偶数的P元素（索引从0开始）； $('p:odd')：选取索引是奇数的p元素（索引从0开始）； $('p:eq(index)')：选取索引等于index的p元素（索引从0开始，支持负数）； $('p:gt(index)')：选取索引大于index的p元素（索引从0开始）； $('p:lt(index)')：选取索引小于index的p元素（索引从0开始）； $(':header')：选取标题元素h1~h6； $(':animated')：选取正在执行动画的元素； $('input:focus')：选取当前被焦点的元素。 内容过滤器 选取包含指定文本的元素$(':contains(含有的文本)') 选取含有选择器匹配元素的元素$(&quot;:has('选择器')&quot;) 选取不包含子元素或文本的空元素$(':empty') 选取包含子元素或文本的空元素$(':parent') 可见性过滤器 选取不可见的元素$(':hidden') 选取可见的元素$(':visible') 属性过滤器 选取拥有此属性的元素$('选择器[attribute]')； 选取属性值为value的元素$('选择器[attribute=value]')； 选取属性值不等于value的元素$('[attribute!=value]')； 选取属性值以value开始的元素$('选择器[attribute^=value]')； 选取属性值以value结束的元素$('选择器[attribute$=value]')； 选取属性值含有value的元素$('选择器[attribute*=value]')； 选取属性值前缀为value的元素$('选择器[attribute|=value]')； 选取属性值用空格分隔的值中包含给定值的元素$('选择器[attribute~=value]')； 组合属性选择器$('选择器[attribute1][attribute2]…[attributeN]')。 子元素过滤器 选取每个父元素下的第一个子元素，返回集合元素$('选择器:first-child') 选取每个父元素下的最后一个子元素，返回集合元素$('选择器:last-child') 选取每个父元素下的唯一子元素，返回集合元素$('选择器:only-child'). 选取每个父元素下的第index个子元素或者奇偶元素，index从1算起$('选择器:nth-child(index)') 表单对象属性过滤器 :enabled选取页面中所有可用元素 :disabled选取页面中所有不可用元素 :checked选取页面中所有被选中的元素（单选框radio、复选框 checkbox） :selected选取下拉列表中被选择的元素 :text选取页面中所有文本框， :password选取页面中所有口令框 :checkbox选取页面中所有检查框 :image选取页面中所有图像按钮 :button选取页面中所有按钮","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"JavaScript与jQuery","slug":"表世界/JavaScript与jQuery","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/JavaScript%E4%B8%8EjQuery/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://mechanicalmind.cn/tags/HTML/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://mechanicalmind.cn/tags/JavaScript/"}]},{"title":"JSP基础知识","slug":"表世界/JSP/JSP基础知识","date":"2019-12-13T16:00:00.000Z","updated":"2019-12-13T16:00:00.000Z","comments":true,"path":"2019/12/14/表世界/JSP/JSP基础知识/","link":"","permalink":"http://mechanicalmind.cn/2019/12/14/%E8%A1%A8%E4%B8%96%E7%95%8C/JSP/JSP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"MyEclipse的安装。","text":"MyEclipse的安装。 Servlet和JSP的关系 JSP页面缺省的基类是HttpJspBase。 jsp在运行时首先被解析成一个java类，该类继承于org.apache.jasper.runtime.HtppJspBase类，这个类又继承了HttpServlet。 JSP脚本元素 脚本元素提供了在jsp中插入java代码的能力。脚本元素有三种类型： 脚本(scriptlet)是JSP页面中Java代码片段的容器。语法：&lt;% java源代码 %&gt;。 表达式(expression)将转换为String的Java表达式的值插入到返回给客户端的响应中。语法：&lt;%= 表达式语句 %&gt;。 声明(declarations)为JSP页面声明全局的方法和变量。语法：&lt;%! 字段或方法声明 %&gt;。 JSP指令元素 page指令 用于设置页面属性。用&lt;%@ page %&gt;标记在JSP文件头部声明。 指定JSP页面使用JAVA语言时，使用指令&lt;%@page language=&quot;java&quot;%&gt;。&lt;%@page language=&quot;java&quot; contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot;%&gt;中pageEncoding设置当前页面的页面编码字符集为UTF-8，contentType设置页面类型为text/html。 使用页面指令Page的&lt;%@page import=&quot;&quot;%&gt;属性在JSP文件引用一个外部Java类。例如JSP页面要用Java的Date类时，在JSP文件前面用&lt;%@page import=&quot;Java.util.Date&quot;%&gt;把Date类包含。 用JSP进行前端页面开发时，用&lt;%@page errorPage=&quot;错误页面.jsp&quot;%&gt;设置错误页面，从而方便把多个JSP页面的出错、错误处理信息集中到错误页面处理；对于错误页面，指定&lt;%page isErrorPage=&quot;true&quot;%&gt;。 include指令 include指令在JSP页面被转换成Servlet前将指定的文件包含。比如说，可能有多页面都需要用到一个logo和一些相应的连接啥的，但可以不每次都写一遍相关代码，而是将相关代码单独写一个logo.jsp，只需在想显示它的地方使用include指令包含进来&lt;%@include file = &quot;logo.jsp&quot;%&gt;。include只能包含静态的资源。 taglib指令 用于导入标签库，使用时需设置两个重要的属性分别是uri和prefix，例如导入jsp标准标签库：&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;。这玩意类似前面的include，但是包含的不是静态jsp，而是一段java代码。导入标签库之后就可以通过&lt;前缀:类名 [参数1 [[参数2 [...]]]]&gt;&lt;/前缀:类名&gt;插入这段代码。 JSP动作元素 标签库啥的的调用。 jsp:useBean用于在JSP文件使用指定名称的JavaBean对象。例如在JSP页面会话中调用Test.UserInfo类，对象名为ui，则语句是&lt;jsp:useBean id=&quot;ui&quot; class=&quot;Test.UserInfo&quot; scope=&quot;session&quot; type=&quot;...&quot;/&gt;。 jsp:setProperty设置JavaBean对象成员的值；用jsp:getProperty获取JavaBean对象成员的值。 jsp:forward从当前页面转至其它JSP页面处理（请求转发）。jsp:include包含页面，但与上面的include指令不同，这里不是插入jsp代码，而是在运行后插入这段代码的应答。在转发或包含时，使用jsp:param传递参数。 jsp的内置对象 application对象将信息保存在服务器中，直到服务器关闭。application对象中保存的信息在整个应用中有效。 session对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为Key-value。session对象的value可以为复杂的对象类型，而不仅仅局限于字符串类型。内置对象session通过setAttribute()函数把数据以key-value形式写入保存，通过getAttribute()函数把保存的数据读取出来。JSP页面使用Session内置对象时，需要在JSP文件头部用&lt;%@page session=&quot;true&quot; %&gt;把Session属性设置为true。 request对象是javax.servlet.httpServletRequest类型的对象，代表客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。作用域为一次请求。 response对象代表对客户端的响应，将JSP容器处理过的对象传回到客户端。response对象只在JSP页面内有效。 page对象代表JSP本身，只在JSP页面内合法。类似于Java中的this。 pageContext对象的作用是取得任何范围的参数，通过它可以获取JSP页面的out、request、reponse、session、application等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用pageContext对象。 out对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。。 config对象的主要作用是取得服务器的配置信息。通过pageConext对象的getServletConfig()方法可以获取一个config对象。 exception对象的作用是显示异常信息，在包含isErrorPage=&quot;true&quot;的页面中可以被使用。 JavaBean JavaBean是一种仅包含数据属性和对数据进行存取的函数的类。 外部包 JSP文件用到外部（第三方）JAR包时，应在web项目的web-inf目录下建立lib目录，把jar包复制到web项目/web-inf目录/lib目录。","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"JSP","slug":"表世界/JSP","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://mechanicalmind.cn/tags/JSP/"}]},{"title":"编译原理・肆・语义分析","slug":"编译原理/编译原理・肆・语义分析","date":"2019-12-11T12:58:14.000Z","updated":"2019-12-11T12:58:14.000Z","comments":true,"path":"2019/12/11/编译原理/编译原理・肆・语义分析/","link":"","permalink":"http://mechanicalmind.cn/2019/12/11/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%83%BB%E8%82%86%E3%83%BB%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/","excerpt":"","text":"属性文法 1E-&gt; TR&#123;R.in:&#x3D;T.val;E.val&#x3D;R.val&#125;2R-&gt; +TR&#39;&#123;R&#39;.in:&#x3D;R.in+T.val;R.val:&#x3D;R&#39;.val&#125;3R-&gt; -TR&#39;&#123;R&#39;.in:&#x3D;R.in-T.val;R.val:&#x3D;R&#39;.val&#125;4R-&gt; epsilon&#123;R.val:&#x3D;R.in&#125;5T-&gt; num&#123;T.val:&#x3D;lexval(num)&#125; 翻译模式 1E-&gt; T&#123;R.in:&#x3D;T.val&#125;R&#123;E.val&#x3D;R.val&#125;2R-&gt; +T&#123;R&#39;.in:&#x3D;R.in+T.val&#125;R&#39;&#123;R.val:&#x3D;R&#39;.val&#125;3R-&gt; -T&#123;R&#39;.in:&#x3D;R.in-T.val&#125;R&#39;&#123;R.val:&#x3D;R&#39;.val&#125;4R-&gt; epsilon&#123;R.val:&#x3D;R.in&#125;5T-&gt; num&#123;T.val:&#x3D;lexval(num)&#125; 1void ParseE()2&#123;3 Tval=ParseT();4 Rval=ParseR(Tval);5 Print(Rval);6&#125;78int ParseR(int in)9&#123;10 if(lookahead=='+')11 &#123;12 MatchToken('+');13 Tval=ParseT();14 Rval=ParseR(in+Tval);15 return Rval;16 &#125;17 else if(lookahead=='-')18 &#123;19 MatchToken('-');20 Tval=ParseT();21 Rval=ParseR(in-Tval);22 return Rval;23 &#125;24 else25 &#123;26 Rval=in;27 return Rval;28 &#125;29&#125;3031int ParseT()32&#123;33 if(lookahead=='num')34 return num;35 else36 error();37&#125; 属性文法/翻译模式的左递归消除 四元式的生成 有C片段如下: 1a=x,b=y,c=1;2while(b&gt;0)3&#123;4 if(b%2==1)c=c*a;5 b=b/2;6 a=a*a;7&#125; 要获得它的四元式代码，首先将具有复杂含义的语句展开: 1 a=x;2 b=y;3 c=1;4begin:5 if b&lt;=0 goto end;6 if b%2 != 1 goto nxt;7 c=c*a;8nxt:9 b=b/2;10 a=a*a;11 goto begin;12end: 容易得到四元式： 101 &#x3D; ,x,&#x2F;,a202 &#x3D; ,y,&#x2F;,b303 &#x3D; ,1,&#x2F;,c404 &lt;&#x3D;,b,0,11505 % ,b,2,t606 !&#x3D;,t,1,8707 * ,c,a,c808 &#x2F; ,b,2,b909 * ,a,a,a1010 go,&#x2F;,&#x2F;,4","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/"},{"name":"编译原理","slug":"深蓝/编译原理","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://mechanicalmind.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"编译原理・贰・自顶向下语法分析","slug":"编译原理/编译原理・贰・自顶向下语法分析","date":"2019-12-11T12:58:14.000Z","updated":"2019-12-11T12:58:14.000Z","comments":true,"path":"2019/12/11/编译原理/编译原理・贰・自顶向下语法分析/","link":"","permalink":"http://mechanicalmind.cn/2019/12/11/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%83%BB%E8%B4%B0%E3%83%BB%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/"},{"name":"编译原理","slug":"深蓝/编译原理","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://mechanicalmind.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"编译原理・贰・词法分析","slug":"编译原理/编译原理・壹・词法分析","date":"2019-12-10T12:58:14.000Z","updated":"2019-12-10T12:58:14.000Z","comments":true,"path":"2019/12/10/编译原理/编译原理・壹・词法分析/","link":"","permalink":"http://mechanicalmind.cn/2019/12/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%83%BB%E5%A3%B9%E3%83%BB%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/"},{"name":"编译原理","slug":"深蓝/编译原理","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://mechanicalmind.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"编译原理・〇・总论","slug":"编译原理/编译原理・〇・总论","date":"2019-12-10T11:46:15.000Z","updated":"2019-12-10T11:46:15.000Z","comments":true,"path":"2019/12/10/编译原理/编译原理・〇・总论/","link":"","permalink":"http://mechanicalmind.cn/2019/12/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%83%BB%E3%80%87%E3%83%BB%E6%80%BB%E8%AE%BA/","excerpt":"编译程序的基本组成与相关概念。","text":"编译程序的基本组成与相关概念。 编译程序的功能 把高级语言翻译为等价的低级语言。 编译程序的组成 编译程序接受一个字符流的源程序的输入。 字符流送词法分析模块进行词法分析。词法分析模块将从左至右扫描字符流，由词法规则识别出最小的语法单位即单词，将其转换为编译程序内部的符号表示，得到单词流。 单词流送送语法分析模块进行语法分析。语法分析模块由语法规则识别语法结构，生成一种语法的内部表示，如语法树、三元组或四元组等。同时检查语法正确性。 前面得到的语法结构送语义分析模块和中间代码生成模块进行语义分析与综合，进行静态语法检查、变量类型的确定与检查等，并生成中间代码。 以上模块称为编译程序的前端。 中间代码送中间代码优化模块，得到优化后的中间代码。 以上模块为中端。 优化后的中间代码送目标代码生成模块和目标代码优化模块，生成目标代码。 以上模块为后端。 除以上模块外，还有符号表管理模块，全程收集每个名字的各种属性；错误处理模块，负责报告错误并尝试从错误中恢复。 “遍” 编译程序中有个叫“遍”或者“趟”（passes或phases）的概念，指从头到尾扫描一遍某种代码形式，并将之转换到另一代码空间（包含代码和一些额外信息如符号表等）。 “遍”的概念使程序结构更清楚，把哪些功能做成一个遍之类。一个编译程序的结构组织取决于其对各“遍”的组织，例如是单遍还是多遍？多个遍是顺序执行（通常如此）还是并发执行？ 编译程序的伙伴程序 预处理程序 将宏定义（#define）、支持文件（#include）等替换为更复杂的源程序扩展信息。 汇编程序 将编译程序给出的汇编代码转换为可重定位的机器语言程序。 装入和连接程序 为可重定位的机器语言程序装载执行时库，生成可执行程序。 编译程序的相关程序 高级语言分编译型和解释性，后者对应解释程序。编译程序读入源程序，输出目标程序，目标程序读入程序输入，输出结果。而解释程序读入源程序和程序输入，输出结果。它不产生目标程序文件、翻译一句执行一句，执行时解释程序依旧在守护，也就是不区分翻译与执行。常用于虚拟机。 文法 文法G[S]是一个四元组(非终结符集合,终结符集合,重写规则集合,属于非终结符集合的识别符号S)。 使用文法产生语言 一串字汇集（非终结符集合并终结符集合）符号由重写规则进行重写的过程叫推导。 由识别符能推导出来的符号串叫句型。如果这里的符号都是终结符，就叫句子。 一个文法描述的语言为其推导出的句子集合。两文法等价当且仅当其能推导出的句子集合相等。 给定一个文法，则可唯一地确定其语言；给定一语言，可不唯一地确定其文法。 使用其它方式描述语言 正则表达式之类的方法。 文法和语言的分类——Chomsky语言分类法 0型语言：没什么要求，基本是个文法生成的都是。等价于图灵机。 1型语言：在0型语言的基础上，其文法之任一产生式之右部式长度有限。等价于线性有界自动机。 2型语言：在1型语言的基础上，其文法之任一产生式之左部式仅有一非终结符。这意味着规约一个非终结符时无需考虑它前后是啥玩意，称为上下文无关文法。等价于下推自动机。 3型语言：在2型语言的基础上，所有产生式均形如A-&gt;aB|a或所有产生式均形如A-&gt;Ba|a，等价于有限状态自动机。 推导与语法树 最左或最右推导（每次推导均队最左或最右的非终结符应用重写规则）生成的句型叫最左或最右句型。反过来有最左最右规约。最早被研究的是最右推导，所以规范推导指的是这玩意；分析程序时都是从左往右读所以是先规约左边，所以规范规约指的是这玩意。 不管你咋推导，只要得到了同一个句子，那语法树就应该是一样的，否则说明这个句子有二义性，生成这个句子的文法就叫二义性文法。 不能仅根据文法本身判断它是否有二义性。 句型分析与语法树 给定一个符号串，判断它是否是某个文法的句型，这个过程叫句型分析。 一般有两种技术： 自顶向下：从识别符号出发，尝试推导出相同的符号串。问题在于，同一个左部符号可能有多个产生式，推导的时候该应用哪个？ 自底向上：从输入串出发，尝试规约到识别符号。问题在于，同样的右部串可能可以规约到多个左部符号，规约到哪个？ 对一棵语法树，每一棵子树（与数据结构上不同，这里叶子不算子树）的叶子构成的串叫一个短语，这意味着它们能被规约到这棵子树的根的符号。只有一层的子树的叶子构成的串叫简单短语，这意味着一次规约就能把它规约到根的符号。最左的简单短语叫句柄，规范规约中将首先被规约。","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/"},{"name":"编译原理","slug":"深蓝/编译原理","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://mechanicalmind.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"Manjaro Linux下配置DosBox+MASM汇编环境","slug":"戏法/Manjaro-Linux下配置DosBox-MASM汇编环境","date":"2019-11-24T08:14:56.000Z","updated":"2019-12-08T16:00:00.000Z","comments":true,"path":"2019/11/24/戏法/Manjaro-Linux下配置DosBox-MASM汇编环境/","link":"","permalink":"http://mechanicalmind.cn/2019/11/24/%E6%88%8F%E6%B3%95/Manjaro-Linux%E4%B8%8B%E9%85%8D%E7%BD%AEDosBox-MASM%E6%B1%87%E7%BC%96%E7%8E%AF%E5%A2%83/","excerpt":"坑待填","text":"坑待填 sudo pacman -S dosbox mount c ~/Workspaces/MASM MASM5.0，更高的版本需要Win行命令提示符环境才能运行 masm hw.asm 文件名长度不能超过8 link hw hw","categories":[{"name":"戏法","slug":"戏法","permalink":"http://mechanicalmind.cn/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://mechanicalmind.cn/tags/%E6%B1%87%E7%BC%96/"},{"name":"DosBox","slug":"DosBox","permalink":"http://mechanicalmind.cn/tags/DosBox/"},{"name":"MASM","slug":"MASM","permalink":"http://mechanicalmind.cn/tags/MASM/"}]},{"title":"Manjaro Linux下使用opencv_traincascade","slug":"Manjaro-Linux下使用opencv-traincascade","date":"2019-11-18T08:34:19.000Z","updated":"2019-11-17T16:00:00.000Z","comments":true,"path":"2019/11/18/Manjaro-Linux下使用opencv-traincascade/","link":"","permalink":"http://mechanicalmind.cn/2019/11/18/Manjaro-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8opencv-traincascade/","excerpt":"使用opencv_traincascade训练实现车辆检测。","text":"使用opencv_traincascade训练实现车辆检测。 OpenCV中有个神奇的AdaBoost，通过读入一个xml即可识别出目标区域。此物中文名唤“级联分类器”，“级联”指它由简单分类器级联组成，通过所有分类器的区域即为目标区域。训练时通过对样本的一定操作可生成样本的Haar/LBP/HOG等特征，检测时遍历待识别图片各区域进行特征匹配。 训练 文件准备 训练文件夹的结构应当如下： data（训练结果文件夹） vec（样本集文件夹） bg（背景集文件夹） vec.bat（样本集相关信息） vec.vec（样本集相关信息） bg.txt（背景集相关信息） opencv_createsamples（生成pos.vec的工具） opencv_traincascade（训练的工具） 其中这些东西的名字都可以变。 首先建立训练文件夹和三个子文件夹，并分别放入样本集图片和背景集图片。样本的大小大约应当几十见方，太大会爆栈；背景应当远大于训练图片，几百见方，且内容较复杂。这是因为程序将训练图片作为滑动窗口在背景上滑动来采集训练图像，如果无法采集到足够多的样本就会报Train dataset for temp stage can not be filled. Branch training terminated.错误。 关于样本集与背景集的比例，有帖子认为一比三是比较合适的，我理解是生活中没有样本的情况（背景）多于有样本，但如果给太多背景影响训练效率。 放好后在训练文件夹下进入终端，ls ./bg/&gt;bg.txt生成背景集相关信息，ls ./vec/&gt;vec.bat生成样本集相关信息。自动生成的文件最后有个空行需要删掉。有帖子指出这里的文件对换行格式也有要求，实测VSCode中的“LF”格式没问题。 此时生成的两个文件内应当是形如： 1xxx.xxx2xxx.xxx 将之改为： 1vec&#x2F;xxx.xxx2vec&#x2F;xxx.xxx 和 1bg&#x2F;xxx.xxx2bg&#x2F;xxx.xxx 这是因为待会调用训练程序时无法指定图片地址，所以地址要在这两个文件中显式指出。 除此之外，还要指出样本图片（背景不需要）的该样本数目、起始坐标和表示样本宽高 1vec&#x2F;xxx.xxx 1 0 0 xx xx2vec&#x2F;xxx.xxx 1 0 0 xx xx 那两个工具在电脑里查找一下，通过anaconda装的就是在anaconda文件夹里某个角落，复制过去即可。 创建样本 ./opencv_createsamples -vec vec.vec -info vec.bat -bg bg.txt -w xx -h xx 注意图片尺寸要对，否则报Error: Assertion failed (_img.rows * _img.cols == vecSize)。 这里的工具是直接拉过来用的，配套环境可能跟不上。如果报错他想找个啥库找不到之类，以libopencv_core.so.3.2为例： Find the folder containing the shared library libopencv_core.so.3.2using the following command line. 1&gt;sudo find &#x2F; -name&quot;libopencv_core.so.3.2*&quot; Then I got the result: /usr/local/&gt;lib/libopencv_core.so.3.2. Create a file called /etc/ld.so.conf.d/opencv.conf and write to it the path to the folder where the binary is stored.For example, I wrote /usr/local/lib/ to my opencv.conf file. Run the command line as follows. 1sudo ldconfig -v Try to run the test binary again. 生成vec.vec就是好了。 可能需要给工具一个执行权限。 训练 ./opencv_traincascade -data data -vec vec.vec -bg bg.txt -numPos xxx -numNeg xxx -numStages 20 -w xx -h xx -minHitRate 0.9999 -maxFalseAlarmRate 0.5 -mode ALL，其中numPos和numNeg是每次训练使用的样本数量，而非你提供了多少样本。这个数量应当足够多（样本数应当大于10，否则报Cascade classifier can’t be trained. Check the used training parameters.），和提供的数量一样保持一比三，并且少于提供的样本数（否则报Traincascade Error:Bad argument(Can not get new positive sample.The most possible reason is insufficient count of samples in given vec-file.）；numStage是训练的级数，默认为20；minHitRate指“分类器的每一级希望得到最小检测率”，一般0.9999；maxFalseAlarmRate，最大虚警率，“影响弱分类器的阈值，表示每个弱分类器将负样本误分为正样本的比例”，一般默认值为0.5。还有其它贼多参数，用到再去查吧。 官方给的numPos和numNeg计算方法是vec-file number &gt;= (numPos + (numStages-1) * (1 – minHitRate) * numPos) + S。vec-file number是指提供的样本数。 训练过程中经常报Train dataset for temp stage can not be filled. Branch training terminated.，排除背景信息那个文本文档格式问题的话就是需要更多更大更复杂的背景的意思。 检测 1xx = cv2.CascadeClassifier(&lt;xml路径&gt;)2xxx = xx.detectMultiScale(&lt;图片&gt;, scaleFactor=1.1, minNeighbors=55, minSize=(10, 10),maxSize=(90,90),flags=cv2.CASCADE_SCALE_IMAGE) scaleFactor指每次检测区域扩大多少，1.1就是每次扩大百分之十；minNeighbors大概意思是一个目标区域附近允许有多少目标区域——因为往往对同一个目标，程序会识别出许多临近的目标区域，看情况调调这个参数留一个就行。","categories":[{"name":"中医","slug":"中医","permalink":"http://mechanicalmind.cn/categories/%E4%B8%AD%E5%8C%BB/"},{"name":"分类器","slug":"中医/分类器","permalink":"http://mechanicalmind.cn/categories/%E4%B8%AD%E5%8C%BB/%E5%88%86%E7%B1%BB%E5%99%A8/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://mechanicalmind.cn/tags/OpenCV/"},{"name":"AdaBoost","slug":"AdaBoost","permalink":"http://mechanicalmind.cn/tags/AdaBoost/"},{"name":"cascade","slug":"cascade","permalink":"http://mechanicalmind.cn/tags/cascade/"}]},{"title":"操作系统・贰・存储器管理","slug":"操作系统/操作系统・贰・存储器管理","date":"2019-11-11T07:35:40.000Z","updated":"2019-11-10T16:00:00.000Z","comments":true,"path":"2019/11/11/操作系统/操作系统・贰・存储器管理/","link":"","permalink":"http://mechanicalmind.cn/2019/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%83%BB%E8%B4%B0%E3%83%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/","excerpt":"坑待填","text":"坑待填 1 +-----------------------+ +-----------------------+2 |1 2 3 4 1 2 5 1 2 3 4 5| |1 2 3 4 1 2 5 1 2 3 4 5|3++----------------------++ ++----------------------++4|1|1|1|4|4|4|5| | |5|5| | |1|1|1|1| | |5|5|5|5|4|4|5| |2|2|2|1|1|1| | |3|3| | | |2|2|2| | |2|1|1|1|1|5|6| | |3|3|3|2|2| | |2|4| | | | |3|3| | |3|3|2|2|2|2|7+-----------------------+ | | | |4| | |4|4|4|3|3|3|8 1 2 3 4 5 6 +-----------------------+9 1 2 3 4 5 61011 +-----------------------+ +-----------------------+12 |1 2 3 4 1 2 5 1 2 3 4 5| |1 2 3 4 1 2 5 1 2 3 4 5|13++----------------------++ ++----------------------++14|1|1|1|4|4|4|5| | |3|3|3| |1|1|1|1| | |1| | |1|1|5|15| |2|2|2|1|1|1| | |1|4|4| | |2|2|2| | |2| | |2|2|2|16| | |3|3|3|2|2| | |2|2|5| | | |3|3| | |5| | |5|4|4|17+-----------------------+ | | | |4| | |4| | |3|3|3|18 1 2 3 4 5 6 7 +-----------------------+19 1 2 3 42021 +-----------------------------------------------------------------+22 |5 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 5 0 1 |23+-+---------------------------------------------------------+-------+24|51|51|51|21| |20|01|00|21| |20|31|21|20| |01| |00| | |25| |01|01|00| |31|31|30|30| |01|01|00|11| |11| |10| | |26| | |11|10| |10|10|41|41| |41|41|40|40| |40| |51| | |27+-----------------------------------------------------------+28 1 2 3 4 5 6 7 8 9 10 11","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/"},{"name":"操作系统","slug":"深蓝/操作系统","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://mechanicalmind.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"编译原理・终・实验","slug":"编译原理/编译原理・终・实验","date":"2019-11-10T12:58:14.000Z","updated":"2019-12-10T12:58:14.000Z","comments":true,"path":"2019/11/10/编译原理/编译原理・终・实验/","link":"","permalink":"http://mechanicalmind.cn/2019/11/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%83%BB%E7%BB%88%E3%83%BB%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"目标 给定一个简单的玩具语言，由C语言小子集构成，为它设计一个编译器，完成词法分析、语法分析、语义分析等功能，并生成汇编语言。 使用的文法规则 词法规则 \\(&lt;ID&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; &lt;ID&gt;&lt;LETTER&gt; \\\\ &amp; &lt;ID&gt;&lt;DIGIT&gt; \\\\ &amp; &lt;LETTER&gt; \\end{aligned} \\right.\\) \\(&lt;NUM&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; &lt;DIGIT&gt; \\\\ &amp; &lt;NUM&gt;&lt;DIGIT&gt; \\end{aligned} \\right.\\) \\(&lt;LETTER&gt;\\rightarrow a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z\\) \\(&lt;DIGIT&gt;\\rightarrow 0|1|2|3|4|5|6|7|8|9\\) \\(&lt;PLUS\\_MINUS&gt;\\rightarrow +|-\\) \\(&lt;STAR\\_DIV&gt;\\rightarrow *|/\\) \\(&lt;RELOP&gt;\\rightarrow &lt;|&gt;|!=|&gt;=|&lt;=|==\\) \\(&lt;DELIMITER&gt;\\rightarrow ,|;|(|)|\\{|\\}\\) \\(&lt;KEY&gt;\\rightarrow main|int|if|else|whileDo|do\\) 语法规则 \\(&lt;Program&gt;\\rightarrow main() \\left\\{ &lt;CompSt&gt; \\right\\}\\) CompSt：由一对花括号括起来的语句块。该语句块内部先是一系列的变量定义DefList，然后是一系列的语句StmtList。 \\(&lt;CompSt&gt;\\rightarrow &lt;Def&gt;;&lt;StmtList&gt;\\) Def：变量定义部分，由于选择的子集里只有int一种变量类型，所以不需要DefList，一条变量定义语句足矣。 \\(&lt;Def&gt;\\rightarrow &lt;Specifier&gt;&lt;IdList&gt;\\) IdList：一个或多个标识符ID \\(&lt;Specifier&gt;\\rightarrow INT\\) \\(&lt;IdList&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; &lt;IdList&gt;,ID \\\\ &amp; ID \\end{aligned} \\right.\\) \\(&lt;StmtList&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp;&lt;StmtList&gt;,&lt;Stmt&gt; \\\\ &amp;&lt;Stmt&gt; \\end{aligned} \\right.\\) \\(&lt;Stmt&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; &lt;Assign&gt; \\\\ &amp; &lt;IfElse&gt; \\\\ &amp; &lt;WhileDo&gt; \\end{aligned} \\right.\\) 一条语句，可以是一个以分号结尾的表达式，或一个条件语句，或一个循环语句，或一个返回语句。这里不考虑返回语句的情况，并且表达式只考虑简单的Id = Exp;的情况即赋值语句、条件语句只考虑if (条件) 语句（块） else 语句（块）的情况、循环语句只考虑while (条件) 语句（块） do 语句（块）的情况。 \\(&lt;Assign&gt;\\rightarrow ID=&lt;Exp&gt;\\) \\(&lt;Exp&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; &lt;Exp&gt;&lt;PLUS\\_MINUS&gt;&lt;Term&gt;\\\\ &amp; &lt;Term&gt; \\\\ \\end{aligned} \\right.\\) \\(&lt;Term&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; &lt;Term&gt;&lt;STAR\\_DIV&gt;&lt;Divisor&gt;\\\\ &amp; &lt;Divisor&gt; \\\\ \\end{aligned} \\right.\\) \\(&lt;Divisor&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; ID \\\\ &amp; NUM \\\\ &amp; (&lt;Exp&gt;) \\end{aligned} \\right.\\) \\(&lt;IfElse&gt;\\rightarrow if(&lt;Condition&gt;)&lt;Inner&gt;else&lt;Inner&gt;\\) \\(&lt;Condition&gt;\\rightarrow &lt;Exp&gt;RELOP&lt;Exp&gt;\\) \\(&lt;Inner&gt;\\rightarrow &lt;Stmt&gt;|{&lt;StmtList&gt;}\\) \\(&lt;WhileDo&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; while(&lt;Condition&gt;)do&lt;Inner&gt;\\\\ &amp; while(&lt;Condition&gt;)&lt;Inner&gt; \\end{aligned} \\right.\\) 可以看出，“C--”的语法规则类似C，但右花括号前的分号在右花括号外，且最外的右花括号后无分号。声明语句必须放在最前面。由于这个玩具语言只支持int，所以声明语句只需要一句，而且不需要进行各种类型检查；也没有数组、函数、结构体等概念。 由于它很简单，使用这个语言编写的的程序能出的错也比较少，编译器大致只需要能够查出源代码中可能包含的下述几类错误: 词法错误 词法中未定义的字符 不符合词法单元定义的字符 语法错误 任何不符合规则的语法 语义错误 变量在使用时未经定义 变量出现重复定义 变量在使用时未经初始化 对给定文法规则的分析 消除左递归 4、5、8、9四条规则是存在左递归的，在自顶向下的分析中左递归将导致死循环。可以容易地消除左递归： 第4条： \\(&lt;IdList&gt;\\rightarrow ID&lt;IdList&#39;&gt;\\) \\(&lt;IdList&#39;&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; ,ID&lt;IdList&#39;&gt; \\\\ &amp; \\epsilon \\end{aligned} \\right.\\) 第5条： \\(&lt;StmtList&gt;\\rightarrow &lt;Stmt&gt;&lt;StmtList&#39;&gt;\\) \\(&lt;StmtList&#39;&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; ;&lt;Stmt&gt;&lt;StmtList&#39;&gt; \\\\ &amp; \\epsilon \\end{aligned} \\right.\\) 第8条： \\(&lt;Exp&gt;\\rightarrow &lt;Term&gt;&lt;Exp&#39;&gt;\\) \\(&lt;Exp&#39;&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; &lt;PLUS\\_MINUS&gt;&lt;Term&gt;&lt;Exp&#39;&gt; \\\\ &amp; \\epsilon \\end{aligned} \\right.\\) 第9条： \\(&lt;Term&gt;\\rightarrow &lt;Divisor&gt;&lt;Term&#39;&gt;\\) \\(&lt;Term&#39;&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; &lt;STAR\\_DIV&gt;&lt;Divisor&gt;&lt;Term&#39;&gt; \\\\ &amp; \\epsilon \\end{aligned} \\right.\\) 拓展属性文法 声明语句需要扩展属性文法以生成符号表，网络上教属性文法的文章通常以此举例，可以容易地找到参考： \\(&lt;Def&gt;\\rightarrow &lt;Specifier&gt;&lt;IdList&gt;\\{&lt;IdList&gt;.inh:=&lt;Specifier&gt;.type\\}\\) 将类型声明指定的类型赋给所有后面的标识符。 \\(&lt;Specifier&gt;\\rightarrow INT \\{&lt;Specifier&gt;.type:=integer\\}\\) 返回类型声明指定的类型为int。 \\(&lt;IdList&gt;\\rightarrow ID\\{addType(ID.entry,&lt;IdList&gt;.inh)\\}&lt;IdList&#39;&gt;\\{&lt;IdList&#39;&gt;.inh:=&lt;IdList&gt;.inh\\}\\) 传入指定的类型，将ID入表，ID后的所有标识符类型将为前面传来的类型。 \\(&lt;IdList&#39;&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; ,ID\\{addType(ID.entry,&lt;IdList&#39;&gt;.inh)\\}&lt;IdList_1&#39;&gt;\\{&lt;IdList_1&#39;&gt;.inh:=&lt;IdList&#39;&gt;.inh\\} \\\\ &amp; \\epsilon \\end{aligned} \\right.\\) 传入指定的类型，将ID入表，ID后的所有标识符类型将为前面传来的类型；如果是空就不管。 注意，这里可能出现重复声明的错误。 赋值语句和表达式处也需要扩展属性文法以生成四元式。这个有点复杂，头秃。以表达式\\(a+b\\times c\\)为例，最先被规约的除了\\(\\epsilon\\)外就是\\(\\times c\\)了。想生成四元式，这里需要传入（也就是\\(&lt;Term’&gt;\\)的继承属性）\\(b\\)，并生成一个变量（也就是\\(&lt;Term’&gt;\\)的综合属性）用于存储结果。将生成的变量——例如是\\(tmp\\)——返回后再规约\\(+tmp\\)，过程类似。 1 +------------------------------+Exp+---------------------------------+2 | |3 v v4 +----+Term+---+ +-------------------+--------------------------+Exp&#39;+-----------------+5 | | | | |6 v v v v v7Divisor Term&#39; + +------+Term+-------------------+ Exp&#39;8 | | | | |9 v v v v v10 a epsilon Divisor +---------------+Term&#39;+---------------+ epsilon11 | | | |12 v v v v13 b * Divisior Term&#39;14 | |15 v v16 c epsilon \\(&lt;Assign&gt;\\rightarrow ID=&lt;Exp&gt;\\{queue.push(&quot;=&quot;,&lt;Exp&gt;.val,N/A,ID)\\}\\) \\(&lt;Exp&gt;\\)将返回一个符号，生成赋值四元式入队列。 \\(&lt;Exp&gt;\\rightarrow &lt;Term&gt;&lt;Exp&#39;&gt;\\{&lt;Exp&#39;&gt;.inh=&lt;Term&gt;.val;&lt;Exp&gt;.val=&lt;Exp&#39;&gt;.val\\}\\) 把\\(&lt;Term&gt;\\)的返回符号传入\\(&lt;Exp&#39;&gt;\\)，\\(&lt;Exp&#39;&gt;\\)将返回一个符号，将之返回。 \\(&lt;Exp&#39;&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; &lt;PLUS\\_MINUS&gt;&lt;Term&gt;&lt;Exp1&#39;&gt;\\{&lt;Exp1&#39;&gt;.inh=&lt;Term&gt;.val;queue.push(&lt;PLUS\\_MINUS&gt;,&lt;Exp&#39;&gt;.inh,&lt;Exp1&#39;&gt;.val,tmp);&lt;Exp&#39;&gt;.val=tmp\\} \\\\ &amp; \\epsilon\\{&lt;Exp&#39;&gt;.val=&lt;Exp&#39;&gt;.inh\\} \\end{aligned} \\right.\\) 传入一个符号，并把\\(&lt;Term&gt;\\)的返回符号传入\\(&lt;Exp1&#39;&gt;\\)，\\(&lt;Exp1&#39;&gt;\\)将返回一个符号，将传入的符号与\\(&lt;Exp1&#39;&gt;\\)返回的符号做加减运算，四元式入队列，结果存在\\(tmp_i\\)，将\\(tmp_i\\)返回；但若\\(&lt;Exp&#39;&gt;\\)为空，则直接将传入的符号返回。 \\(&lt;Term&gt;\\rightarrow &lt;Divisor&gt;&lt;Term&#39;&gt;\\{&lt;Term&#39;&gt;.inh=&lt;Divisor&gt;.val;&lt;Term&gt;.val=&lt;Term&#39;&gt;.val\\}\\) 把\\(&lt;Divisor&gt;\\)的返回符号传入\\(&lt;Term&#39;&gt;\\)，\\(&lt;Term&#39;&gt;\\)将返回一个符号，将之返回。 \\(&lt;Term&#39;&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; &lt;STAR\\_DIV&gt;&lt;Divisor&gt;&lt;Term1&#39;&gt;\\{&lt;Term1&#39;&gt;.inh=&lt;Divisor&gt;.val;queue.push(&lt;STAR\\_DIV&gt;,&lt;Term&#39;&gt;.inh,&lt;Term1&#39;&gt;.val,tmp);&lt;Term&#39;&gt;.val=tmp\\} \\\\ &amp; \\epsilon\\{&lt;Term&#39;&gt;.val=&lt;Term&#39;&gt;.inh\\} \\end{aligned} \\right.\\) 传入一个符号，并把\\(&lt;Divisor&gt;\\)的返回符号传入\\(&lt;Term1&#39;&gt;\\)，\\(&lt;Term1&#39;&gt;\\)将返回一个符号，将传入的符号与\\(&lt;Term1&#39;&gt;\\)返回的符号做乘除运算，四元式入队列，结果存在\\(tmp_i\\)，将\\(tmp_i\\)返回；但若\\(&lt;Term&#39;&gt;\\)为空，则直接将传入的符号返回。 \\(&lt;Divisor&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; ID \\{&lt;Divisor&gt;.val=ID\\}\\\\ &amp; NUM \\{&lt;Divisor&gt;.val=NUM\\}\\\\ &amp; (&lt;Exp&gt;) \\end{aligned} \\right.\\) 返回一个符号，这个符号可能是ID，或NUM，或一个\\(&lt;Exp&gt;\\)的返回符号。 注意，这里可能出现使用未经定义的变量的错误。 条件语句和循环语句的四元式难点是怎么确定要跳转的位置我感觉，需要在分析到要跳转的地方后再回过头去修改最初跳转语句的目标位置为当前位置。 \\(&lt;IfElse&gt;\\rightarrow if(&lt;Condition&gt;)\\{queue.push(GO,&lt;Condition&gt;.val==false,N/A,else)\\}&lt;Inner&gt;\\{queue.push(GO,N/A,N/A,end)\\}else&lt;Inner&gt;\\) 条件表达式将返回一个布尔变量，如果为真则执行完第一个条件体后跳转至结尾，如果为假则跳转至else的标号。 \\(&lt;Condition&gt;\\rightarrow &lt;Exp1&gt;\\{&lt;Condition&gt;.exp1val=&lt;Exp1&gt;.val\\}RELOP&lt;Exp2&gt;\\{&lt;Condition&gt;.exp2val=&lt;Exp2&gt;.val\\,queue.ppush(RELOP,&lt;Condition&gt;.exp1val,&lt;Condition&gt;.exp2val,tmp_i);&lt;Condition&gt;.val=tmp_i\\}\\) 将两个表达式返回的符号做给定的比较运算，结果存在一个新符号中，入四元式并返回。 \\(&lt;WhileDo&gt;\\rightarrow \\left\\{ \\begin{aligned} &amp; while(&lt;Condition&gt;)do&lt;Inner&gt;\\\\ &amp; while(&lt;Condition&gt;)&lt;Inner&gt; \\end{aligned} \\right.\\) 类似条件语句，只不过跳转回去的时候要跳到判断那里，属性文法懒得写了：） 之后按平时作业的编程题正常写即可。要求具有一定排错能力，这个比较难。哪天想起来再补充吧。","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/"},{"name":"编译原理","slug":"深蓝/编译原理","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://mechanicalmind.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"Struts2中Action的几种传值方式","slug":"表世界/Struts2/Struts2中Action的几种传值方式","date":"2019-11-07T12:09:33.000Z","updated":"2019-11-07T12:09:33.000Z","comments":true,"path":"2019/11/07/表世界/Struts2/Struts2中Action的几种传值方式/","link":"","permalink":"http://mechanicalmind.cn/2019/11/07/%E8%A1%A8%E4%B8%96%E7%95%8C/Struts2/Struts2%E4%B8%ADAction%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/","excerpt":"struts2中，传统的servlet中的request和response传递参数法仍可使用（但略有不同），并且增加了船新的传值方式。","text":"struts2中，传统的servlet中的request和response传递参数法仍可使用（但略有不同），并且增加了船新的传值方式。 0. 环境 Tomcat 9.0 MyEclipse 2017 ci10 Struts 2.5.20 Manjaro Linux 18.1.0 JDK 1.8u221 1. request/response 为避免与Servlet API耦合在一起，方便Action类做单元测试，Struts2对HttpServletRequest、HttpSession、ServletContext进行了封装，构造了三个Map对象来替代这三种对象。注意，这三个对象与Servlet API中的三个对象是相同的，即，在Action中放入Session中信息，在JSP页面中是可以读出来的。 在Action类中引入上下文类ActionContext，使用getContext()实例化一个对象，就可以通过这个对象获取session和application的map对象，而ActionContext对象本身包含了request的map对象。 向它们中添加属性只需使用put()方法，若向request添加属性，只需向ActionContext对象中添加。 2. get/set 之前带有传值的示例就是用的这种方式。在action类中定义与jsp页面中上传参数的东西同名的私有成员变量并生成get/set方法即可直接使用，贼方便。 这种方法的进阶版是传JavaBean——而不是一个个传数据。也非常简单，唯一需要注意的是jsp页面中上传参数的东西的name必须是&lt;JavaBean的名字&gt;.名字。 3. 示例 一个学生登录的界面。用户在index.jsp填写表单，提交后跳转至欢迎界面，在欢迎界面显示输入的信息。 3.1. index.jsp 1&lt;body&gt;2 &lt;h1&gt;使用JavaBean传递参数：&lt;/h1&gt;3 &lt;form action=\"transJB\"&gt;4 &lt;label for=\"stud.id\"&gt;学号&lt;/label&gt;5 &lt;input type=\"text\" name=\"stud.id\"&gt;6 &lt;br/&gt;7 &lt;label for=\"stud.name\"&gt;姓名&lt;/label&gt;8 &lt;input type=\"text\" name=\"stud.name\"/&gt;9 &lt;br/&gt;10 &lt;label for=\"stud.school\"&gt;学院&lt;/label&gt;11 &lt;input type=\"text\" name=\"stud.school\"/&gt;12 &lt;br/&gt;13 &lt;label for=\"stud.pw\"&gt;口令&lt;/label&gt;14 &lt;input type=\"password\" name=\"stud.pw\"/&gt;15 &lt;br/&gt;16 &lt;label for=\"stud.mail\"&gt;邮箱&lt;/label&gt;17 &lt;input type=\"text\" name=\"stud.mail\"/&gt;18 &lt;br/&gt;19 &lt;input type=\"submit\" value=\"登录\"/&gt;20 &lt;/form&gt;21 &lt;h1&gt;使用HttpServletRequest传递参数：&lt;/h1&gt;22 &lt;form action=\"transSERVLET\"&gt;23 &lt;label for=\"id\"&gt;学号&lt;/label&gt;24 &lt;input type=\"text\" name=\"id\"&gt;25 &lt;br/&gt;26 &lt;label for=\"name\"&gt;姓名&lt;/label&gt;27 &lt;input type=\"text\" name=\"name\"/&gt;28 &lt;br/&gt;29 &lt;label for=\"school\"&gt;学院&lt;/label&gt;30 &lt;input type=\"text\" name=\"school\"/&gt;31 &lt;br/&gt;32 &lt;label for=\"pw\"&gt;口令&lt;/label&gt;33 &lt;input type=\"password\" name=\"pw\"/&gt;34 &lt;br/&gt;35 &lt;label for=\"mail\"&gt;邮箱&lt;/label&gt;36 &lt;input type=\"text\" name=\"mail\"/&gt;37 &lt;br/&gt;38 &lt;input type=\"submit\" value=\"登录\"/&gt;39 &lt;/form&gt;40&lt;/body&gt; 3.2. struts.xml 1&lt;package name=\"TransTestPkg\" extends=\"struts-default\"&gt;2 &lt;action name=\"transJB\" class=\"transTest.JBtrans\" method=\"execute\"&gt;3 &lt;result name=\"success\"&gt;/succJB.jsp&lt;/result&gt;4 &lt;/action&gt;5 &lt;action name=\"transSERVLET\" class=\"transTest.SERVLETtrans\" method=\"execute\"&gt;6 &lt;result name=\"success\"&gt;/succSERVLET.jsp&lt;/result&gt;7 &lt;/action&gt;8&lt;/package&gt; 3.3. transTest 3.3.1. SERVLETtrans.java 1package transTest;23import java.util.Map;4import javax.servlet.http.HttpServletRequest;5import com.opensymphony.xwork2.ActionContext;6import org.apache.struts2.ServletActionContext; 78public class SERVLETtrans&#123;9 public String execute()&#123;10 ActionContext ctx=ActionContext.getContext();11 HttpServletRequest request = (HttpServletRequest) ctx.get(ServletActionContext.HTTP_REQUEST);12 Map&lt;String,Object&gt; application=ctx.getApplication();1314 String id=request.getParameter(\"id\");15 String name = request.getParameter(\"name\");16 String school = request.getParameter(\"school\");17 String pw = request.getParameter(\"pw\");18 String mail = request.getParameter(\"mail\");1920 System.out.println(\"id: \" + id);21 System.out.println(\"name: \" + name);22 System.out.println(\"school: \" + school);23 System.out.println(\"pw: \" + pw);24 System.out.println(\"mail: \" + mail);25 26 application.put(\"id\",id);27 application.put(\"name\",name);28 application.put(\"school\",school);29 application.put(\"pw\",pw);30 application.put(\"mail\",mail);31 32 return \"success\";33 &#125;34&#125; 3.3.2. JBtrans.java 1package transTest;2import com.opensymphony.xwork2.ActionSupport;3import transTest.StudentBean;45public class JBtrans extends ActionSupport &#123;6 /**7 * 8 */9 private static final long serialVersionUID = 1L;10 11 private StudentBean stud;12 public StudentBean getStud() &#123;13 return stud;14 &#125;15 public void setStud(StudentBean stud) &#123;16 this.stud = stud;17 &#125;18 19 //public StudentBean stud = new StudentBean();20 21 public String execute()&#123;22 /*System.out.println(stud.getName());23 System.out.println(stud.getSchool());24 System.out.println(stud.getPw());25 System.out.println(stud.getMail());26 System.out.println(stud.getId());*/27 return \"success\";28 &#125;29&#125; 3.3.3. StudentBean.java 1package transTest;23public class StudentBean &#123;4 public String name,id,school,pw,mail;5 public String getName() &#123;6 return name;7 &#125;8 public void setName(String name) &#123;9 this.name = name;10 &#125;11 public String getId() &#123;12 return id;13 &#125;14 public void setId(String id) &#123;15 this.id = id;16 &#125;17 public String getSchool() &#123;18 return school;19 &#125;20 public void setSchool(String school) &#123;21 this.school = school;22 &#125;23 public String getPw() &#123;24 return pw;25 &#125;26 public void setPw(String pw) &#123;27 this.pw = pw;28 &#125;29 public String getMail() &#123;30 return mail;31 &#125;32 public void setMail(String mail) &#123;33 this.mail = mail;34 &#125;35&#125; 3.4. succJB和succSERVLET.jsp 1jb:2&lt;body&gt;3 &lt;h1&gt;欢迎你，学号&lt;s:property value=\"stud.id\"/&gt;，&lt;s:property value=\"stud.school\"/&gt;学院的&lt;s:property value=\"stud.name\"/&gt;同学！&lt;/h1&gt;4 &lt;p&gt;你登记的邮箱是&lt;s:property value=\"stud.mail\"/&gt;，口令是&lt;s:property value=\"stud.pw\"/&gt;。&lt;/p&gt;5&lt;/body&gt;67servlet:8&lt;body&gt;9 &lt;h1&gt;欢迎你，学号$&#123;applicationScope.id&#125;，$&#123;applicationScope.school&#125;学院的$&#123;applicationScope.name&#125;同学！&lt;/h1&gt;10 &lt;p&gt;你登记的邮箱是$&#123;applicationScope.mail&#125;，口令是$&#123;applicationScope.pw&#125;。&lt;/p&gt;11&lt;/body&gt;","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"Struts2","slug":"表世界/Struts2","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/Struts2/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://mechanicalmind.cn/tags/JSP/"},{"name":"Struts2","slug":"Struts2","permalink":"http://mechanicalmind.cn/tags/Struts2/"}]},{"title":"Struts2中Action的几种Result","slug":"表世界/Struts2/Struts2中Action的几种Result","date":"2019-11-02T08:53:30.000Z","updated":"2019-11-02T08:53:30.000Z","comments":true,"path":"2019/11/02/表世界/Struts2/Struts2中Action的几种Result/","link":"","permalink":"http://mechanicalmind.cn/2019/11/02/%E8%A1%A8%E4%B8%96%E7%95%8C/Struts2/Struts2%E4%B8%ADAction%E7%9A%84%E5%87%A0%E7%A7%8DResult/","excerpt":"action跳转至页面、URL或另一个action。","text":"action跳转至页面、URL或另一个action。 Struts中调用Action后应当获得一个Result。它告诉Struts接下来该干啥。它的属性可以是以下类型： dispatcher：请求转发，用于整合JSP的结果类型。 redirect：请求重定向。值为一个请求URL。 redirect-action：请求重定向到action。值为定义的action的name。 plaintext：用于显示某个页面的源代码。 还有好多种不会的…… 0. 环境 Tomcat 9.0 MyEclipse 2017 ci10 Struts 2.5.20 Manjaro Linux 18.1.0 JDK 1.8u221 1. dispatcher 如果在result标签中没有指定type，则默认是dispatcher类型。此时它指定一个视图资源——通常是JSP页面。 2. redirect 使用该type的action重定向到一个页面，另一个action或一个网址。 3. redirect-action 使用该type的action使用ActionMapperFactory提供的ActionMapper来重定向请求到另外一个action。与redirect相比，在使用上没有什么区别。 4. 测试 4.1. struts.xml中的packge 1&lt;package name=\"ActionTestPkg\" extends=\"struts-default\"&gt; 2 &lt;action name=\"action2JSP\" class=\"actionTest.JSPaction\" method=\"execute\"&gt;3 &lt;result name=\"success\"&gt;/succ.jsp&lt;/result&gt;4 &lt;result name=\"failed\"&gt;/fail.jsp&lt;/result&gt;5 &lt;/action&gt;6 &lt;action name=\"action2URL\" class=\"actionTest.URLaction\" method=\"execute\"&gt;7 &lt;result name=\"success\" type=\"redirect\"&gt;http://www.bing.com&lt;/result&gt;8 &lt;/action&gt;9 &lt;action name=\"action2ACT\" class=\"actionTest.ACTaction\" method=\"execute\"&gt;10 &lt;result name=\"success\" type=\"redirectAction\"&gt;action2URL&lt;/result&gt;11 &lt;/action&gt;12&lt;/package&gt; 4.2. actionTest包 4.2.1. JSPaction类 1package actionTest;23public class JSPaction &#123;4 private String text;5 6 public void setText(String text) &#123;7 System.out.println(\"JSPaction set text:\"+this.text);8 this.text = text;9 &#125;10 public String getText() &#123;11 System.out.println(\"JSPaction get text:\"+text);12 return text;13 &#125;14 15 public String execute() throws Exception &#123;16 if(\"hello world\".equals(this.text))&#123;17 System.out.println(\"JSPaction execute success.\");18 return \"success\";19 &#125;20 else &#123;21 System.out.println(\"JSPaction execute failed.\");22 return \"failed\";23 &#125;24 &#125;25&#125; 4.2.2. URLaction类 1package actionTest;23public class URLaction &#123;4 public String execute() throws Exception &#123;5 System.out.println(\"URLaction execute success.\");6 return \"success\";7 &#125;8&#125; 4.2.3. ACTaction类 1package actionTest;23public class ACTaction &#123;4 public String execute() throws Exception &#123;5 System.out.println(\"ACTaction return success.\");6 return \"success\";7 &#125;8&#125; 4.3. JSP页面 4.3.1. index 1&lt;form action=\"action2JSP\"&gt;2 &lt;label for=\"text\"&gt;Please enter hello world&lt;/label&gt;3 &lt;br/&gt;4 &lt;input type=\"text\" name=\"text\"/&gt;5 &lt;br/&gt;6 &lt;input type=\"submit\" value=\"call JSP action\"/&gt;7&lt;/form&gt;8&lt;form action=\"action2URL\"&gt;9 &lt;input type=\"submit\" value=\"call URL action\"/&gt;10&lt;/form&gt;11&lt;form action=\"action2ACT\"&gt;12 &lt;input type=\"submit\" value=\"call ACT action\"/&gt;13&lt;/form&gt; 4.3.2. succ和fail 1&lt;p&gt;success或者fial:get &lt;s:property value=\"text\"/&gt; .&lt;/p&gt; 5. 带参数的重定向 5.1. redirect&quot; 1&lt;result name=\"success\" type=\"redirect\"&gt;/login.do?userId=$&#123;userId &#125;&lt;/result&gt; 5.2. redirect-action&quot;： 1&lt;result name=\"success\" type=\"redirect-action\"&gt; 2 &lt;param name=\"actionName\"&gt;login.do&lt;/param&gt; 重定向action名3 &lt;param name=\"userId\"&gt;userId&lt;/param&gt;带的参数4&lt;/result&gt;","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"Struts2","slug":"表世界/Struts2","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/Struts2/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://mechanicalmind.cn/tags/JSP/"},{"name":"Struts2","slug":"Struts2","permalink":"http://mechanicalmind.cn/tags/Struts2/"}]},{"title":"编译原理・叁・自底向上语法分析","slug":"编译原理/编译原理・叁・自底向上语法分析","date":"2019-10-28T11:54:06.000Z","updated":"2019-12-08T16:00:00.000Z","comments":true,"path":"2019/10/28/编译原理/编译原理・叁・自底向上语法分析/","link":"","permalink":"http://mechanicalmind.cn/2019/10/28/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%83%BB%E5%8F%81%E3%83%BB%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"优先分析法和LR(0)、SLR(1)、LR(1)三种LR分析法。","text":"优先分析法和LR(0)、SLR(1)、LR(1)三种LR分析法。 概述 基本思想 从输入符号串出发，在每一分析步对相应句型中的某个简单短语进行归约。如果最终能归约到识别符号，则该输入符号串是相应文法的句子，否则就不是。 基本问题 （假设句型分析过程中每个分析步都对最左的简单短语进行直接归约）如何找出句柄及把此句柄直接归约为哪个非终结符号。 基本思路 找出句柄\\(u\\) 找出规则\\(U\\rightarrow u\\) 把\\(u\\)直接归约成\\(U\\) 基本概念 活前缀:右句型（最右推导可得到的句型）的前缀（如abc的前缀为a、ab、abc），而且其右端不会超过该句型的最右边句柄（句柄是和某个产生式右部匹配的字符串，可以把句柄归约成产生式左部的非终结符）的末端。 举例，设有文法\\(G[E]\\)： \\[ E\\rightarrow E+E|E\\times E \\] \\(E+E\\times E\\)归约成\\(E+E\\)，句柄是\\(E\\times E\\)，那么它的活前缀就是\\(E\\)、\\(E+\\)、\\(E+E\\)、\\(E+E\\times\\)、\\(E+E\\times E\\)。 这里又可以分为两种情况： 归态活前缀： 活前缀的尾部正好是句柄之尾，这时可以进行规约，规约之后又成为另一句型的活前缀。 非归态活前缀：句柄尚未形成，需继续移入若干符号之后才能形成句柄。 自底向上优先分析 简单优先分析法 如果可以确定所有符号的优先级，则只需按优先级顺序规约（当一个符号优先级高于它后面的符号时，向前匹配一个产生式右部进行规约）即可。如果一个文法其任意两个符号间最多只有一种优先关系成立并且所有产生式的右部均不相同，则这么做是可行的，这种文法称为简单优先文法。这种分析方式有时用在表达式的分析上，大部分时候不实用。 算符优先分析法 如果只确定终结符之间的关系，则可大大提高适用性，但这时的规约不再是规范的。想通过终结符规约，需要所有产生式右部均没有相邻的非终结符（满足此条件称为算符文法）且任一对终结符之间仅有大于、小于或等于一种优先关系存在（满足此条件称为算符优先文法）。 如果两个终结符出现在了同一个产生式右部，称他俩优先级相等，写作\\(a\\doteq b\\)（点在中间，不会打，下面所有符号同）。 有类似\\(A\\to \\dots aB\\ldots\\)的产生式且有\\(B\\Rightarrow^{+} \\Rightarrow Cb\\ldots\\)（\\(C\\)可以为空）的\\(a\\)和\\(b\\)，这种要规约的话肯定是先把含\\(b\\)的式子规约到\\(B\\)再规约\\(a\\)，所以称为\\(a\\)的优先级小于\\(b\\)，写作\\(a\\dot&lt; b\\)。 有类似\\(A\\to \\dots Bb\\ldots\\)的产生式且有\\(B\\Rightarrow^{+} \\Rightarrow \\ldots aC\\)（\\(C\\)可以为空）的\\(a\\)和\\(b\\)，这种要规约的话肯定是先把含\\(a\\)的式子规约到\\(B\\)再规约\\(b\\)，所以称为\\(a\\)的优先级大于\\(b\\)，写作\\(a\\dot&gt; b\\)。 以\\(G[S]\\)为例： \\[ \\begin{aligned} &amp; S\\rightarrow S;G|G\\\\ &amp; G\\rightarrow G(T)|H\\\\ &amp; H\\rightarrow a|(S)\\\\ &amp; T\\rightarrow T+S|S \\end{aligned} \\] 判断\\(\\doteq\\)关系，只需硬看产生式。这里可知\\((\\doteq )\\)和隐式的\\(\\# \\doteq \\#\\)。 判断\\(\\dot&lt;\\)关系，需先找到所有终结符后跟非终结符的情况，有\\(;G\\)、\\((T\\)、\\((S\\)、\\(+S\\)和隐式的\\(\\#S\\)、\\(\\#G\\)。这几个关系中，在前面的终结符的优先级小于后面的非终结符的\\(FirstV_t\\)中元素，这里指的是产生式中的第一个终结符，而非可能产生的句子中的第一个终结符，与First集略有不同。 \\[ \\begin{aligned} &amp;FirstV_t(S)=\\{;\\}+FirstV_t(G)=\\{;\\}+\\{(\\}+FirstV_t(H)=\\{;\\}+\\{(\\}+\\{a,(\\}=\\{;,a,(\\}\\\\ &amp;FirstV_t(G)=\\{a,(\\}\\\\ &amp;FirstV_t(H)=\\{a,(\\}\\\\ &amp;FirstV_t(T)=\\{+\\}+FirstV_t(S)=\\{+,;,a,(\\} \\end{aligned} \\] 故: \\(;G\\)有\\(;\\dot&lt; FirstV_t(G)\\)； \\((T\\)有\\((\\dot&lt; FirstV_t(T)\\)； \\((S\\)有\\((\\dot&lt; FirstV_t(S)\\)； \\(+S\\)有\\(+\\dot&lt; FirstV_t(S)\\)； \\(\\#S\\)有\\(\\#\\dot&lt; FirstV_t(S)\\)； \\(\\#G\\)有\\(\\#\\dot&lt; FirstV_t(G)\\)。 判断\\(\\dot&gt;\\)关系，需先找到所有非终结符后跟终结符的情况，有\\(S;\\)、\\(G(\\)、\\(T)\\)、\\(S)\\)、\\(T+\\)和隐式的\\(G\\#\\)。这几个关系中，在前面的非终结符的\\(LastV_t\\)集中元素优先级大于后面的终结符，这里指的是产生式中的最后一个终结符，而非可能产生的句子中的第一个终结符，与Last集略有不同。 \\[ \\begin{aligned} &amp;LastV_t(S)=\\{;\\}+LastV_t(G)=\\{;\\}+\\{)\\}+LastV_t(H)=\\{;\\}+\\{)\\}+\\{a,)\\}=\\{;,a,)\\}\\\\ &amp;LastV_t(G)=\\{a,)\\}\\\\ &amp;LastV_t(H)=\\{a,)\\}\\\\ &amp;LastV_t(T)=\\{+\\}+LastV_t(S)=\\{+,;,a,)\\} \\end{aligned} \\] 故: \\(S;\\)有\\(LastV_t(S)\\dot&gt;;\\)； \\(G(\\)有\\(LastV_t(G)\\dot&gt;(\\)； \\(T)\\)有\\(LastV_t(T)\\dot&gt;)\\)； \\(S)\\)有\\(LastV_t(S)\\dot&gt;)\\)； \\(G\\#\\)有\\(LastV_t(G)\\dot&gt;\\#\\)； \\(T+\\)有\\(LastV_t(T)\\dot&gt;+\\)； 将这些关系构建为一张表： ; ( ) + a # ; \\(\\dot&gt;\\) \\(\\dot&lt;\\) \\(\\dot&gt;\\) \\(\\dot&gt;\\) \\(\\dot&lt;\\) ( \\(\\dot&lt;\\) \\(\\dot&lt;\\) \\(\\doteq\\) \\(\\dot&lt;\\) \\(\\dot&lt;\\) ) \\(\\dot&gt;\\) \\(\\dot&gt;\\) \\(\\dot&gt;\\) \\(\\dot&gt;\\) \\(\\dot&gt;\\) + \\(\\dot&lt;\\) \\(\\dot&lt;\\) \\(\\dot&gt;\\) \\(\\dot&lt;\\) a \\(\\dot&gt;\\) \\(\\dot&gt;\\) \\(\\dot&gt;\\) \\(\\dot&gt;\\) \\(\\dot&gt;\\) # \\(\\dot&lt;\\) \\(\\dot&lt;\\) \\(\\dot&lt;\\) 没有冲突，该文法是算符优先文法。 引入最左素短语概念以确定算符优先分析的句柄，素短语是一个包含终结符的短语，且不包含除自身外的其它素短语。最左素短语就是最左的没啥好说的。可以看出，我们可以通过每次规约最左素短语进行规约。在算符优先文法的输入串中，如果一个终结符的优先级大于它两边的终结符的优先级，则它（和它两边的非终结符，如果有）是素短语。故对于算符优先文法的输入串，每次规约最左的、优先级比两边的终结符大的终结符即可，例如a;(a+a)之于上面的文法： 步骤 句型 优先关系 最左素短语 规约 1 #a;(a+a)# #&lt;a&gt;;&lt;(&lt;a&gt;+&lt;a&gt;)&gt;# a H 2 #H;(a+a)# #&lt;;&lt;(&lt;a&gt;+&lt;a&gt;)&gt;# a H 3 #H;(H+a)# #&lt;;&lt;(&lt;+&lt;a&gt;)&gt;# a H 4 #H;(H+H)# #&lt;;&lt;(&lt;+&gt;)&gt;# T+S T 5 #H;(T)# #&lt;;&lt;(=)&gt;# (T) S 这一步把(T)规约到S。这里只要求形式相同，具体非终结符是哪个并不关心。 步骤 句型 优先关系 最左素短语 规约 6 #H;S# #&lt;;&gt;# H;S S 7 #S# 虽然接受了，但该字符串其实不是文法的句子。毕竟它不是规范的，难免。因此只适合表达式的分析。 LR分析 概述 LR(K)分析器包括总控程序和分析表。 总控程序根据不同的分析表决定下一步的处理动作。不同文法的总控程序相同，只是分析表不同。 分析表是LR(K)分析技术的核心，根据具体文法按某种规则构造，由分析动作表和转换表构成。 分析动作表ACTION[S,y]指明当状态S与向前看符号串y相匹配时所应采取的动作。包括：移进、归约、接受、出错 。 状态转换表GOTO[S,U]指明当状态S与非终结符号U相匹配时所转换到的下一状态。 分析过程 将初始状态S0与#压进分析栈 根据栈顶状态和当前输入符号查动作表进行以下工作 移进(Si)：当前输入符号进符号栈,新的状态进状态栈,继续扫描. 归约(rj)：按某规则归约,若规则的右部长度n,则符号栈顶和状态栈顶n个元素同时退栈. 把归约后的左部符号进符号栈,查状态转换表,新的状态进状态栈. 接受(acc): 分析成功,结束. 出错(空白): 报告出错信息. 重复(1),直到接受或出错为止. LR(0)分析 设有文法\\(G[S]\\)： \\[ \\begin{aligned} &amp;(1)S\\rightarrow A\\\\ &amp;(2)S\\rightarrow B\\\\ &amp;(3)A\\rightarrow aAb\\\\ &amp;(4)A\\rightarrow c\\\\ &amp;(5)B\\rightarrow aBb\\\\ &amp;(6)B\\rightarrow d\\\\ \\end{aligned} \\] 为了确保起始符号不出现在产生式右部，并显式地表示EOF，增加一个起始符号S'，得到增广文法\\(G&#39;[S&#39;]\\)： \\[ \\begin{aligned} &amp;(0)S&#39;\\rightarrow S\\#\\\\ &amp;(1)S\\rightarrow A\\\\ &amp;(2)S\\rightarrow B\\\\ &amp;(3)A\\rightarrow aAb\\\\ &amp;(4)A\\rightarrow c\\\\ &amp;(5)B\\rightarrow aBb\\\\ &amp;(6)B\\rightarrow d\\\\ \\end{aligned} \\] 并引入一个“・”记号，这个记号之前的部分为已经读入（并且匹配）的部分，之后的部分为期望为读入的部分匹配的部分。为了便于识别，手写时将点记号写作“\\(\\Delta\\)”。 为了得到想要的两个表，需要先构建这个文法的自动机。 首先看起始状态，现在面对一个未知的串，期望其匹配G'，也就是未读入的部分匹配\\(S\\#\\)。将现在的状态称为\\(S_0\\)，也就是： 状态 项目 后继符号 后继状态 \\(S_0\\) \\(S&#39;\\rightarrow \\Delta S\\) \\(S\\) 既然期待\\(S\\)，那左部符号为\\(S\\)的产生式也可以被期待。加进去，就变成： 状态 项目 后继符号 后继状态 \\(S_0\\) \\(S&#39;\\rightarrow \\Delta S\\) \\(S\\) \\(S_0\\) \\(S\\rightarrow \\Delta A\\) \\(A\\) \\(S_0\\) \\(S\\rightarrow \\Delta B\\) \\(B\\) 同理，都期待\\(A\\)和\\(B\\)了，那左部符号为\\(A\\)和\\(B\\)的产生式也可以被期待： 状态 项目 后继符号 后继状态 \\(S_0\\) \\(S&#39;\\rightarrow \\Delta S\\) \\(S\\) \\(S_0\\) \\(S\\rightarrow \\Delta A\\) \\(A\\) \\(S_0\\) \\(S\\rightarrow \\Delta B\\) \\(B\\) \\(S_0\\) \\(A\\rightarrow \\Delta aAb\\) \\(a\\) \\(S_0\\) \\(A\\rightarrow \\Delta c\\) \\(c\\) \\(S_0\\) \\(B\\rightarrow \\Delta aBb\\) \\(a\\) \\(S_0\\) \\(B\\rightarrow \\Delta d\\) \\(d\\) 现在假设对每个项目，真的都读到了它的后继符号，那将进入新的状态。给它们起名字： 状态 项目 后继符号 后继状态 \\(S_0\\) \\(S&#39;\\rightarrow \\Delta S\\) \\(S\\) \\(S_1\\) \\(S_0\\) \\(S\\rightarrow \\Delta A\\) \\(A\\) \\(S_2\\) \\(S_0\\) \\(S\\rightarrow \\Delta B\\) \\(B\\) \\(S_3\\) \\(S_0\\) \\(A\\rightarrow \\Delta aAb\\) \\(a\\) \\(S_4\\) \\(S_0\\) \\(A\\rightarrow \\Delta c\\) \\(c\\) \\(S_5\\) \\(S_0\\) \\(B\\rightarrow \\Delta aBb\\) \\(a\\) \\(S_4\\) \\(S_0\\) \\(B\\rightarrow \\Delta d\\) \\(d\\) \\(S_6\\) 对于两个后继为\\(a\\)的，由于其都是“第一个读到\\(a\\)”的情况，所以对应的下一个状态是相同的。 现在考虑\\(S_1\\)。现在已经读入了\\(S\\)（或者不能叫读入了，因为\\(S\\)并不是一个终结符，不过意思是这么个意思……），所以\\(\\Delta\\)要放在\\(S\\)后面，那就是后面没有没有待匹配的东西了，这时进行规约： 状态 项目 后继符号 后继状态 \\(S_1\\) \\(S&#39;\\rightarrow S\\Delta\\) \\(\\#S&#39;\\rightarrow S\\) END \\(S_2\\)和\\(S_3\\)同理： 状态 项目 后继符号 后继状态 \\(S_2\\) \\(S\\rightarrow A\\Delta\\) \\(\\#S\\rightarrow A\\) END \\(S_3\\) \\(S\\rightarrow B\\Delta\\) \\(\\#S\\rightarrow B\\) END 对\\(S_4\\)，已经读入了\\(a\\)，对于\\(A\\rightarrow aAb\\)，期望看到\\(A\\)；对于\\(B\\rightarrow aBb\\)，期望看到\\(B\\)，所以左部符号为\\(A\\)和\\(B\\)的产生式也可以被期待——注意此时的\\(\\Delta\\)在右部式的最左，而不是\\(a\\)后，因为这个期待的\\(A\\)或\\(B\\)还没被读取： 状态 项目 后继符号 后继状态 \\(S_4\\) \\(A\\rightarrow a\\Delta Ab\\) \\(A\\) \\(S_7\\) \\(S_4\\) \\(B\\rightarrow a\\Delta Bb\\) \\(B\\) \\(S_8\\) \\(S_4\\) \\(A\\rightarrow \\Delta aAb\\) \\(a\\) \\(S_4\\) \\(S_4\\) \\(A\\rightarrow \\Delta c\\) \\(c\\) \\(S_5\\) \\(S_4\\) \\(B\\rightarrow \\Delta aBb\\) \\(a\\) \\(S_4\\) \\(S_4\\) \\(B\\rightarrow \\Delta d\\) \\(d\\) \\(S_6\\) 这里头两个项目时已经读入了\\(a\\)，期待\\(A\\)或\\(B\\)，是新状态；之后的是已有的状态。 对于\\(S_5\\)和\\(S_6\\)，当读到期待的符号后后面就没了，期待EOF： 状态 项目 后继符号 后继状态 \\(S_5\\) \\(A\\rightarrow c\\Delta\\) \\(\\#A\\rightarrow c\\) END \\(S_6\\) \\(B\\rightarrow d\\Delta\\) \\(\\#B\\rightarrow d\\) END 对于\\(S_7\\)和\\(S_8\\)，当读到期待的符号后再后还有得读，又多了两种状态： 状态 项目 后继符号 后继状态 \\(S_7\\) \\(A\\rightarrow aA\\Delta b\\) \\(b\\) \\(S_9\\) \\(S_8\\) \\(B\\rightarrow aB\\Delta b\\) \\(b\\) \\(S_{10}\\) 对于\\(S_9\\)和\\(S_10\\)，当读到期待的符号后期待EOF： 状态 项目 后继符号 后继状态 \\(S_9\\) \\(A\\rightarrow aAb\\Delta\\) \\(\\#A\\rightarrow aAb\\) END \\(S_10\\) \\(B\\rightarrow aBb\\Delta\\) \\(\\#B\\rightarrow aBb\\) END 这样所有的状态都分析完了。整合一下这个表，就是： 状态 项目集 后继符号 后继状态 \\(S_0\\) \\(\\{\\\\S&#39; \\rightarrow \\Delta S\\\\S\\rightarrow \\Delta A\\\\S\\rightarrow \\Delta B\\\\A\\rightarrow \\Delta aAb\\\\A\\rightarrow \\Delta c\\\\B\\rightarrow \\Delta aBb\\\\B\\rightarrow \\Delta d\\\\\\}\\) \\(S\\\\A\\\\B\\\\a\\\\c\\\\a\\\\d\\) \\(S_1\\\\S_2\\\\S_3\\\\S_4\\\\S_5\\\\S_4\\\\S_6\\) \\(S_1\\) \\(\\{\\\\S&#39;\\rightarrow S\\Delta\\\\\\}\\) \\(\\#S&#39;\\rightarrow S\\) END \\(S_2\\) \\(\\{\\\\S\\rightarrow A\\Delta\\\\\\}\\) \\(\\#S\\rightarrow A\\) END \\(S_3\\) \\(\\{\\\\S\\rightarrow B\\Delta\\\\\\}\\) \\(\\#S\\rightarrow B\\) END \\(S_4\\) \\(\\{\\\\A\\rightarrow a\\Delta Ab\\\\B\\rightarrow a\\Delta Bb\\\\A\\rightarrow \\Delta aAb\\\\A\\rightarrow \\Delta c\\\\B\\rightarrow \\Delta aBb\\\\B\\rightarrow \\Delta d\\\\\\}\\) \\(A\\\\B\\\\a\\\\c\\\\a\\\\d\\) \\(S_7\\\\S_8\\\\S_4\\\\S_5\\\\S_4\\\\S_6\\) \\(S_5\\) \\(\\{\\\\A\\rightarrow c\\Delta\\\\\\}\\) \\(\\#A\\rightarrow c\\) END \\(S_6\\) \\(\\{\\\\B\\rightarrow d\\Delta\\\\\\}\\) \\(\\#B\\rightarrow d\\) END \\(S_7\\) \\(\\{\\\\A\\rightarrow aA\\Delta b\\\\\\}\\) \\(b\\) \\(S_9\\) \\(S_8\\) \\(\\{\\\\B\\rightarrow aB\\Delta b\\\\\\}\\) \\(b\\) \\(S_10\\) \\(S_9\\) \\(\\{\\\\A\\rightarrow aAb\\Delta\\\\\\}\\) \\(\\#A\\rightarrow aAb\\) END \\(S_{10}\\) \\(\\{\\\\B\\rightarrow aBb\\Delta\\\\\\}\\) \\(\\#B\\rightarrow aBb\\) END END 这样就获得了这个文法的自动机。为了方便程序查找在啥状态下读到啥时该做啥，需要构建分析表。 当位于状态\\(S_0\\)时，下一位可能的符号有\\(a\\)，\\(b\\)，\\(c\\)，\\(d\\)和\\(\\#\\)。由自动机知此时下一位若为\\(a\\)，\\(c\\)，\\(d\\)是符合规则的。因此若下一位是\\(a\\)则移进（shift）一位（就是把\\(S_0,a\\)入分析栈，读入的指针右移一位）并转换到到\\(S_4\\)，\\(c\\)则\\(S_5\\)，\\(d\\)则\\(S_6\\)。 状态 \\(a\\) \\(b\\) \\(c\\) \\(d\\) \\(\\#\\) \\(S_0\\) s4 s5 s6 也就是从这样： 1+-----------------+ +----------------------------------+2|status |symble | |...a... |3+-----------------+ +---^------------------------------+4| | | |5| | | |6| | | +7| | |8+-----------------+9|S0 |x |10+-----------------+11|... |... |12+-----------------+13|S0 |# |14+-----------------+ 变成这样： 1+-----------------+ +----------------------------------+2|status |symble | |...a... |3+-----------------+ +----^-----------------------------+4| | | |5| | | |6| | | +7| | |8+-----------------+9|S4 |a |10+-----------------+11|S0 |x |12+-----------------+13|... |... |14+-----------------+15|S0 |# |16+-----------------+ 当位于状态\\(S_1\\)时，如果遇到\\(\\#\\)就是分析完了，称之为“acc(ept)”，其它情况不符合自动机。 状态 \\(a\\) \\(b\\) \\(c\\) \\(d\\) \\(\\#\\) \\(S_1\\) acc 当位于状态\\(S_2\\)时，栈中的内容是\\(A\\)，要进行规约（reduce）。 根据\\(S_2\\)的规则，也就是规则1，\\(A\\)规约后将变成\\(S\\)。所以在表里填上“r1”表示根据规则1规约，并弹出被规约的内容，这里只有\\(S_2,A\\)，规约后得到的非终结符是使用的规则的左部符号，到达栈顶状态遇到这一符号的状态。 状态 \\(a\\) \\(b\\) \\(c\\) \\(d\\) \\(\\#\\) \\(S_2\\) r1 r1 r1 r1 r1 也就是由（这个例子中只有\\(S_0\\)后继符号是\\(S\\)，此时后继状态是\\(S_1\\)）： 1+-----------------+ +----------------------------------+2|status |symble | |....... |3+-----------------+ +---^------------------------------+4| | | |5| | | |6| | | +7+-----------------+8|S2 |A |9+-----------------+10|S0 |# |11+-----------------+ 变成： 1+-----------------+ +----------------------------------+2|status |symble | |....... |3+-----------------+ +---^------------------------------+4| | | |5| | | |6| | | +7+-----------------+8|S1 |S |9+-----------------+10|S0 |# |11+-----------------+ 为方便查找，还要再搞一个将状态与非终结符联系起来的表，为表区分，之前的称为“ACTION”表，后者称为“GOTO”表。 状态 \\(S\\) \\(A\\) \\(B\\) \\(S_0\\) 1 \\(S_3\\)同样是要规约，要从\\(B\\)规约到\\(S\\)也就是按规则2: 状态 \\(a\\) \\(b\\) \\(c\\) \\(d\\) \\(\\#\\) \\(S_3\\) r2 r2 r2 r2 r2 依此类推即可获得分析表。 这种分析方法的问题在于，一旦进入某个可以规约的状态，无论输入是什么都会规约。这可能导致错误的规约。 SLR(1)分析 对大部分文法，会出现移进与规约的冲突和规约与规约的冲突。 设有文法\\(G[S]\\)： \\[ \\begin{aligned} &amp;(1)S\\rightarrow A\\\\ &amp;(2)A\\rightarrow aAd\\\\ &amp;(3)A\\rightarrow aAb\\\\ &amp;(4)A\\rightarrow \\epsilon \\end{aligned} \\] 写为\\(G&#39;[S&#39;]\\)： \\[ \\begin{aligned} &amp;(0)S&#39;\\rightarrow S\\\\ &amp;(1)S\\rightarrow A\\\\ &amp;(2)A\\rightarrow aAd\\\\ &amp;(3)A\\rightarrow aAb\\\\ &amp;(4)A\\rightarrow \\epsilon \\end{aligned} \\] 构造自动机： 状态 项目集 后继符号 后继状态 \\(S_0\\) \\(\\{\\\\S\\rightarrow \\Delta A\\\\A\\rightarrow \\Delta aAd\\\\A\\rightarrow \\Delta aAb\\\\A\\rightarrow \\epsilon \\Delta \\\\\\}\\) \\(A\\\\a\\\\a\\\\\\#A\\rightarrow \\epsilon\\) \\(S_1\\\\S_2\\\\S_2\\\\END\\) 可以发现这里面既有移进项又有规约项。这种情况就说这个文法不是LR(0)的。如果一个文法的自动机同时存在不止一个规约项目，它也不是LR(0)的。 继续分析： 状态 项目集 后继符号 后继状态 \\(S_0\\) \\(\\{\\\\S&#39;\\rightarrow \\Delta S\\\\S\\rightarrow \\Delta A\\\\A\\rightarrow \\Delta aAd\\\\A\\rightarrow \\Delta aAb\\\\A\\rightarrow \\epsilon \\Delta \\\\\\}\\) \\(S\\\\A\\\\a\\\\a\\\\\\#A\\rightarrow \\epsilon\\) \\(1\\\\2\\\\3\\\\3\\\\END\\) \\(S_1\\) \\(\\{\\\\S&#39;\\rightarrow S\\Delta\\\\\\}\\) \\(\\#S&#39;\\rightarrow S\\) \\(END\\) \\(S_2\\) \\(\\{\\\\S\\rightarrow A\\Delta\\\\\\}\\) \\(\\#S\\rightarrow A\\) \\(END\\) \\(S_3\\) \\(\\{\\\\A\\rightarrow a\\Delta Ad\\\\A\\rightarrow a\\Delta Ab\\\\A\\rightarrow \\Delta aAd\\\\A\\rightarrow \\Delta aAb\\\\A\\rightarrow \\epsilon \\Delta\\\\\\}\\) \\(A\\\\A\\\\a\\\\a\\\\\\#A\\rightarrow \\epsilon\\) \\(4\\\\4\\\\3\\\\3\\\\END\\) \\(S_4\\) \\(\\{\\\\A\\rightarrow aA\\Delta d\\\\A\\rightarrow aA\\Delta b\\\\\\}\\) \\(d\\\\b\\) \\(5\\\\6\\) \\(S_5\\) \\(\\{\\\\A\\rightarrow aAd\\Delta\\\\\\}\\) \\(\\#A\\rightarrow aAd\\) \\(END\\) \\(S_6\\) \\(\\{\\\\A\\rightarrow aAb\\Delta\\\\\\}\\) \\(\\#A\\rightarrow aAb\\) \\(END\\) 除上述冲突外无其它冲突。冲突的\\(A\\)的Follow集和这里的两个\\(a\\)无交集，故可以根据这个进行判断是移进还是规约，这种叫SLR(1)文法，因为根据下一个输入字符即可判断执行什么操作。之所以是SLR而不是LR，是因为它仅在冲突时进行判断，不冲突时仍然是不管输入啥都规约。这导致有时仍然会错误地规约。一个项目集中有两个规约的情况类似，考察两个左部符号的Follow集，没有交集的话也OK。 类似LR(0)地可获得分析表。唯一区别就是有些地方状态既可能要移进也可能要规约，而不是要规约一整行都是规约： 状态 a b d # A S \\(S_0\\) s3 r4 r4 r4 2 1 \\(S_1\\) acc \\(S_2\\) r1 r1 r1 r1 \\(S_3\\) s3 r4 r4 r4 4 \\(S_4\\) s6 s5 \\(S_5\\) r2 r2 r2 r2 \\(S_6\\) r3 r3 r3 r3 以分析ab#为例，初始为： 1+-----------------+ +----------------------------------+2|status |symble | | ab# |3+-----------------+ +---^------------------------------+4| | | |5| | | |6| | | +7+-----------------+8|S0 |# |9+-----------------+ S0遇a，故入栈S3和a，指针后移： 1+-----------------+ +----------------------------------+2|status |symble | | ab# |3+-----------------+ +----^-----------------------------+4| | | |5| | | |6| | | +7+-----------------+8|S3 |a |9+-----------------+10|S0 |# |11+-----------------+ S3遇b，按规则(4)规约。规则(4)右部串长度为0，故弹出栈顶前0个元素。弹完栈顶是(S3,a)，规则(4)左部符号为A，故S3遇A，将S4和A入栈。 1+-----------------+ +----------------------------------+2|status |symble | | ab# |3+-----------------+ +----^-----------------------------+4| | | |5| | | |6| | | +7+-----------------+8|S4 |A |9+-----------------+10|S3 |a |11+-----------------+12|S0 |# |13+-----------------+ S4遇b，入栈S6和b，指针后移。 1+-----------------+ +----------------------------------+2|status |symble | | ab# |3+-----------------+ +-----^----------------------------+4| | | |5| | | |6| | | +7+-----------------+8|S6 |b |9+-----------------+10|S4 |A |11+-----------------+12|S3 |a |13+-----------------+14|S0 |# |15+-----------------+ S6遇#，按规则(3)规约。规则(3)右部串长度为3，故弹出栈顶三元素，弹出后栈顶为(S0,#)，规则(3)左部符号为A。S0遇A，入栈S2和A。 1+-----------------+ +----------------------------------+2|status |symble | | ab# |3+-----------------+ +-----^----------------------------+4| | | |5| | | |6| | | +7+-----------------+8|S2 |A |9+-----------------+10|S0 |# |11+-----------------+ S2遇#，按规则(1)规约，弹一对元素，S0遇S转S1，遇#，接受。 LR(1)分析 上面讲项目集规约与移进、规约与规约出现冲突时考察交集，那万一有呢？当时是通过比较Follow集，但Follow集只是个笼统的说法，一个非终结符的Follow集中的某个元素可能在某些句型中并不会出现。考虑在自动机的每一个产生式中标注其推导出的句型可能的后缀，当遇到可能遇到的后缀时才进行规约。这不止可以避免冲突，还可以避免误规约。","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/"},{"name":"编译原理","slug":"深蓝/编译原理","permalink":"http://mechanicalmind.cn/categories/%E6%B7%B1%E8%93%9D/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://mechanicalmind.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"语法分析","slug":"语法分析","permalink":"http://mechanicalmind.cn/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"在MyEclipse中使用Struts2框架","slug":"表世界/Struts2/在MyEclipse中使用Struts2框架","date":"2019-10-24T10:32:29.000Z","updated":"2019-10-24T10:32:29.000Z","comments":true,"path":"2019/10/24/表世界/Struts2/在MyEclipse中使用Struts2框架/","link":"","permalink":"http://mechanicalmind.cn/2019/10/24/%E8%A1%A8%E4%B8%96%E7%95%8C/Struts2/%E5%9C%A8MyEclipse%E4%B8%AD%E4%BD%BF%E7%94%A8Struts2%E6%A1%86%E6%9E%B6/","excerpt":"贼难配的环境。学委甚至到快结课才配好……","text":"贼难配的环境。学委甚至到快结课才配好…… CSDN——尤其是CSDN论坛，是好东西，也是坏东西。里面有许许多多大神分享有用的经验，但更多的是半吊子误人子弟，给出一些过时的、没用的建议。小白面对茫茫多的信息只能一边望洋兴叹，祈祷下一个看到的解决方案能稍微粘点边；一边对遇到的每行代码、每条命令追根究底，努力摆脱NOOB的身份。 0. 环境 Tomcat 9.0 MyEclipse 2017 ci10 Struts 2.5.20 Manjaro Linux 18.1.0 JDK 1.8u221 1. Struts2的下载 在http://struts.apache.org/download.cgi下载zip包struts-版本-min-lib.zip和struts-版本-all.zip。 前者包含的Struts2所必须的最少的包，后者包含了所有的包和例程。 2. 新建项目与导包 新建一个动态Web项目——有人说这里对动态Web项目的版本有要求需要2.5，实测没有——然后例如取名为“Struts2_HelloWorld”。先不急着完成，去下一步勾选“Generate Web.xml 啥啥啥”那一项和“Generate index.jsp 啥啥啥”（这个缺省是勾选的）。前者将在WEB-INF下创建一个Web.xml，Struts2请求需要先通过其中定义的过滤器。有人说这里需要将“WebRoot”修改为“WebContent”，实测两者均可，估计改其它名也没影响。 将前面下载的struts-版本-min-lib.zip中的包丢到WEB-INF/lib/，选中这些包（选中的是包而不是文件夹lib），右键构建路径。随后工作空间栏中项目根目录下将出现一个“Web应用程序库”，里面显示这些包。不要导入ALL版的lib，因为这些包有一些冲突，最简单的冲突原因例如如果两个包中有同样路径的类，此时某包先加载，则后加载的包中同名的类无法加载，导致一些函数无法找到等。网上很多人都介绍了最小需求包集合，但不少都与官方的有出入。 如果包导多了，由于已经建立了依赖所以无法直接删除。在工作目录视图中右击项目根文件夹，选构建路径，配置构建路径，这里显示了所有已导入的包，移除想删的——或者所有的也行，再移除整个Web应用程序库。然后可以在lib文件夹下删除包，再重新导入即可。 3. 编写Action 在src/新建一个类，例如包名为“helloWorld.action”，类名为“HelloWorld”。在自动生成的类中添加一个execute()： 1public String execute() throws Exception &#123;2 System.out.println(\"进入action。\");3 return \"success\";4&#125;5public String getText() &#123;6 System.out.println(\"赋值text。\");7 return \"Hello World !\";8&#125; 这里HelloWorld类并不需要继承什么东西，有execute()并返回一个String即可。这里希望执行action后跳转到的页面能够根据action的情况决定显示什么内容，而不是一个写死的jsp，所以加一个get函数，命名规则和JavaBean一样，跳转过去后struts2的s:property标签可以通过函数名找到这个函数从中获取值。多加一个println()便于判断是否成功进入action。 4. 编写页面 这个测试例程将有两个页面，一个是主页，一个是执行action后将要跳转到的页面。主页已经生成好了，为body添加一个按钮： 1&lt;form action=\"hello\"&gt;2 &lt;input type=\"submit\" value=\"Say Hello to the World!\"/&gt;3&lt;/form&gt; 用户按下这个按钮，将调用hello.action。 除此之外还需要在jsp第一行加上&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;，这句话指明了这个页面将使用struts2的标签，而且这些标签将在s之前。 另外再创建action将跳转到的页面，例如命名为helloworld.jsp，与index同样位于WebRoot/。 在body中添加&lt;h1&gt;&lt;s:property value=&quot;text&quot;/&gt;&lt;/h1&gt;，并在一开始添加&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;。 5. 添加配置文件 5.1. struts.xml struts.xml将URL、action类和jsp页面相关联。它规定了当收到某个URL请求时应当调用哪个类，并根据这个类的返回值决定跳转至哪个jsp页面。 可以从之前下载的struts-版本-all.zip中的apps/找一个例程，在其WEB-INF/classes/会有一个该文件。将该文件复制到项目的src/——或者什么其它地方，这个似乎无所谓，无论这个文件在项目的哪里IDE都会在WEB-INF/classes/下创建一个对应的配置文件。建议复制例程的该文件而不是自己编写，因为这样更不容易出错。 复制过来后将&lt;struts&gt;&lt;/struts&gt;中的内容修改为： 1&lt;constant name=\"struts.devMode\" value=\"true\" /&gt;2&lt;package name=\"HelloWorldPkg\" extends=\"struts-default\"&gt; 3 &lt;action name=\"hello\" class=\"helloWorld.action.HelloWorld\" method=\"execute\"&gt;4 &lt;result name=\"success\"&gt;/helloworld.jsp&lt;/result&gt;5 &lt;/action&gt;6&lt;/package&gt; 设置struts.devMode为true可以输出更多日志信息，HelloWorldPkg中的hello这个action规定：当URL为&lt;网站地址&gt;/hello时，调用helloWorld.action包中的HelloWorld类，根据execute()的返回值决定跳转；当返回值为&quot;success&quot;时跳转至/helloworld.jsp。 5.2. Web.xml 新建项目时已经自动生成了这个文件。将&lt;Web-app&gt;&lt;/Web-app&gt;内的内容修改为： 1&lt;display-name&gt;Struts2_HelloWorld&lt;/display-name&gt;2&lt;welcome-file-list&gt;3 &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;4&lt;/welcome-file-list&gt;5&lt;filter&gt;6 &lt;filter-name&gt;struts2&lt;/filter-name&gt;7 &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;8&lt;/filter&gt;9&lt;filter-mapping&gt;10 &lt;filter-name&gt;struts2&lt;/filter-name&gt;11 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;12&lt;/filter-mapping&gt; 这一段内容指定index.jsp为welcome文件。然后配置了Struts2的过滤器来运行任何匹配模式/*的URL，即所有的URL都需要拦截后由Struts进行判断，如果程序决定要调用某个action，再由前面的struts.xml决定调用哪一个。这需要使用一个org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter类。注意在不同版本中这个类是不同的。 有帖子指出welcome-file-list必须放在最后。似乎这并不是必须的。 5.3. log4j2.xml 这个包似乎与日志生成有关，导入方法类似struts.xml，不导入的话会报错ERROR StatusLogger Log4j2 could not find a logging implementation.，但因为只是日志相关所以不影响使用。我导入了也会报错。可能是因为有依赖没搞好？先不管它。 6. 尾声 右击项目，运行方式-&gt;在服务器上运行即可。","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"Struts2","slug":"表世界/Struts2","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/Struts2/"}],"tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://mechanicalmind.cn/tags/MyEclipse/"},{"name":"JSP","slug":"JSP","permalink":"http://mechanicalmind.cn/tags/JSP/"},{"name":"Struts2","slug":"Struts2","permalink":"http://mechanicalmind.cn/tags/Struts2/"}]},{"title":"编写一个注册页面并使用JS函数校验","slug":"表世界/JavaScript与jQuery/编写一个注册页面并使用JS函数校验","date":"2019-10-11T12:09:01.000Z","updated":"2019-10-10T16:00:00.000Z","comments":true,"path":"2019/10/11/表世界/JavaScript与jQuery/编写一个注册页面并使用JS函数校验/","link":"","permalink":"http://mechanicalmind.cn/2019/10/11/%E8%A1%A8%E4%B8%96%E7%95%8C/JavaScript%E4%B8%8EjQuery/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2%E5%B9%B6%E4%BD%BF%E7%94%A8JS%E5%87%BD%E6%95%B0%E6%A0%A1%E9%AA%8C/","excerpt":"实现了简单的参数传递与判断。不连接数据库。","text":"实现了简单的参数传递与判断。不连接数据库。 首先新建一个Web Project，在WebRoot下新建一个html、一个js和一个css文件。将html自动生成的添加css文件的那段注释改成能用的，再添加&lt;script type=&quot;text/javascript&quot; src=&quot;./js.js&quot;&gt;&lt;/script&gt;引入js文件。 body中就是一个表格，action是跳转，单击时希望使用js文件中的函数进行校验。 在表单中加上οnsubmit=&quot;return false;&quot;可以阻止表单提交。但是对于如下的代码οnsubmit=&quot;submitTest();&quot;，如果提交表单时submitTest()返回false，实际情况是表单正常提交。原因在于如果这样写，相当于： 1Form.prototype.onsubmit &#x3D; function() &#123;2 submitTest();3&#125;; 而我们希望得到这样的函数： 1Form.prototype.onsubmit &#x3D; function() &#123;2 return submitTest();3&#125;; 1&lt;form action=\"succ.jsp\" name=\"form\" onsubmit=\"return signIn();\" method=\"post\"&gt;2 &lt;table border=\"\"&gt;3 4 &lt;caption&gt;注册页面&lt;/caption&gt;5 6 &lt;tr&gt;7 &lt;td&gt;用户名&lt;/td&gt;8 &lt;td&gt;9 &lt;input type=\"text\" 10 required=\"required\" 11 name=\"name\" 12 id=\"name\" 13 onblur=\"checkName();\" 14 onfocus=\"clearName();\" 15 value=\"在此输入用户名\"&gt;16 &lt;/td&gt;17 &lt;td&gt;&lt;label id=\"tip_name\"&gt;请输入用户名&lt;/label&gt;&lt;/td&gt;18 &lt;/tr&gt;19 20 &lt;tr&gt;21 &lt;td&gt;密码&lt;/td&gt;22 &lt;td&gt;23 &lt;input type=\"password\" 24 required=\"required\" 25 name=\"pw\" 26 id=\"pw\" 27 onblur=\"checkPw();\"&gt;28 &lt;/td&gt;29 &lt;td&gt;&lt;label id=\"tip_pw\"&gt;密码由六个或以上字符组成&lt;/label&gt;&lt;/td&gt;30 &lt;/tr&gt;31 32 &lt;tr&gt;33 &lt;td&gt;确认密码&lt;/td&gt;34 &lt;td&gt;35 &lt;input type=\"password\" 36 required=\"required\" 37 name=\"repw\" 38 id=\"repw\" 39 onblur=\"checkRepw();\"&gt;40 &lt;/td&gt;41 &lt;td&gt;&lt;label id=\"tip_repw\"&gt;请确认密码&lt;/label&gt;&lt;/td&gt;42 &lt;/tr&gt;4344 &lt;tr&gt;45 &lt;td&gt;性别&lt;/td&gt;46 &lt;td colspan=\"2\"&gt;47 男&lt;input type=\"radio\" name=\"sex\" id=\"sex1\" value=\"male\" required=\"required\"/&gt;48 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;49 女&lt;input type=\"radio\" name=\"sex\" id=\"sex0\" value=\"female\" required=\"required\"/&gt;50 &lt;/td&gt;51 &lt;/tr&gt;52 53 &lt;tr&gt;54 &lt;td&gt;爱好&lt;/td&gt;55 &lt;td colspan=\"2\"&gt;56 &lt;input type=\"checkbox\" name=\"habit\" value=\"PE\"&gt;体育57 &lt;input type=\"checkbox\" name=\"habit\" value=\"music\"&gt;音乐58 &lt;input type=\"checkbox\" name=\"habit\" value=\"chinese\"&gt;文学59 &lt;input type=\"checkbox\" name=\"habit\" value=\"other\"&gt;其他60 &lt;/td&gt;61 &lt;/tr&gt;62 63 &lt;tr&gt;64 &lt;td&gt;出生年月&lt;/td&gt;65 &lt;td colspan=\"2\"&gt;66 &lt;select name=\"year\"&gt;67 &lt;option selected=\"selected\"&gt;2000&lt;/option&gt;68 &lt;option value=\"1990\"&gt;1990&lt;/option&gt;69 &lt;option value=\"1991\"&gt;1991&lt;/option&gt;70 &lt;option value=\"1992\"&gt;1992&lt;/option&gt;71 &lt;option value=\"1993\"&gt;1993&lt;/option&gt;72 &lt;option value=\"1994\"&gt;1994&lt;/option&gt;73 &lt;option value=\"1995\"&gt;1995&lt;/option&gt;74 &lt;option value=\"1996\"&gt;1996&lt;/option&gt;75 &lt;option value=\"1997\"&gt;1997&lt;/option&gt;76 &lt;option value=\"1998\"&gt;1998&lt;/option&gt;77 &lt;option value=\"1999\"&gt;1999&lt;/option&gt;78 &lt;option value=\"2000\"&gt;2000&lt;/option&gt;79 &lt;/select&gt;年80 &lt;select name=\"month\" &gt;81 &lt;option selected=\"selected\"&gt;1&lt;/option&gt;82 &lt;option value=\"1\"&gt;1&lt;/option&gt;83 &lt;option value=\"2\"&gt;2&lt;/option&gt;84 &lt;option value=\"3\"&gt;3&lt;/option&gt;85 &lt;option value=\"4\"&gt;4&lt;/option&gt;86 &lt;option value=\"5\"&gt;5&lt;/option&gt;87 &lt;option value=\"6\"&gt;6&lt;/option&gt;88 &lt;option value=\"7\"&gt;7&lt;/option&gt;89 &lt;option value=\"8\"&gt;8&lt;/option&gt;90 &lt;option value=\"9\"&gt;9&lt;/option&gt;91 &lt;option value=\"10\"&gt;10&lt;/option&gt;92 &lt;option value=\"11\"&gt;11&lt;/option&gt;93 &lt;option value=\"12\"&gt;12&lt;/option&gt;94 &lt;/select&gt;月95 &lt;/td&gt;96 &lt;/tr&gt;97 98 &lt;tr&gt;99 &lt;td&gt;个人简介&lt;/td&gt;100 &lt;td colspan=\"2\"&gt;&lt;textarea rows=\"4\" cols=\"25\" required=\"required\"&gt;&lt;/textarea&gt;&lt;/td&gt;101 &lt;/tr&gt;102103 &lt;tr&gt;104 &lt;td colspan=\"3\"&gt;105 &lt;input type=\"submit\" value=\"提交\" class=\"bt\"&gt;106 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;107 &lt;input type=\"reset\" value=\"重置\" class=\"bt\"&gt;108 &lt;/td&gt;109 &lt;/tr&gt;110 &lt;/table&gt;111&lt;/form&gt; required=&quot;required&quot;可以要求该项为必填，否则无法提交。select中无法使用该属性，可以使用&lt;option selected=&quot;selected&quot;&gt;2000&lt;/option&gt;设定默认选择的项。 onblur和onfocus分别在对象失去和获得焦点时调用函数，可以实时地提醒用户一些信息。 比如将检查是否提交的函数分为几个小部分，在用户填写表单各小部分对应的对象获得和失去焦点时就调用，即时地给出提醒： 1function clearName()2&#123;3 if(document.getElementById('name').value==\"在此输入用户名\")4 document.getElementById('name').value = null;5&#125;67function checkName()8&#123;9 if(document.getElementById('name').value !=\"在此输入用户名\"&amp;&amp;document.getElementById('name').value!=\"\")10 &#123;11 document.getElementById('tip_name').innerHTML=\"你好，\"+document.getElementById('name').value;12 return true;13 &#125;14 else15 &#123;16 document.getElementById('tip_name').innerHTML=\"请输入用户名\";17 document.getElementById('name').value=\"在此输入用户名\";18 return false;19 &#125;20&#125;2122function checkPw()23&#123;24 if(/^(?=.&#123;6,16&#125;)([0-9A-Za-z]*[\\x00-\\x2F\\x3A-\\x40\\x5B-\\xFF][0-9A-Za-z]*)&#123;2,&#125;$/.test(document.getElementById('pw').value))25 &#123;26 document.getElementById('tip_pw').innerHTML=\"天呐这么复杂的密码你记得住？\";27 return true;28 &#125;29 else if(/^(?=.&#123;6,16&#125;)[0-9A-Za-z]*[\\x00-\\x2f\\x3A-\\x40\\x5B-\\xFF][0-9A-Za-z]*$/.test(document.getElementById('pw').value))30 &#123;31 document.getElementById('tip_pw').innerHTML=\"这强度凑活吧……\";32 return true;33 &#125;34 else if(/^[0-9A-Za-z]&#123;6,16&#125;$/.test(document.getElementById('pw').value))35 &#123;36 document.getElementById('tip_pw').innerHTML=\"这密码我一刻钟就能破解！\";37 return true;38 &#125;39 else40 &#123;41 document.getElementById('tip_pw').innerHTML=\"密码由六至十六个字符组成\";42 return false;43 &#125;44&#125;4546function checkRepw()47&#123;48 var pw = document.getElementById('pw');49 var repw = document.getElementById('repw');50 var tip_repw = document.getElementById('tip_repw');51 52 if(pw.value == repw.value&amp;&amp;pw.value!=\"\")53 &#123;54 tip_repw.innerHTML=\"√\";55 return true;56 &#125;57 else if(repw.value==\"\")58 &#123;59 tip_repw.innerHTML=\"请确认密码\";60 return false;61 &#125;62 else63 &#123;64 tip_repw.innerHTML=\"密码不一致\";65 return false;66 &#125;67&#125;6869function signIn()70&#123;71 if(!checkName())72 &#123;73 alert(\"请检查用户名！\");74 return false;75 &#125;76 if(!checkPw())77 &#123;78 alert(\"请检查密码！\");79 return false;80 &#125;81 if(!checkRepw())82 &#123;83 alert(\"请重新确认密码！\");84 return false;85 &#125;86 return true;87&#125; HTML DOM 定义了多种查找元素的方法，如果需要查找文档中的一个特定的元素，最有效的方法是 getElementById()。在写html时给需要被查找的元素一个id属性，为它指定一个（在文档中）唯一的名称，然后就可以用该id查找想要的元素，该函数返回元素对象。注意要用.value获取它的“值”，因为返回的只是标签，而想要的“值”是标签里的东西。而修改的话就是修改innerHTML也就是标签里面的html语句，另外还有一个innerText类似前者，但是把内容都当文本理解（有点类似赋值给value？）。例如添加&lt;h1&gt;test&lt;\\h1&gt;，前者显示h1级别的test，后者显示&lt;h1&gt;test&lt;\\h1&gt;。","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"JavaScript与jQuery","slug":"表世界/JavaScript与jQuery","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/JavaScript%E4%B8%8EjQuery/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://mechanicalmind.cn/tags/HTML/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://mechanicalmind.cn/tags/JavaScript/"}]},{"title":"Manjaro Linux下配置JS&jQuery开发环境","slug":"表世界/JavaScript与jQuery/Manjaro-Linux下配置JS-jQuery开发环境","date":"2019-10-11T12:07:10.000Z","updated":"2019-10-11T12:07:10.000Z","comments":true,"path":"2019/10/11/表世界/JavaScript与jQuery/Manjaro-Linux下配置JS-jQuery开发环境/","link":"","permalink":"http://mechanicalmind.cn/2019/10/11/%E8%A1%A8%E4%B8%96%E7%95%8C/JavaScript%E4%B8%8EjQuery/Manjaro-Linux%E4%B8%8B%E9%85%8D%E7%BD%AEJS-jQuery%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"之前的JSP环境直接就可以拿来写JS,但是并没有语法提示等,因此需要装个插件解决这个问题。","text":"之前的JSP环境直接就可以拿来写JS,但是并没有语法提示等,因此需要装个插件解决这个问题。 javaScript是一种脚本语言。可以以&lt;script&gt; code &lt;/script&gt;的形式混合在HTML页面中编写动态网页。 0. 环境 MyEclipse 2017 Ci10 jquery-migrate-1.4.1.js spket-1.6.23 1. 安装spket spket是一个JS的IDE，但也可以作为eclipse或MyEclipse的插件使用。下载https://spket.com/download.html中的plugin版本得到一个zip，将其中两个文件夹直接与MyEclipse目录下同名文件夹合并即可。 为了让它可以对jQuery进行智能提示，还需为它指定jQuery的文件，在https://jquery.com/download/右击另存为uncompressed版本。网上说压缩过的min版本会各种报错。 2. 配置spket 使用.../&quot;MyEclipse 2017 CI&quot;/myeclipse -clean启动MyEclipse。直接启动会报错，可能是因为插件缓存的缘故。注意因为MyEclipse 2017默认安装目录中间有空格所以要加引号。启动后在窗口-&gt;首选项-&gt;spket-&gt;JavaScript Profiles中new一个profile，比如取名为”jQuery“，点击Add Library，选择jQuery；再点击Add File，选择jQuery的.js。最后点Default。 在窗口-&gt;首选项–&gt;常规–&gt;编辑器–&gt;文件关联中将*.js的缺省编辑器设为“Spket JavaScript Editor”即可。 右键项目名称，点击Reload JavaScript Profile然后再打开JS文件（可能需要重启），应当会出现语法提示和智能补全。","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"JavaScript与jQuery","slug":"表世界/JavaScript与jQuery","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/JavaScript%E4%B8%8EjQuery/"}],"tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://mechanicalmind.cn/tags/MyEclipse/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://mechanicalmind.cn/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://mechanicalmind.cn/tags/jQuery/"}]},{"title":"《城市：天际线》中的有用模组","slug":"其它/《城市：天际线》中的有用模组","date":"2019-10-07T12:49:21.000Z","updated":"2019-12-07T16:00:00.000Z","comments":true,"path":"2019/10/07/其它/《城市：天际线》中的有用模组/","link":"","permalink":"http://mechanicalmind.cn/2019/10/07/%E5%85%B6%E5%AE%83/%E3%80%8A%E5%9F%8E%E5%B8%82%EF%BC%9A%E5%A4%A9%E9%99%85%E7%BA%BF%E3%80%8B%E4%B8%AD%E7%9A%84%E6%9C%89%E7%94%A8%E6%A8%A1%E7%BB%84/","excerpt":"记录好用的《发际线》模组。感谢所有模组的作者！常年更新。","text":"记录好用的《发际线》模组。感谢所有模组的作者！常年更新。 尽管即使打开蓝灯也无法在steam客户端和游戏内访问创意工房，但在浏览器中的订阅也可以立即生效。因此可以在游戏中打开游戏内浏览器，再将地址复制至浏览器进行订阅操作。 影响建造的模组 fine road anarchy和fine road tool 前者屏蔽道路的碰撞判定。是极重要的前置模组。后者 强化了道路编辑模式下那个调整每次抬升高度的功能，点开后分为三行，除第一行保留原有功能外，第二行允许强制道路类型，第三行四个功能分别为取消道路角度限制、智能弯曲道路、自动吸附和道路与其它元素的无冲突（例如开启后升级道路不会挤没建筑）。 Move It 启用该模组后将在右下角推土机的左边新增一个十字箭头样的按钮，提供了移动已安放物品的功能。 点开后从左至右共九个按钮。 前两个按钮是导入与导出，可以导入与导出当前选中的元素。导出似乎与主题相关，将导出的内容导入到不同主题的地图时，不兼容的建筑不会被导入（似乎是因为这个，有待继续测试，总之道路没问题，低密度住宅区没问题，会成为“历史性建筑”出现，太阳能发电站垃圾焚烧厂收费站电车站各种直升机中心没问题，而小学警局消防局等和商业区等都无法导入）。之后两个选项是地形跟随与辅助线，前者控制在移动部分类型元素如房屋时其高度是否跟随地形变化，后者开启时为道路等提供角度为90°的整倍时的吸附。 之后的四个选项提供点选择（可使用shift多选）、区域选择、复制和删除的功能。其中复制可以使用ctrl+c，并支持ctrl+z撤销，区域选择功能提供了大量完善的分类功能，且可使用类似Ps中吸管的类型选定工具。 最后一个上三角图标提供了大量有用功能。从下往上数第一个柱状图一样的图标，先选中一个建筑或道路节点等，再选中它，再选另一个元素，即可使前者与后者同高。选中一个元素后再点一下第二个长相与第一个类似的图标就可以使它的高度恢复贴地状态（注意，对高架等使用此功能会使路面和柱子全部贴地，但不影响通行）。选中一段路的所有点和段后再点一下第三个像线性拟合一样的图标后再点击某两个节点，则选中道路的角度将与两点连线与地面之夹角相同。选中一些建筑后点击第四个五边形图标或第五个闪电形图标再点击其中或另外的一建筑，可使所有被选中建筑朝向被点击建筑的方向，区别在于前者的旋转中心为各建筑中心，后者为整体的中心。选中后点击第六个图标则可打乱方向。选中一些元素后点击上数第一个图标再点一个线性元素可实现镜面复制。 另外贴合右侧边缘处还提供了两个视图。 network extentions 2 提供更多道路种类。例如公交车道与人行道。尤其人行道可做成低级道路避免车辆抄近道。 Ploppable RICO RICO指的是住宅、商业等四个区那种会生长的建筑（Residential住宅、Industrial工业、Commerical商业、Office办公，首字母RICO）的一种创意工房版本。启用此模组后会在工具栏右侧出现一个新的左绿右黄下蓝的图标，在创意工房订阅了“RICO”之后可以从此处“噗通”出建筑。也可以从弹出的面板右上角的设置中添加游戏自带的建筑并设置其属性使之成为“RICO”，此操作重启后生效。 Plop the Growables 原本Find It只能放置“RICO”，该模组可让游戏自带的“Growables”可通过Find It放置。 Precision Engineering 修路时按住shift显示更多参数。 影响经营的模组 extra landscaping tools 在工具栏上预算图标右侧新增矿物和水体两个图标，可编辑矿物与水的分布。 Improved Public Transport 2 在查看公共交通面板时提供时速等信息。 No Problem Notifications 作 quay anarchy 允许小河堤在任何地方建造。小河堤平整坡面很有用也很好看。 Prop &amp; Tree Anarchy 作 Prop Line Tool [PLT] (vAlpha) 作 摆放prop时可使用类似修路的工具进行线性摆放。 Prop Precision 变大变小 Procedural Objects 变大变小 Prop Scaling 0.3 [Experimental ALPHA] 允许贴在表面 影响城展的模组 Adaptive Prop Visibility Distance 允许调整元素距离多远可见。 Dynamic Resolution (Fixed for 1.9!) 动态抗拒齿。 first person auto walking 提供第一人称行走功能。 LOD Toggler (deprecated) 允许手动调整细节程度。封面图是“READY TO MELT YOUR GPU？”。 影响外观的模组 network skins 提供道路皮肤。在道路编辑模式下会在右下角出现小窗口用以选择。 Road Options (Road Colors Changer ++) 和 Painter Relight 作显示设置中“色彩矫正覆盖”中提供一些滤镜。 Theme Mixer 在该模组的选项中可以修改每种元素使用那个主题的样式，只支持创意工房的主题。 Surface Painter 在工具栏右侧增加一个“地表工具”图标，允许涂画地表。譬如建筑之间的缝隙原本是草坪，就可以用它涂成水泥，变得更工业风，非常有用。 方便操作的模组 Loading Screen Mod 加载时显示加载信息。可提供缺失资产的信息，可禁止部分资产的加载。 Automatic Bulldoze v2 建筑废弃后自动拆除。 Find It! 在工具栏右侧提供一个放大镜图标用于搜索资产。 More Beautification 为铲子那个图标提供更多分栏。 Advanced Toolbar 在左下方问号图标旁提供一个加号图标，可将下方道具栏展开后的状态由显示一行提升为三行。","categories":[{"name":"其它","slug":"其它","permalink":"http://mechanicalmind.cn/categories/%E5%85%B6%E5%AE%83/"},{"name":"丧志","slug":"其它/丧志","permalink":"http://mechanicalmind.cn/categories/%E5%85%B6%E5%AE%83/%E4%B8%A7%E5%BF%97/"},{"name":"城市：天际线","slug":"其它/丧志/城市：天际线","permalink":"http://mechanicalmind.cn/categories/%E5%85%B6%E5%AE%83/%E4%B8%A7%E5%BF%97/%E5%9F%8E%E5%B8%82%EF%BC%9A%E5%A4%A9%E9%99%85%E7%BA%BF/"}],"tags":[{"name":"城市：天际线","slug":"城市：天际线","permalink":"http://mechanicalmind.cn/tags/%E5%9F%8E%E5%B8%82%EF%BC%9A%E5%A4%A9%E9%99%85%E7%BA%BF/"}]},{"title":"Manjaro Linux因显卡驱动无法进入图形界面之处理方法","slug":"戏法/Manjaro-Linux因显卡驱动无法进入图形界面之处理方法","date":"2019-09-30T08:40:32.000Z","updated":"2019-09-30T08:40:32.000Z","comments":true,"path":"2019/09/30/戏法/Manjaro-Linux因显卡驱动无法进入图形界面之处理方法/","link":"","permalink":"http://mechanicalmind.cn/2019/09/30/%E6%88%8F%E6%B3%95/Manjaro-Linux%E5%9B%A0%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E4%B9%8B%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/","excerpt":"因尝试更换显卡驱动为nVIDIA 430xx导致重启后无法进入图形界面，只是黑屏并在屏幕左上角显示一个光标。","text":"因尝试更换显卡驱动为nVIDIA 430xx导致重启后无法进入图形界面，只是黑屏并在屏幕左上角显示一个光标。 0. 环境 Manjaro Linux 18.1.0 video-hybrid-intel-nvidia-430xx-bumblebee VERSION 2019.08.24 1. 进入tty界面 tty，源于Teletypes，原指电传打字机，对于现在的电脑来讲可以叫终端。可以使用w查看当前使用的终端。在使用GNOME+GDM的manjaro下，共有6个tty。登录界面在tty1运行，登录成功后进入在tty2运行的图形界面（登录界面仍保持在tty1运行）。其余界面为文本界面。现在的问题在于由于显卡驱动问题无法进入tty2，因此只需在文字界面下解决驱动问题即可。 使用ctrl+alt+Fx可以切换到ttyx，现在切换到tty3，输入用户名，回车，密码，回车，即可进入tty3。 2. 修改语言配置 tty3-6不能支持中文，而配置的语言是中文的，因此凡是中文会显示为方块。其实在输命令的时候没太大影响，但后面连Wifi的界面全是中文，所以要改成英文。 使用export命令可以修改语言，且仅对当次进入终端有效。 Linux export 命令用于设置或显示环境变量。 在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。 通过export -p可以查看当前的环境变量，有关语言的环境变量（也就是locale，也可以直接用locale查看，根据计算机用户所使用的语言、所在国家或地区以及当地的文化传统所定义的一个软件运行时的语言环境。locale的命名规则为_.，如zh_CN.UTF-8，zh代表中文，CN代表大陆地区，UTF-8表示字符集）默认都是“zh_CN.UTF-8”，执行export xxx=xxx可以修改变量的值。 印象中当时是使用export LC_ALL=en_US.UTF-8和export LANG=en_US.UTF-8。这堆LC_xxx有一堆优先级规则，显而易见LC_ALL是老大。它是一个宏，如果该值设置了，则该值会覆盖所有LC_xxx的设置值。注意，LANG的值不受该宏影响。 【其它有关内容】 locale -a：查看本机可选的配置。可通过诸如sudo locale-gen &quot;zh_CN.gbk&quot;增加。 C和POSIX：默认配置，例如export LC_ALL=C。 3. 连接Wifi 因为需要下载安装原本使用的驱动，所以先连Wifi。 一些Linux中连接Wlan专门有个界面，叫nmtui，即“Network Manager TextUI”，nmtui即可进入。 其中中间的三个选项，第一个是编辑保存的链接，第二个是进行连接。进去第二个等一会，扫描出来之后连上即可。 4. 更换驱动 manjaro提供了方便的驱动管理工具，叫mhwd，即“Manjaro Hardware Detection”，mhwd即可进入，mhwd-tui可进入TUI。在TUI中很方便地选择“Use nonfree graphics”就好了。更新引导sudo mkinitcpio -P即可。 5. 尾声 这个默认的闭源驱动是真的不错。 NVIDIA的Optimus（擎天柱）技术可让笔记本根据性能需要在英特尔集成显卡和NVIDIA独显之间自动切换（其实不是切换而是“是否开启独显”，显示一直都是由集显完成的，只是独立显卡按需渲染并传输给集成显卡显示功能），以达到节约能耗与平衡性能双需求，但此项技术仅仅支持Windows系统。 而默认的“video-hybrid-intel-nvidia-bumblebee”，也就是那个著名的把rm -rf /usr/lib/nvidia-current/xorg/xorg写成rm -rf /usr /lib/nvidia-current/xorg/xorg的软件，可以实现手动的切换。只需在命令前添加optirun即可指定该命令由独显执行。在Steam下，修改游戏属性中的高级启动选项为optirun %command%可指定游戏运行在独立显卡上。原本我的古墓丽影只能以720P全低特效运行，添加这一选项后可以1080P全最高特效丝般顺滑。可惜不知道为啥存档没能继承Windows上的…… 不过Bumblebee不兼容Vulkan。可能可以通过“nvidia-xrun”解决，还未尝试。 最开始的时候在steam改高级选项后启动游戏，会闪一下steam的启动界面然后毫无反应。后来解决了，但是忘了怎么弄的了……果然好记性不如双飞燕……可能是一开始没有进行设置： In order to use Bumblebee, it is necessary to add your regular user to the bumblebee group: 需要gpasswd -a &lt;user&gt; bumblebee。 使用bumblebeed --version查看bumblebee版本，optirun nvidia-settings -c :8以设置N卡，optirun glxgears -info进行测试，vblank_mode=0 glxgears查看关闭垂直同步后的帧数。 后记 安装Manjaro后的第一次更新之后，再次出现了无法使用optirun %command%命令进入游戏的情况。从终端通过optirun steam进入游戏，则将以集显进入；通过primusrun steam进入，则报错“glXChooseVisual failed”。 尝试卸载显卡驱动重装，无效。尝试安装网上的驱动前置的东西sudo pacman -S virtualgl lib32-virtualgl lib32-primus primus，无效。有说法认为报错原因是“libGL.so.1指向mesa和nvidia提供的模糊libGL”，因此删除这些（sudo ldconfig -p | grep -i gl.so中查看）指向mesa的.so即可，但我未找到指向mesa的.so。 最后的处理方案是sudo systemctl disable bumblebeed.service禁用了大黄蜂，安装了另一个管理软件sudo pacman -S optimus-manager并reboot后启用systemctl enable optimus-manager.service。该软件可optimus-manager --switch nvidia切换为N卡。但会注销，还是不如大黄蜂好用…… 【第二天的更新】操，不能用，切完之后optimus-manager --status显示还是用的Intel，昨天断电了玩着卡还以为是断电的原因。似乎是因为GDM与之不兼容，还需要装兼容的版本。游戏啥的，戒了算了。","categories":[{"name":"戏法","slug":"戏法","permalink":"http://mechanicalmind.cn/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"Manjaro","slug":"Manjaro","permalink":"http://mechanicalmind.cn/tags/Manjaro/"},{"name":"BumbleBee","slug":"BumbleBee","permalink":"http://mechanicalmind.cn/tags/BumbleBee/"}]},{"title":"Manjaro Linux下配置MySQL并在MyEclipse中使用","slug":"表世界/JSP/Manjaro-Linux下配置MySQL并在MyEclipse中使用","date":"2019-09-30T08:39:14.000Z","updated":"2019-12-14T16:00:00.000Z","comments":true,"path":"2019/09/30/表世界/JSP/Manjaro-Linux下配置MySQL并在MyEclipse中使用/","link":"","permalink":"http://mechanicalmind.cn/2019/09/30/%E8%A1%A8%E4%B8%96%E7%95%8C/JSP/Manjaro-Linux%E4%B8%8B%E9%85%8D%E7%BD%AEMySQL%E5%B9%B6%E5%9C%A8MyEclipse%E4%B8%AD%E4%BD%BF%E7%94%A8/","excerpt":"配合MyEclipse使用MySQL。","text":"配合MyEclipse使用MySQL。 0. 环境 MyEclipse 2017 ci10 Tomcat 9.0或8.5 JDK 8u221 JDBC 8.0.17 1. MySQL安装 只需sudo pacman -S mysql便可以安装MySQL。装好后根据提示sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql，注意此步需root权限，并会返回临时的用户名和密码，在输出的那一堆东西里找一下。随后可sudo systemctl enable mysqld开机自启、sudo systemctl start mysqld启动服务、sudo systemctl status mysqld查看状态。 使用刚刚给出的临时密码登录mysql -uroot -p&lt;密码&gt;后会提示可以sudo mysql_secure_installation，如果运行的话会执行以下安全设置： 为root用户设置密码 删除匿名账号 取消root用户远程登录 删除test库和对test库的访问权限 刷新授权表使修改生效 看心情设置一下。之后通过“添加/删除软件”安装“MySQL WorkBench”即可进行图形化的操作。 【2020-01-06更新】今天试图sudo systemctl start mysqld时报错： 1Job for mysqld.service failed because the control process exited with error code.2See &quot;systemctl status mysqld.service&quot; and &quot;journalctl -xe&quot; for details. 执行其提示的命令没看到什么有用的信息，网上看了下其错误日志为/var/log/mysql.log，但打开是空文件；又找了下发现其配置文件为/usr/etc/my.cnf，打开看到其内容为： 1# 很多注释，说不要编辑此文件之类23datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql4socket&#x3D;&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock56sql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 网上说可以增加一条log-error=/var/log/mysql.log使日志可以生成，加入后再次sudo systemctl start mysqld，确实生成以下日志： 12020-01-05T16:54:11.081802Z 0 [Warning] [MY-010915] [Server] &#39;NO_ZERO_DATE&#39;, &#39;NO_ZERO_IN_DATE&#39; and &#39;ERROR_FOR_DIVISION_BY_ZERO&#39; sql modes should be used with strict mode. They will be merged with strict mode in a future release.22020-01-05T16:54:11.081880Z 0 [System] [MY-010116] [Server] &#x2F;usr&#x2F;bin&#x2F;mysqld (mysqld 8.0.18) starting as process 1169832020-01-05T16:54:11.111586Z 1 [ERROR] [MY-011011] [Server] Failed to find valid data directory.42020-01-05T16:54:11.111754Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed.52020-01-05T16:54:11.111805Z 0 [ERROR] [MY-010119] [Server] Aborting62020-01-05T16:54:11.112463Z 0 [System] [MY-010910] [Server] &#x2F;usr&#x2F;bin&#x2F;mysqld: Shutdown complete (mysqld 8.0.18) Source distribution. 说不能初始化data directory，但查看/usr/etc/my.cnf中配置的datadir即/var/lib/mysql是有东西的，删掉再启动也会重新生成。 尝试重装，sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql时报了个类似/var/lib/mysql不可用的错，删掉，成功。 （所以我是不是上次装的时候忘初始化了？） 2. JDBC下载 https://dev.mysql.com/downloads/connector/j/下载Platform Independent版本，解压。 3. 与MyEclipse链接 使用MySQL WorkBench新建一个Schema（注意在Collation下拉列表中选择数据库需要修改为的字符集），并新建一个Table（不知为啥新建table时如果改table名字会导致无法操作其它内容，只能先设置其它内容应用后再回头改名字），用于测试。 在MyEclipse中点击窗口-&gt;Perspective-&gt;打开透视图-&gt;Database Explorer，在左侧“DB Broster”中空白处右击new一数据库，弹出“DataBase Driver”界面： Driver template：选择MySQL Connector/J Driver name：编个名字 Connection URL：改为 jdbc:mysql://localhost:3306/ User name ：数据库用户名，默认root Password：访问密码 Add Jar：JDBC的jar包的路径 Driver classname：系统会自动匹配 Test一下成功后点完成即可。此时“DB Broster”中会多出MySQL数据库，双击即可链接上。 4. 测试链接 在MyEclipse中新建一个Java项目，在其中新建一个lib文件夹，把JDBC的.jar丢进去，在MyEclipse中右击这个包构建一下路径。此时可以在该项目“引用的库”列表中看到这个包。 再在src/新建一包，在其中新建一类。以包名为testDB、类名为Test、前面新建的table名为new_table、table中有name和pw两列为例： 1package testDB;2import java.sql.*;34public class Test 5&#123; 6 static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\"; 7 static final String DB_URL = \"jdbc:mysql://localhost:3306/db0?useSSL=false&amp;serverTimezone=UTC\";8 static final String USER = \"root\";9 static final String PASS = \"root\";1011 public static void main(String[] args) 12 &#123;13 Connection conn = null;14 Statement stmt = null;15 16 try17 &#123;18 // 注册 JDBC 驱动19 Class.forName(JDBC_DRIVER);20 // 打开链接21 System.out.println(\"连接数据库...\");22 conn = DriverManager.getConnection(DB_URL,USER,PASS);23 // 执行查询24 System.out.println(\"实例化Statement对象...\");25 stmt = conn.createStatement();26 String sql;27 sql = \"SELECT name,pw FROM new_table\";28 ResultSet rs = stmt.executeQuery(sql);2930 // 打印结果31 while(rs.next())32 &#123;33 // 通过字段检索34 String name = rs.getString(\"name\");35 String pw = rs.getString(\"pw\");36 37 // 输出数据38 System.out.print(\"账户: \" + name);39 System.out.print(\"\\t\");40 System.out.print(\"密码: \" + pw);41 System.out.print(\"\\n\");42 &#125;43 44 // 完成后关闭45 rs.close();46 stmt.close();47 conn.close();48 49 &#125;catch(SQLException se)&#123;50 // 处理 JDBC 错误51 se.printStackTrace();52 &#125;catch(Exception e)&#123;53 // 处理 Class.forName 错误54 e.printStackTrace();55 &#125;finally&#123;56 // 关闭资源57 try&#123;58 if(stmt!=null) stmt.close();59 &#125;catch(SQLException se2)&#123;60 // 什么都不做61 &#125;62 63 try&#123;64 if(conn!=null) conn.close();65 &#125;catch(SQLException se)&#123;66 se.printStackTrace();67 &#125;68 &#125;69 System.out.println(\"Goodbye!\");70 &#125;71&#125; 【注意】对旧版JDBC，JDBC_DRIVER与DB_URL两项与以上不同。与老版相比，这里使用的新的8.0版本将com.mysql.jdbc.Driver改为com.mysql.cj.jdbc.Driver（需要注意Tomcat也要用JDK8）；另外已不需要建立ssl连接，但需要设置CST时区。 各数据库默认端口号如下： 数据库 端口 Oracle 1521 SQL Server 1433 MySQL 3306 Derby 1527 pointbase 9092 DB2 5000 MongoDB 27017 Redis 6379 memcached 11211 5. 尾声 如需在Web开发中使用JDBC，需将.jar放一份到Tomcat的lib目录下，并重启。一定注意跑页面时选择Tomcat，不然连不上数据库。","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"JSP","slug":"表世界/JSP","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/JSP/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://mechanicalmind.cn/tags/MySQL/"},{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://mechanicalmind.cn/tags/MyEclipse/"}]},{"title":"Manjaro Linux下配置JSP开发环境","slug":"表世界/JSP/Manjaro-Linux下配置JSP开发环境","date":"2019-09-26T12:35:52.000Z","updated":"2019-12-15T12:35:52.000Z","comments":true,"path":"2019/09/26/表世界/JSP/Manjaro-Linux下配置JSP开发环境/","link":"","permalink":"http://mechanicalmind.cn/2019/09/26/%E8%A1%A8%E4%B8%96%E7%95%8C/JSP/Manjaro-Linux%E4%B8%8B%E9%85%8D%E7%BD%AEJSP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"MyEclipse的安装。","text":"MyEclipse的安装。 0. 环境 Manjaro Linux 18.1.0 JDK 8u221 tomcat 9.0 Myeclipse 2017 ci10 1. 安装JDK 从官网https://www.oracle.com/technetwork/java/javase/downloads/index.html下载JavaSE的tar.gz格式，完成后提取到随便什么地方，例如家目录下。 在~/.bashrc中添加： 1export PATH&#x3D;~&#x2F;jdk1.8.0_221bin:$PATH2export JAVA_HOME&#x3D;~&#x2F;jdk1.8.0_221&#x2F; 此时运行java -version可判断安装情况。 2. 安装MyEclipse MyEclipse是集成了一些包的Eclipse，与后者不同，这是一个收费软件。 获取Myeclipse的.run文件、破解包和汉化包，进入.run文件目录打开终端，chmod +x myeclipse-2017-ci-10-offline-installer-linux.run增加权限，./myeclipse-2017-ci-10-offline-installer-linux.run运行程序安装。装好后取消勾选launch，不要打开。 打开破解包的patch，使用里面的文件替换掉MyEclipse安装目录下的plugins内的同名文件，再进入破解包另一个文件夹打开终端运行java -jar cracker2017.jar，注意该安装包只能运行在java8下，如果最开始安装的JDK是更新的版本，需要用同样的方法安装java8并修改PATH。进入破解软件界面后输入Usercode（任意字母或者数字），后面的下拉列表选择Blue，点击SystemId两次，点击Active，点击菜单栏-&gt;Tools-&gt;saveProperties。此时启动MyEclipse，在help-&gt;subscription information可见产品已激活。 直接使用汉化包中的文件夹合并MyEclipse安装目录中的同名文件夹并替换其中同名文件即可完成汉化。 在首选项中Maven项下关闭所有有关下载啊更新啊之类的项。 3. 安装tomcat并将之与MyEclipse关联 此项可忽略，因为MyEclipse自带Tomcat。但也按以下步骤可以安装新的版本，并不冲突。 从官网http://tomcat.apache.org/下载tar.gz包并提取，例如提取到家目录，可在终端执行bin下的startup.sh和shutdown.sh开启和关闭，开启后通过访问http://localhost:8080/可以看到一个页面。 在首选项中服务器项下的运行时环境项下点击&quot;add&quot;的添加按钮，弹出选项，选择与下载的相同的Tomcat版本，&quot;Next&quot;，选择Tomcat的安装目录，并选择安装的Java环境，&quot;Finish&quot;，完成配置。 新建Web Project时注意一下选项中的Target Runtime，如果不是刚才配置的则需要点后面的New Runtime添加。创建项目时记得在最后一个选项卡勾选Generate Web.xml...那一项。运行新建的Web Project，可以看到一个有一行文字的网页。","categories":[{"name":"表世界","slug":"表世界","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"JSP","slug":"表世界/JSP","permalink":"http://mechanicalmind.cn/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/JSP/"}],"tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://mechanicalmind.cn/tags/MyEclipse/"},{"name":"Java","slug":"Java","permalink":"http://mechanicalmind.cn/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"http://mechanicalmind.cn/tags/JSP/"}]},{"title":"Manjaro Linux主力机的安装与及基本环境配置","slug":"戏法/Manjaro-Linux主力机的安装与及基本环境配置","date":"2019-09-23T13:34:18.000Z","updated":"2019-12-07T16:00:00.000Z","comments":true,"path":"2019/09/23/戏法/Manjaro-Linux主力机的安装与及基本环境配置/","link":"","permalink":"http://mechanicalmind.cn/2019/09/23/%E6%88%8F%E6%B3%95/Manjaro-Linux%E4%B8%BB%E5%8A%9B%E6%9C%BA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"双显卡笔记本电脑写代码环境的全配置，包括VSCode、Hexo和日常软件。","text":"双显卡笔记本电脑写代码环境的全配置，包括VSCode、Hexo和日常软件。 环境 本文时效性较强，许多配置方式会因软件的更新与迭代而发生变化。 戴尔Inspiron 15-7567笔记本，英特尔i7-7700HQ（集成HD630）+英伟达GTX1050Ti，三星970EVO500G（NVMe）。 使用32G闪迪酷刃U盘引导安装manjaro-GNOME-18.1.0-rc10-stable-x86_64，经测试兼容良好，触控板灵敏，所有功能键均可正常使用（第一次装的时候Fx键直接按是功能键，按Fn键是Fx，第二次装的时候按Fx直接就是Fx，按住Fn才是功能键，奇怪）。 系统安装 制作引导盘 在中科大镜像站https://mirrors.ustc.edu.cn/manjaro-cd/下载iso镜像（manjaro|乐于简单那个网站似乎是个人的……），再在http://rufus.ie/下载引导盘制作工具Rufus，分区类型GPT，目标系统类型UEFI(非CSM)，其余默认，点击开始。检测到ISOHybrid镜像后以DD镜像模式写入，否则系统无法识别。 应当使用尽可能新的系统镜像，这是由于Manjaro是滚动更新，新的补丁仅针对新的环境进行测试，老系统直接更新最新的内容的话很容易滚挂——基于同样的理由，装好系统后平时也应当保持最新。 BIOS设置 开机闪DELL图标时狂按F12（不用按Fn），进入BIOS界面，选择BIOS SETUP进入图形界面进行设置，在出厂设置下修改Secure Boot-&gt;Secure Boot Enable为Disabled，否则会有一系列错误：微软要求预装Windows的PC需要开启Secure Boot，此时操作系统启动过程中涉及到的无CA数字签名的软件比如Linux这种开源的无签名的系统就会被直接阻止；修改System Configuration-&gt;SATA Operation为AHCI，否则系统将无法识别到NVMe的硬盘：AHCI（Serial ATA Advanced Host Controller Interface，串行ATA高级主控接口/高级主机控制器接口）是以Intel为首的多家公司联合研发的接口标准，它允许存储驱动程序启用高级串行 ATA 功能，如本机命令队列和热插拔等。 系统安装 开机进BIOS界面，选择引导盘启动，进入grub界面，选择语言为中文，将光标移动至BOOT那一项上按E编辑启动设置，或进入那个空白的笔记本一样的选项，将driver=free改为（或直接添加，如果选择进入空白的笔记本一样的选项的话）driver=intel xdriver=mesa acpi_osi=! acpi_osi=&quot;Windows 2009&quot;，否则会因默认的开源驱动nouveau与N卡冲突而卡死。按ctrl+x或F12即可启动。 启动后正常安装即可。 关于分区设置，选择默认的清空磁盘选项，如果选择自定义，应当在硬盘开始处设置1MiB空闲空间。安装完成后选择重启，在出现DELL图标后长按Esc键直至进入grub界面（网络上各路教程都说是按住Shift键进入，但经测试该机器下无效），按E进入编辑模式，在quite后添加nouveau.modeset=0，理由同上，按ctrl+x或F12即可启动。这一设置只影响当次启动，因此在配置好驱动前的每次启动都应做此设置。 系统配置 配置pacman Pacman是Arch Linux的包管理器。提供经过测试的完善支持的程序。应当尽可能使用pacman提供的程序，由社区维护的程序可能会出各种奇怪的问题。 sudo pacman-mirrors -i -c China -m rank，随后会弹出一个图形界面，可在其中选择一些源添加。添加并更新sudo pacman -Syy后在国内也可以方便地下载包了。 pacman中的包通过GPG签名，想要安装一个包，则这个包必须通过检查。因此需要先为计算机安装和更新密钥以识别待安装的包：sudo pacman -S archlinux-keyring，sudo pacman-key --refresh-keys。重新加载sudo pacman-key --init、sudo pacman-key --populate并清除缓存sudo pacman -Scc后应当就没问题了。 此时可能出现仍无法进行验证的错误，将/etc/pacman.conf中的SigLevel项都设为Never即可，此选项决定对密钥的检查级别。记得用完改回来。 接下来（可以等省完系统啥的回来再说）配置额外的源： archlinuxcn是由Arch Linux中国维护的提供具有中国特色的包的仓库。 在/etc/pacman.conf添加： 1[archlinuxcn]2SigLevel&#x3D;Optional TrustedOnly3Server&#x3D;服务器地址 以下地址供参考： CDN (ipv4, http, https) Global CDN (no nodes in mainland China)[archlinuxcn] Server= https://cdn.repo.archlinuxcn.org/$arch 浙江大学 (浙江杭州) (ipv4, ipv6, http, https) Added: 2017-06-05[archlinuxcn] Server= https://mirrors.zju.edu.cn/archlinuxcn/$arch 中国科学技术大学 (ipv4, ipv6, http, https)[archlinuxcn] Server= https://mirrors.ustc.edu.cn/archlinuxcn/$arch 清华大学 (ipv4, ipv6, http, https)[archlinuxcn] Server= https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch xTom (Hong Kong) (ipv4, ipv6, http, https) Added: 2017-09-18 xTom Hong Kong Mirror[archlinuxcn] Server= https://mirror.xtom.com.hk/archlinuxcn/$arch Unique Studio (湖北武汉) (ipv4, http, https) Added: 2017-08-02[archlinuxcn] Server= https://mirrors.hustunique.com/archlinuxcn/$arch 上海科技大学 (上海) (ipv4, http, https) Added: 2016-04-07[archlinuxcn] Server= https://mirrors-wan.geekpie.org/archlinuxcn/$arch 中国科学院开源软件协会 (北京) (ipv4, http) Added: 2017-02-09[archlinuxcn] Server= http://mirrors.opencas.org/archlinuxcn/$arch 电子科技大学凝聚网络安全工作室 (ipv4, http) Added: 2016-05-28[archlinuxcn] Server= http://mirrors.cnssuestc.org/archlinuxcn/$arch 网易 (ipv4, http)[archlinuxcn] Server= http://mirrors.163.com/archlinux-cn/$arch 重庆大学 (ipv4, http)[archlinuxcn] Server= http://mirrors.cqu.edu.cn/archlinuxcn/$arch 然后全面更新一下，再sudo pacman-mirrors -g更新源列表，更新密钥环sudo pacman -S archlinuxcn-keyring（可能需要多试几次）后即可使用。 不太建议使用其它的社区源。 不需要配置yaourt，它已经停止维护了。 系统更新 sudo pacman-mirrors -g更新源列表，这可以使pacman找到最新的仓库，更新系统前最好这么弄一下保证源最新；sudo pacman -Syyu刷新并更新系统（如果报错误：同步所有数据库失败，可sudo pkill pacman）。 N卡驱动的安装 在Manjaro Setting Manager-&gt;Hardware Configuration中选择Auto Install Proprietary Driver，等很久很久很久之后即可。 常用应用安装 输入法 在linux中，输入法是依托于输入法框架的。主要有ibus和fcitx两个框架。不像搜狗输入法只能在fcitx上使用，RIME输入法两者皆可。这里使用fcitx上的RIME，尽管fcitx-rime并非由RIME官方维护。 首先安装fcitx：sudo pacman -S fcitx-im，该命令将安装fcitx所有必要的组件。另外，sudo pacman -S fcitx-configtool，这个包为fcitx的设置提供了图形界面。fcitx自带中文输入法，不过很难用。安装RIME：sudo pacman -S fcitx-rime。 接下来添加配置文件，指定在GTK或QT下使用fcitx输入。在~/下新建.xprofile，添加： 1export GTK_IM_MODULE&#x3D;fcitx2export QT_IM_MODULE&#x3D;fcitx3export XMODIFIERS&#x3D;@im&#x3D;fcitx 注意：文件为~/.xprofile，如果当前用户为root则类似nano ~/.xprofile的命令会把文件新建在/root/，这是不行的。 接下来重启即可，应当可以看到屏幕右上角出现了一个键盘样图标，点进去选择配置当前输入法，用+添加中州韻，用-删去其它输入法，重新部署之后就可以使用了。 与小狼毫不同，fcitx-rime的皮肤和相关设置由fcitx决定，不过从fcitx中配置也极为方便，不过我配置完后fcitx菜单中的虚拟键盘/方案列表/输入法/皮肤一栏的下拉菜单弹出后会立即收回无法选中，因为不影响使用就没管；另其外自带双拼配置文件（位于程序文件夹/usr/share/rime-data，若没有，从https://github.com/rime/rime-double-pinyin可下载），只需在用户配置文件夹~/.config/fcitx/rime（若为ibus，则为~/.config/ibus/rime）中新建一个default.custom.yaml，添加： 1# default.custom.yaml 2# save it to: 3# ~&#x2F;.config&#x2F;ibus&#x2F;rime (linux) 4# ~&#x2F;Library&#x2F;Rime (macos) 5# %APPDATA%\\Rime (windows) 67patch: 8 schema_list: 9 - schema: luna_pinyin # 朙月拼音 10 - schema: luna_pinyin_simp # 朙月拼音 简化字模式 11 - schema: luna_pinyin_tw # 朙月拼音 臺灣正體模式 12 - schema: terra_pinyin # 地球拼音 dì qiú pīn yīn 13 - schema: bopomofo # 注音 14 - schema: jyutping # 粵拼 15 - schema: cangjie5 # 倉頡五代 16 - schema: cangjie5_express # 倉頡 快打模式 17 - schema: quick5 # 速成 18 - schema: wubi86 # 五笔 86 19 - schema: wubi_pinyin # 五笔拼音混合輸入 20 - schema: double_pinyin # 自然碼雙拼 21 - schema: double_pinyin_mspy # 微軟雙拼 22 - schema: double_pinyin_abc # 智能 ABC 雙拼 23 - schema: double_pinyin_flypy # 小鶴雙拼 24 - schema: wugniu # 吳語上海話（新派） 25 - schema: wugniu_lopha # 吳語上海話（老派） 26 - schema: sampheng # 中古漢語三拼 27 - schema: zyenpheng # 中古漢語全拼 28 - schema: ipa_xsampa # X-SAMPA 國際音標 29 - schema: emoji # emoji 表情 保存后重新部署即可。 Tim sudo pacman -S deepin.com.qq.office安装即可。这个过程同时安装了wine。也可以使用wine打开其它.exe。sudo pacman -S winetricks后即可方便地添加一些windows上的库，例如winetricks xna40安装mono等。 百度云 sudo pacman -S baidunetdisk，需要多试几次才能登录上。 网易云 网易云客户端虽然是网易云和深度合作的官方客户端，但除了可以下载外体验上似乎与Web端相比没什么优势……平时不如用Web…… 非要下载的话Web也不是不可以，以钢铁洪流为例，地址为https://music.163.com/#/song?id=1394369908，将#/song替换为song/media/outer/url即可右键下载。许多网站提供给一个歌曲id跳转到这一页面的服务，也不算麻烦。 代码环境配置 VSCode sudo pacman -S visual-studio-code-bin，ctrl++调大界面，选项里把bar移到右边。 在Explorer中打开文件夹，比如在家目录新建Workspaces/VSCode作为工作空间。 扩展中安装中文语言包。 设置里强制显示空格和制表符。 Markdown 安装三个插件即可： Markdown All in One Markdown Preview Github Styling Markdown TOC C++ 测试GCC环境和安装GDB GCC即the GNU Compiler Collection，是GNU的一个编译器集合，包含多种编译器及相关工具。其中的gcc是GNU的C编译器(GNU C Compiler)；g++是GNU的C++编译器(GNU C++ Compiler)。也是GNU Compiler Collection的一部分，sudo pacman -S gcc即可。 使用gcc -v确认环境已正确配置。可以nano HelloWorld.cpp尝试写一个HelloWorld，通过g++ HelloWorld.cpp编译。编译完成后会生成一个a.out文档，~/a.out运行它。 除此之外，还需要一个GNU DeBugger即GDB。只需sudo pacman -S gdb即可安装。 在VSCode上运行程序 与在Windows上只需安装一个紫色程序即可高喊M$天下第一实现一切功能不同，在linux下，开发过程中需要使用一系列独立工具配合完成开发。VSCode只是一个文档编辑器，需要进行设置以告诉它怎么和其它工具（也就是前面说的几个）配合工作。 首先安装“C/C++”插件，这可以使它对.c和.cpp文件执行恰当的操作。除此之外，还有如下有用的插件应当安装： Code Runner：编译运行单个文件必备 Bracket Pair Colorizer：大括号变成彩虹色 RainBow Brackets：小括号变成彩虹色 Include Autocomplete：自动补全头文件 C++ Intellisense：不知道是干啥的，但是VSCode推荐了反正 完成之后打开之前的HelloWorld，右键可以运行。但是不能调试，并且头文件那里有可能会标红说找不到。 Code Runner默认使用的是“输出”，这个是只读的，设置中勾上“Run In Terminal”即可在终端中进行cin等操作。 在VSCode上调试程序 在调试选项卡中单击“没有配置”下拉菜单，添加配置，选择C++(GDB/LLDB)。此时会在当前工作区下新建一个launch.json文件并让你设置。另外接下来使用中还会有其它两个需要配置的文件生成。这里不等它们自动生成直接自己手动添加，效果似乎是一样的。 c_cpp_properties.json gcc -v -E -x c++ -搜索includePath，将结果填在下面的&quot;includePath&quot;处，注意添加/*和引号，中间用逗号分隔： 1&#123;2 \"configurations\": [3 &#123;4 \"name\": \"g++\",5 \"intelliSenseMode\": \"gcc-x64\",6 \"includePath\": [7 \"/usr/lib/gcc/x86_64-pc-linux-gnu/9.1.0/include/*\",8 \"/usr/local/include/*\",9 \"/usr/lib/gcc/x86_64-pc-linux-gnu/9.1.0/include-fixed/*\",10 \"/usr/include/*\"11 ],12 \"defines\": [],13 \"browse\": &#123;14 \"path\": [15 \"$&#123;workspaceFolder&#125;\"16 ],17 \"limitSymbolsToIncludedHeaders\": true,18 \"databaseFilename\": \"\"19 &#125;,20 \"cStandard\": \"c11\",21 \"cppStandard\": \"c++17\",22 \"compilerPath\": \"/usr/bin/gcc\"23 &#125;24 ],25 \"version\": 426&#125; 这样就解决了标红的问题。 launch.json： 此文件给出调试时的任务。 1&#123;2 \"version\": \"0.2.0\", //20193 \"configurations\": [4 &#123;5 //配置名称，将会在启动配置的下拉菜单中显示6 \"name\": \"(gdb) Launch\",7 //配置类型，这里只能为cppdbg8 \"type\": \"cppdbg\",9 //请求配置类型，可以为launch（启动）或attach（附加）10 \"request\": \"launch\",11 //将要进行调试的程序也就是前面task生成的那哥们的路径12 \"program\": \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe\",13 //程序调试时传递给程序的命令行参数14 \"args\": [],15 //设为true时程序将暂停在程序入口处16 \"stopAtEntry\": false,17 //下面俩不理解18 \"cwd\": \"$&#123;fileDirname&#125;\",19 \"environment\": [],20 //调试时是否显示控制台窗口21 \"externalConsole\": false,22 //miDebugger的配置，不太懂23 \"MIMode\": \"gdb\",24 \"miDebuggerPath\": \"/usr/bin/gdb\",25 //调试会话开始前执行的任务，要与TASK的名字对应26 \"preLaunchTask\": \"Build\",27 //不知道是干啥的28 \"setupCommands\": [29 &#123;30 \"description\": \"Enable pretty-printing for gdb\",31 \"text\": \"-enable-pretty-printing\",32 \"ignoreFailures\": true33 &#125;34 ]35 &#125;36 ]37&#125; tasks.json： 此文件指定调试前执行的任务。 注意在以下文件中网上文章常用的路径是诸如${workspaceFolder}（比较新）或${workspaceRoot}（比较旧）。这会使编译和调试时在工作目录下生成和调试文件。为了方便在工作目录下使用子文件夹（个人偏好），此处均使用${fileDirname}。 1&#123;2 \"version\": \"2.0.0\",3 \"tasks\": [4 &#123;5 //任务的名字6 \"label\": \"Build\",7 //该任务要执行的命令8 \"command\": \"g++\",9 //参数们，执行时每个之间会用空格空开10 \"args\": [11 \"-g\",12 \"$&#123;file&#125;\",13 //编译$&#123;file&#125;14 \"-o\",15 \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe\"16 //生成一个位于$&#123;fileDirname&#125;的$&#123;fileBasenameNoExtension&#125;.exe17 ],18 //下面的看不懂了先不管吧19 \"problemMatcher\": &#123;20 \"owner\": \"cpp\",21 \"fileLocation\": [22 \"relative\",23 \"$&#123;fileDirname&#125;\"24 ],25 \"pattern\": &#123;26 \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",27 \"file\": 1,28 \"line\": 2,29 \"column\": 3,30 \"severity\": 4,31 \"message\": 532 &#125;33 &#125;34 &#125;35 ]36&#125; 至此可以使用VSCode调试C++了。实际调试时如果使用单步调试，遇到cout等时会报/build/gcc/src/gcc-build/x86_64-unknown-linux-gnu/libstdc++-v3/include/bits/ostream.tcc: No such file or directory.。必应了一夜都没找到解决方法，结果谷歌了一下第二条结果就可完美解决： This happens because the ostream source file cannot be found. You can strip the libstdc++ library: 1sudo strip &#x2F;usr&#x2F;lib&#x2F;libstdc++.so.6 And then gdb will not try to open the source file and the error will not appear anymore. You can switch back to the unstripped version by reinstalling it with: 1sudo pacman -S gcc-libs 注意：此操作会导致所有程序退出，并且操作后需要重启，需要先保存并关闭所有其它内容！ 多文件的编译 通常会将头文件分为两个文件，分别用来写实现和声明。例如对于如下的文件结构： 某文件夹 main.cpp header.hpp header.cpp 主程序是main.cpp，header.hpp是一个头文件，但里面的类只是做了声明，具体的实现在header.cpp中。这个时候使用上面的配置就不管用了，因为在这个工程中两个.cpp都需要被编译，而上面的配置（无论是code-runner还是调试）只编译了main.cpp。 对于code-runner，打开VSCode的settings.json（不是.vscode下的那个针对Workspace的），添加一项&quot;code-runner.executorMap&quot;:{}，不出意外的话此时会自动填充好默认的各语言的配置文件。将&quot;cpp&quot;一项改为&quot;cd $dir &amp;&amp; g++ *.cpp -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,，也就是把具体的文件替换为了*.cpp即编译所有.cpp即可。 对于调试，将tasks.json中的&quot;${file}&quot;改为&quot;*.cpp&quot;会提示找不到文件，似乎是因为这里只能使用绝对目录，这特么就很尴尬了，尝试了加一个cd任务先进入文件夹再用*.cpp等很多方法研究了一晚上没找到合适的修改方法，暂时想调试这类工程只能手动在tasks.json中添加除主文件外的其它文件的绝对路径。 后记 在第一次升级系统后执行格式化文档报错。查看C/C++扩展的输出发现报错为： 1Formatting failed:2&#x2F;home&#x2F;oiljhihai&#x2F;.vscode&#x2F;extensions&#x2F;ms-vscode.cpptools-0.26.0&#x2F;bin&#x2F;..&#x2F;LLVM&#x2F;bin&#x2F;clang-format -style&#x3D;&#123; BasedOnStyle: LLVM, UseTab: Never, IndentWidth: 4, TabWidth: 4, BreakBeforeBraces: Allman, AllowShortIfStatementsOnASingleLine: false, IndentCaseLabels: false, ColumnLimit: 0, AccessModifierOffset: -4 &#125; -fallback-style&#x3D;LLVM -sort-includes&#x3D;0 -assume-filename&#x3D;&#x2F;home&#x2F;oiljhihai&#x2F;Workspaces&#x2F;VSCode&#x2F;HDU5396.cpp3&#x2F;home&#x2F;oiljhihai&#x2F;.vscode&#x2F;extensions&#x2F;ms-vscode.cpptools-0.26.0&#x2F;bin&#x2F;..&#x2F;LLVM&#x2F;bin&#x2F;clang-format: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory 可以看出是因为没找到libinfo.so.5。查了一下，这个东西是一个叫“ncurses”的包里的东西。pacman -Ss一下，大概是这次升级将ncurses5升级到了6，所以就找不到了。 pacman -Ss中有两个跟nurses5有关的，先装了第一个看起来像是32位版的sudo pacman -S lib32-ncurses5-compat-libs，没什么用；又试了第二个sudo pacman -S ncurses5-compat-libs，问题解决。 Python 安装插件 Python Python-autopep8 再结合之前已经装好的Code Runner，就可以运行py程序了。 运行过程中VSCode会提示要装其它什么东西，装就行了，可能网不好会失败几次。 右键格式化，提示装些东西，选autopep8比较好用。 安装Anaconada 在https://repo.continuum.io/archive/下载.sh文件，在文件目录bash xxxx.sh。安装没问题的话which python可以得到路径。由于路径被配置在了~/.bashrc，需要source ~/.bashrc一下。 注意下载Anaconda3，一开始下成了2之后还有点小麻烦……由于是先装了2，再装了3，3的路径就没添加上，所以卸掉2后按升级的方法重装了3：bash xxxx.sh -u；卸载的方法是删掉安装文件夹并删掉bashrc中自动生成的那一段信息。 在VSCode中打开一个.py，下方显示文件类型的地方点一下，选配置，在json中添加Anaconda的路径和其它设置选项： 1\"python.pythonPath\": \"&lt;which python的结果，类似/home/oiljhihai/anaconda3/bin/python，系统自带的py位于/user/bin/python&gt;\",2 \"python.autoComplete.extraPaths\": [3 \"&lt;应该差不多是形如~/anaconda3/lib/python3.7/site-packages，找一下这个文件夹&gt;\"4 ],5 \"python.linting.flake8Enabled\": false,6\"python.formatting.provider\": \"autopep8\",7//禁用自动换行8 \"python.formatting.autopep8Args\": [9 \"--max-line-length=200\",10 ],11 \"python.testing.unittestEnabled\": true,12 \"python.testing.pytestEnabled\": true,13 \"python.testing.nosetestsEnabled\": false, 安装OpenCV 在终端进入Python，运行： 1import pip._internal2print(pip._internal.pep425tags.get_supported()) 可以查看当前py版本所支持的包。在https://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv或清华镜像https://pypi.tuna.tsinghua.edu.cn/simple/opencv-python/找到符合条件的包，丢到前面的&quot;python.autoComplete.extraPaths&quot;:填的目录下直接pip install opencv_python-xxxxxx.whl即可。 以下不用看，把opencv版本搞错了。 conda install --channel https://conda.anaconda.org/menpo opencv3即可安装，但过程中报错“Unsatisfiable Error”。大体意思是版本不对应。可以根据详细的报错信息判断出目前的Python是3.7，而openCV只支持到3.6。解决办法是安装3.6的环境conda create -n python3.6 -c menpo configparser。 安装完毕后电脑上同时有python3.7和3.6，其中3.7位于前面说的位置，3.6位于~/anaconda3/envs/python3.6/bin/python，bashrc只记录了3.7的路径。于是通过conda activate python3.6进入3.6的环境，再次安装即可。安装完毕后python进入写python代码模式，import cv2不报错就是装好了。 conda deactivate退出python3.6。 进入VSCode，此时VSCode还在用3.7的路径，所以不能写openCV。用3.6的路径替换一下就OK了。这时运行.py还是先在终端默认的3.7运行，报错后VSCode会自动根据设定的路径conda activate python3.6。 通过： 1import cv22img = cv2.imread('~/Workspaces/VSCode/test/test.jpeg',cv2.IMREAD_COLOR)3cv2.imshow('image',img)4cv2.waitKey(0)5cv2.destroyAllWindows() 测试。然而如果用相对路径会报错“OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in imshow”，没查到为啥（另外网上说中文路径、图片不在工程文件夹内都会报错。这也太WEAK了吧……）。但是这样的话目录啥的变了直接凉凉啊，研究半天，这里可以用路径获取+格式化输出： 1import os2path=os.path.dirname(os.path.abspath(__file__))3img0=cv2.imread(r'%s/mipha.jpg'%path) Hexo+GithubPages博客配置 Hexo基本环境的配置 hexo依赖于git和node.js。 manjaro自带git，可git查看详情。 hexo官方建议使用node.js的管理工具nvm安装node.js（nvm是管理node.js的版本的工具，npm是node.js管理它的包的工具）。尝试了官方https://github.com/nvm-sh/nvm给出的curl -o- https://raw.githubusercontent.com/creationix/nvm/v.xx.xx.xx/install.sh | bash（xx为当前版本号）命令，访问会被拒绝。经测试可用 1git clone https://github.com/creationix/nvm.git ~/.nvm &amp;&amp; cd ~/.nvm &amp;&amp; git checkout `git describe --abbrev=0 --tags` 命令安装，可以看出这里是把它装到了/.nvm下。完成后在~/.bash_profile~【更新：~/.bashrc下（否则重启终端后需要source ~/.bash_profile，不然会提示没有npm这个命令。官方教程说~/.bashrc, ~/.zshrc, ~/.bash_profile, ~/.profile都可以】中添加环境变量： 1export NVM_DIR=\"$HOME/.nvm\"2[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\"3export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node 注意地址与安装地址相匹配。最后一行是淘宝镜像源，根据需求添加，也可在调用npm时NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm install node。保存后source ~/.bash_profile即可使用nvm和node命令。 然后使用NVM安装node.js，只需nvm install node，这样npm也可以使用了。 进行一下设置： 1npm config set user 02npm config set unsafe-perm true3npm config set registry https://registry.npm.taobao.org 不设置前两个的话会报Permission denied，进度条卡在最开始不动，最后一个是镜像源。至此可以使用npm命令下载node包。 Hexo的安装与初始化 npm install -g hexo-cli，可使用hexo -v查看安装结果。 从github上下载网页的代码hexo init &lt;folder&gt;后在&lt;folder&gt;/安装所需的依赖npm install，之后hexo -s就可以看到网页了。考虑使用~/blog作为文件夹。 写博客 在Hexo目录下hexo new [类型] &lt;&quot;博客名&quot;&gt;，类型缺省时为新建一篇博客post（另两种是新建页面page和新建草稿draft）。这其实就是将模板文件blog/scaffolds/对应类型的内容复制过来并重命名为博客名.md。默认post新建博客类型的模板为以下内容： 1---2title: &#123;&#123; title &#125;&#125;3date: &#123;&#123; date &#125;&#125;4tags:5--- 其中前两项生成时会自动填写，tags一项的填写格式为 1tags: [标签1,标签2,...]2或3tags:4 - 标签15 - 标签26 - …… 编辑保存后hexo g即可。运行hexo s可查看。 除默认配置外，有必要添加如下内容。 categories:，分级目录属性。与tags属性不同，其可以划分父子级关系。例如： 1---2title: 怎么拿长老知识3...4categories: 5 - 游戏6 - 遗迹：灰烬重生7...8--- &lt;!--more--&gt;，此标签之后的部分将被隐藏，点进去才能看，对NexT很有用。 ~~thumbnail:（如果主题支持文章封面），后跟图片链接即可。经测试，使用450*212的图片作为主题“Hueman”的封面可以获得比较好的画质，体积也只有20至30KB。~~之前用的Hueman，现在NexT不支持，不过可以在&lt;!--more--&gt;前放，格式更随意，横向两百多像素效果就不错，接着用212吧，嗯，水的华氏温标沸点……算是个整数？ updated: 1569245658000更新日期。 最终效果如下： 1---2title: &#123;&#123; title &#125;&#125;3mathjax: false4date: &#123;&#123; date &#125;&#125;5updated: &#123;&#123; date &#125;&#125;6tags: 7 - 8categories: 9 - 10---1112![]()1314&lt;center&gt;&lt;/center&gt;1516&lt;!--more--&gt; 【！注意！】 任何行内式中不要出现两个同方向大括号连用的情况！否则会报Nunjucks Error，要空格分开！ 对于一些具有一定私密性的博客，可通过安装插件npm install hexo-blog-encrypt --save后在博客配置文件写入： 1encrypt:2 enable: true 后在要加密的文章添加password: xxxxx加密。与直接通过js代码加密不同，这种加密方式更难破解，不会出现看下网页源码就知道密码的情况。 不过还是没啥安全性就是了，毕竟是静态页面。 站点的配置 在blog/有一_config.yml文件，其保存有站点相关的设置。 开头是Site模块： 1# Site2title: 标题，会显示在浏览器标签栏上3subtitle: 副标题4description: 描述5keywords:6author: 作者7language: 语言（简中：zh-CN；不同主题不同，例如NexT中似乎叫zh-Hans）8timezone: 网站时区，默认使用电脑的无需改动 剩下的似乎不是太用改，例如URL模块似乎是当网站放在子目录下时用的等等。 当此配置文件与主题的配置文件冲突时，此配置文件将覆盖主题的配置文件。 hexo的文章是.md经过swig转换成的html，生成的html中的空格和注释会影响JS的性能，可在blog/安装hexo自带的neat插件npm install hexo-neat --save进行压缩。安装插件后在站点配置文件中添加： 1# hexo-neat2# 全局开关3neat_enable: true4# 压缩html5neat_html:6 enable: true7 exclude:8# 压缩css 9neat_css:10 enable: true11 exclude:12 - '**/*.min.css'13# 压缩js14neat_js:15 enable: true16 mangle: true17 output:18 compress:19 exclude:20 - '**/*.min.js'21 - '**/jquery.fancybox.pack.js'22 - '**/index.js' exclude项是跳过压缩的文件。 【更新】neat突然会报错了，暂且设为false。 主题的配置 如果想要换主题，首先找到一个主题，下载可得一个压缩包解压到themes文件夹下即可。注意很多主题同时会有WordPress和Hexo两个版本，不要下错。 曾经长期使用Landscape（2018年）和Hueman（2019年）两个主题。Landscape作为默认主题，简约大气，自己改一下图片啊配色啊啥的相当不错，但支持的功能略少；Hueman算是杂志风格，支持的功能也很多，但总感觉侧边栏和选项卡功能重复，不够简约，而且一些符号显示会出错，默认的代码块也很丑。目前使用最大众化的NexT主题。 该主题仓库位于这里，参照说明安装即可。 使用主题文件夹下多出的文件夹的名字替换掉博客根目录下的_config.yml中theme项的内容后hexo g即可，注意theme:后应当有一个空格。 这里是一份较早前版本的参考文档，具有一定参考性，但已有部分设置与最新版本有偏差。 主题的_config.yml需要设置的项主要有一下一些： 修改风格项Schemes。 为侧栏增加标签页、分类页和关于页，将menu下对应项的注释取注，并按上述文档生成前两者页面即可。后者通过hexo new page &quot;about&quot;，在其内写入： 1---2title: about3date: 2019-09-23 18:13:294---5正文 来实现。 显示当前浏览进度scrollpercent置为true。 启用本地搜索只需npm install hexo-generator-searchdb --save并设置： 1# Local search2local_search:3 enable: true 添加： 1search:2 path: search.xml3 field: post4 format: html5 limit: 10000 设置头像只需简单修改Sidebar Avatar字段。 这个主题还提供了评论功能，有许多可选的服务提供商，不过没什么卵用。国内的要么倒闭了要么需要实名制，国外的又要扶墙…… 【更新】发现了一个比较好用的服务商，棒子的“来必力”。只需正常步骤注册即可获得一段代码，用此代码替换掉主题中的layout/comment/livere.ejs中的内容，再在主题配置文件中禁用comment项下的所有评论工具，在comment项外，比如上面一行添加livere_uid: xxxxxxxx，其中xxxxxxx为获取的代码中提供的UID。再将主题中的layout/common/article.ejs中最后一行&lt;%- partial('comment/index') %&gt;改为&lt;%- partial('comment/livere') %&gt;即可。【更新】划去部分针对Hueman。NexT只需在主题配置文件下找到livere_uid:填上代码中的UID即可。 添加网站访问数统计只需在xx-analysis项添加从分析网站比如百度分析、谷歌分析等等网站获得的哈希值即可。注册帐号后根据提示操作即可获得一段JS代码，哈希值在其中。但这类网站只能站主登录进去查看自己网站的访问情况。若想在网站中显示访问数，可使用不算子，注意footer文件的位置可能与官方描述有差别。不蒜子自身只提供标签与数字，具体内容由用户编辑。使用官方给出的简易程序对footer做如下修改将统计显示在页脚：【更新】划去部分针对Hueman，Next集成不算子，只需调整busuanzi_count项即可。 如果想要开启RSS订阅，首先需要安装RSS插件npm install hexo-generator-feed --save，并在站点配置文件中添加RSS支持： 1# RSS订阅支持2plugin:3 - hexo-generator-feed4feed:5 type: atom #RSS的类型(atom/rss2)6 path: atom.xml #文件路径,默认atom.xml/rss2.xml7 limit: 20 #展示文章的数量,0或false展示全部 最后将主题配置文件中的rss项改为rss: /atom.xml可开启RSS订阅，可在public/见atom.xml。 字体配置先找到font并启用，这样就可以自定义字体怎么用而不是通过默认的谷歌字库外链加载默认字体。全局设置使用思源黑体，谷歌和奥多比联合开发，品质保证！code要以等宽字体显示所以需要设置为等宽字体，“Fira Code”虽然样子只能说还行，但提供了极好的连字模式，如果只是想表示\\(\\rightarrow\\)之类可以直接代码块-&gt;，非常方便。缺点是会给读者造成误解，管它呢，这破博客本身就是写了自嗨的。可选择字库外链，中科大的地址是//fonts.lug.ustc.edu.cn，速度勉强，偶尔会崩。 部署至GitHub 安装hexo的插件：npm install hexo-deployer-git --save。 在github中建立一个以自己名字命名的仓库，建好后将_config.yml中的`deploy项替换为： 1deploy:2 type: git3 repository: 建好仓库后给出的地址中git格式那个复制一下粘过来4 branch: master 首先配置git用户名git config --global user.name &quot;&lt;用户名&gt;&quot;和邮箱git config --global user.email &quot;&lt;邮箱&gt;&quot;，这会生成一个~/gitconfig文件，想改的话直接改这个文件就行。然后获取SHH密钥ssh-keygen -t rsa -C &quot;&lt;前面的邮箱&gt;&quot;，一路回车即可，之后会生成一个~/.ssh文件夹，其中有一个私钥id_rsa和一个公钥id_rsa.pub，将公钥添加至github。从github网页右上角的下拉菜单里的settings中添加。 如果ssh -T git@github.com后（第一次连接时中间需要yes一下）出现You've successfully authenticated, but GitHub does not provide shell access.说明OK了，使用hexo d即可部署网页。 域名解析 终端ping -4 用户名.github.io可以获得GitHub Pages的服务器地址。 在提供域名解析的网站的控制台，设置主机记录www，记录类型为A，记录值为刚才ping得的地址。再设置一条主机记录@，记录类型为CNAME，记录值是用户名.github.io。这两条分别意味着将购买的域名指向一个IPv4地址和另一个域名。 在blog/source/建立CNAME文件，写入购买的域名。进入GitHub中的博客仓库。在仓库的Setting-&gt;Custom domain添加域名后保存即可。 使用LaTex语法 在主题配置文件中开启“mathjax”一项为true即可使用LaTex语法，某些主题可能还需要将“math”开启，可选择是每个页面都开启还是需要手动开启。 注意，与正常使用Markdown不同，Hexo不支持LaTex，mathjax并非对.md渲染，而是渲染Hexo生成的Html。因此要确保Hexo不会误将LaTex标记渲染为Html标签。一种方法是在公式块中使用Markdown语法符号时使用转义，更一劳永逸的方法是更换Hexo的渲染引擎。 默认的渲染引擎“hexo-renderer-marked”可通过npm uninstall hexo-renderer-marked --save卸载，npm install hexo-renderer-pandoc --save，即可更换成另一个表现较好的引擎。与许多人推荐的npm install hexo-renderer-kramed --save相比，该引擎表现更好，无需额外修改一些配置文件。 【更新】发现无法渲染形如\\(\\xRightarrow[aaa]{bbb}\\)的格式。暂时用\\(\\Rightarrow_{aaa}^{bbb} \\Rightarrow\\)这样子代替。 看板娘 可以使用 Live 2D 为博客增添一个 2D 角色。 首先检查package.json里是否已安装&quot;hexo-helper-live2d&quot;，有的话可以先npm uninstall hexo-helper-live2d，官方称“THIS PACKAGE IS DEPRECATED BECAUSE IT WON'T ADD DEPENDENCIES ON YOUR PRODUCTION ENVIRONMENT”。 安装npm install --save hexo-helper-live2d后node_moduels/会生成配置文件夹live2d-widget。 https://github.com/xiazeyu/live2d-widget-models.git提供了可用的模型，前缀为live2d-widget-model-haru的模型需要npm install live2d-widget-model-haru支持。 以一只黑猫的模型为例，npm install live2d-widget-model-hijiki后配置博客站点配置文件_config.yml，添加： 1live2d:2 enable: true3 pluginModelPath: assets/4 model:5 use: live2d-widget-model-hijiki #模板目录，在node_modules里6 display:7 position: right #位置只能调上下和靠左靠右 具体多靠左多靠右不能调8 width: 200 #大小9 height: 290 #上下位置10 mobile:11 show: false #是否在手机进行显示 即可。这个位置大小是NexT的那个两栏的模式+黑猫我精心调之后觉得最合适的。 尾声 完成以上配置后的manjaro已经可以正常使用了。可以从优化中设置GNOME桌面的样式——不过默认外观已经很好看了，但是在拓展中可以启用GNOME的一些有用插件，例如显示在上方工具条中的许多有用工具。 Windows系统中的字体可以直接拿过来安装，非常方便；如果只是在Libre Office下用的话只拷贝到～/.config/libreoffice/4/user/fonts下也可以在Libre Office中用。如果没有fonts目录新建即可。 若报未找到strip分割所需的二进制文件，似乎是由于缺少编译器，sudo pacman -S core/binutils可安装酷睿的binutils工具集，或安装gcc。","categories":[{"name":"戏法","slug":"戏法","permalink":"http://mechanicalmind.cn/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"Manjaro","slug":"Manjaro","permalink":"http://mechanicalmind.cn/tags/Manjaro/"},{"name":"Hexo","slug":"Hexo","permalink":"http://mechanicalmind.cn/tags/Hexo/"},{"name":"VSCode","slug":"VSCode","permalink":"http://mechanicalmind.cn/tags/VSCode/"},{"name":"Anaconda","slug":"Anaconda","permalink":"http://mechanicalmind.cn/tags/Anaconda/"}]}]}