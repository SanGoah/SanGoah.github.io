{"meta":{"title":"Mech_Mind‘s blog","subtitle":null,"description":"敲键盘 按快门 巡星空","author":null,"url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-09-23T10:13:29.000Z","updated":"2019-10-16T06:22:05.207Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"欢迎您，访客。 本博客为Mech_Mind备份个人笔记等的空间。 本博客存在的意义既不是帮助他人，也不是分享生活，因此也不会提交给搜索引擎收录。如果您偶然点击进来，便是我们的缘分。如果其中的内容对您有些许帮助，欢迎您常来看看；当然，本人能力一般、水平有限，所写内容多是粗浅鄙陋之零碎，望能博君一笑。 这方小天地分为以下一些归档： 戏法：这里记录着必要环境的配置——譬如法师之手的法术模型。虽然没什么技术含量，但总归是个开始。 前端：虽然不打算从事相关工作，不过还是认真接触一下吧。 丧志：玩物。"},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2019-12-06T15:34:19.153Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2019-12-06T15:32:04.247Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Manjaro Linux下配置DosBox+MASM汇编环境","slug":"Manjaro-Linux下配置DosBox-MASM汇编环境","date":"2019-11-24T08:14:56.000Z","updated":"2019-12-08T16:00:00.000Z","comments":true,"path":"2019/11/24/Manjaro-Linux下配置DosBox-MASM汇编环境/","link":"","permalink":"http://yoursite.com/2019/11/24/Manjaro-Linux%E4%B8%8B%E9%85%8D%E7%BD%AEDosBox-MASM%E6%B1%87%E7%BC%96%E7%8E%AF%E5%A2%83/","excerpt":"坑待填","text":"坑待填 sudo pacman -S dosbox mount c ~/Workspaces/MASM MASM5.0，更高的版本需要Win行命令提示符环境才能运行 masm hw.asm 文件名长度不能超过8 link hw hw","categories":[{"name":"戏法","slug":"戏法","permalink":"http://yoursite.com/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/%E6%B1%87%E7%BC%96/"},{"name":"DosBox","slug":"DosBox","permalink":"http://yoursite.com/tags/DosBox/"},{"name":"MASM","slug":"MASM","permalink":"http://yoursite.com/tags/MASM/"}]},{"title":"Manjaro Linux下使用opencv_traincascade","slug":"Manjaro-Linux下使用opencv-traincascade","date":"2019-11-18T08:34:19.000Z","updated":"2019-11-17T16:00:00.000Z","comments":true,"path":"2019/11/18/Manjaro-Linux下使用opencv-traincascade/","link":"","permalink":"http://yoursite.com/2019/11/18/Manjaro-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8opencv-traincascade/","excerpt":"使用opencv_traincascade训练实现车辆检测。","text":"使用opencv_traincascade训练实现车辆检测。 OpenCV中有个神奇的AdaBoost，通过读入一个xml即可识别出目标区域。此物中文名唤“级联分类器”，“级联”指它由简单分类器级联组成，通过所有分类器的区域即为目标区域。训练时通过对样本的一定操作可生成样本的Haar/LBP/HOG等特征，检测时遍历待识别图片各区域进行特征匹配。 训练 文件准备 训练文件夹的结构应当如下： data（训练结果文件夹） vec（样本集文件夹） bg（背景集文件夹） vec.bat（样本集相关信息） vec.vec（样本集相关信息） bg.txt（背景集相关信息） opencv_createsamples（生成pos.vec的工具） opencv_traincascade（训练的工具） 其中这些东西的名字都可以变。 首先建立训练文件夹和三个子文件夹，并分别放入样本集图片和背景集图片。样本的大小大约应当几十见方，太大会爆栈；背景应当远大于训练图片，几百见方，且内容较复杂。这是因为程序将训练图片作为滑动窗口在背景上滑动来采集训练图像，如果无法采集到足够多的样本就会报Train dataset for temp stage can not be filled. Branch training terminated.错误。 关于样本集与背景集的比例，有帖子认为一比三是比较合适的，我理解是生活中没有样本的情况（背景）多于有样本，但如果给太多背景影响训练效率。 放好后在训练文件夹下进入终端，ls ./bg/&gt;bg.txt生成背景集相关信息，ls ./vec/&gt;vec.bat生成样本集相关信息。自动生成的文件最后有个空行需要删掉。有帖子指出这里的文件对换行格式也有要求，实测VSCode中的“LF”格式没问题。 此时生成的两个文件内应当是形如： 1xxx.xxx2xxx.xxx 将之改为： 1vec&#x2F;xxx.xxx2vec&#x2F;xxx.xxx 和 1bg&#x2F;xxx.xxx2bg&#x2F;xxx.xxx 这是因为待会调用训练程序时无法指定图片地址，所以地址要在这两个文件中显式指出。 除此之外，还要指出样本图片（背景不需要）的该样本数目、起始坐标和表示样本宽高 1vec&#x2F;xxx.xxx 1 0 0 xx xx2vec&#x2F;xxx.xxx 1 0 0 xx xx 那两个工具在电脑里查找一下，通过anaconda装的就是在anaconda文件夹里某个角落，复制过去即可。 创建样本 ./opencv_createsamples -vec vec.vec -info vec.bat -bg bg.txt -w xx -h xx 注意图片尺寸要对，否则报Error: Assertion failed (_img.rows * _img.cols == vecSize)。 这里的工具是直接拉过来用的，配套环境可能跟不上。如果报错他想找个啥库找不到之类，以libopencv_core.so.3.2为例： Find the folder containing the shared library libopencv_core.so.3.2using the following command line. 1&gt;sudo find &#x2F; -name&quot;libopencv_core.so.3.2*&quot; Then I got the result: /usr/local/&gt;lib/libopencv_core.so.3.2. Create a file called /etc/ld.so.conf.d/opencv.conf and write to it the path to the folder where the binary is stored.For example, I wrote /usr/local/lib/ to my opencv.conf file. Run the command line as follows. 1sudo ldconfig -v Try to run the test binary again. 生成vec.vec就是好了。 可能需要给工具一个执行权限。 训练 ./opencv_traincascade -data data -vec vec.vec -bg bg.txt -numPos xxx -numNeg xxx -numStages 20 -w xx -h xx -minHitRate 0.9999 -maxFalseAlarmRate 0.5 -mode ALL，其中numPos和numNeg是每次训练使用的样本数量，而非你提供了多少样本。这个数量应当足够多（样本数应当大于10，否则报Cascade classifier can’t be trained. Check the used training parameters.），和提供的数量一样保持一比三，并且少于提供的样本数（否则报Traincascade Error:Bad argument(Can not get new positive sample.The most possible reason is insufficient count of samples in given vec-file.）；numStage是训练的级数，默认为20；minHitRate指“分类器的每一级希望得到最小检测率”，一般0.9999；maxFalseAlarmRate，最大虚警率，“影响弱分类器的阈值，表示每个弱分类器将负样本误分为正样本的比例”，一般默认值为0.5。还有其它贼多参数，用到再去查吧。 官方给的numPos和numNeg计算方法是vec-file number &gt;= (numPos + (numStages-1) * (1 – minHitRate) * numPos) + S。vec-file number是指提供的样本数。 训练过程中经常报Train dataset for temp stage can not be filled. Branch training terminated.，排除背景信息那个文本文档格式问题的话就是需要更多更大更复杂的背景的意思。 检测 1xx = cv2.CascadeClassifier(&lt;xml路径&gt;)2xxx = xx.detectMultiScale(&lt;图片&gt;, scaleFactor=1.1, minNeighbors=55, minSize=(10, 10),maxSize=(90,90),flags=cv2.CASCADE_SCALE_IMAGE) scaleFactor指每次检测区域扩大多少，1.1就是每次扩大百分之十；minNeighbors大概意思是一个目标区域附近允许有多少目标区域——因为往往对同一个目标，程序会识别出许多临近的目标区域，看情况调调这个参数留一个就行。","categories":[{"name":"中医","slug":"中医","permalink":"http://yoursite.com/categories/%E4%B8%AD%E5%8C%BB/"},{"name":"分类器","slug":"中医/分类器","permalink":"http://yoursite.com/categories/%E4%B8%AD%E5%8C%BB/%E5%88%86%E7%B1%BB%E5%99%A8/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"AdaBoost","slug":"AdaBoost","permalink":"http://yoursite.com/tags/AdaBoost/"},{"name":"cascade","slug":"cascade","permalink":"http://yoursite.com/tags/cascade/"}]},{"title":"有关摆脱祸乱之源的尝试","slug":"有关摆脱祸乱之源的尝试","date":"2019-11-11T09:02:23.000Z","updated":"2019-11-10T16:00:00.000Z","comments":true,"path":"2019/11/11/有关摆脱祸乱之源的尝试/","link":"","permalink":"http://yoursite.com/2019/11/11/%E6%9C%89%E5%85%B3%E6%91%86%E8%84%B1%E7%A5%B8%E4%B9%B1%E4%B9%8B%E6%BA%90%E7%9A%84%E5%B0%9D%E8%AF%95/","excerpt":"早睡早起的那些事。","text":"早睡早起的那些事。 因为整天昏昏欲睡，玩Dota的同学称我为啥啥之主记不清了，刚刚查了下可能是叫祸乱之源？ 知乎上有一些类似“如何保持精力旺盛”的问题，答者众，然而翻翻回答，要么是一些傻逼励志书的类似读书笔记的东西（这些书有一个算一个都是傻逼，引用这玩意的答主也是傻逼，有不同意见的请将本网址添加至C:\\WINDOWS\\system32\\drivers\\etc\\host，自己搭博客写字的好处就是特么的不用管这些友善度），要么是一些莫名其妙似是而非八成就是为了推销保健品的科学术语使劲堆，还有就是分好几十条小tips每一条都令人无法理解这玩意有啥用的例如想着待会你要去吃个啥啥一直想吃的小点心然后你就精神了我觉得我想着待会就能去把你打一顿了比较有用点。 与其看网上这些编出来骗赞的“经验贴”，不如自己实验。毕竟就算真的是答主发自肺腑的经验之谈，由于人与人之间生活环境、个人身体条件巨大的差别恐怕也很难直接套用，有个答主说他找了女朋友就好了，一想woc真特么有道理，问题是国家不给发我去哪找，充一万话费送吗那我充十万。 1. 睡眠 精力不好最大的表现就是昏昏欲睡，所以第一反应是研究睡眠。 1.1. 时间 目前11点到2点间睡，具体没规律。典型的情况是11点半上床，十二点半或更晚些睡着——话说怎么知道自己是几点睡着的啊百度搜出来全是怎么知道自己电脑是32位还是64位。早晨会在上课前半小时起床，无论是几点的课。如果上午没课的话就11点到2点起，不一定。 如果上午没课睡到中午自然是没有午睡的，否则会有。时间大致是从回到宿舍睡到再不起就迟到，时间根据季节、课表可能从不到20分钟到3小时以上。 早晨或中午醒来后通常会感觉没睡够，大部分情况下会坚持不睡去上课也就慢慢清醒些，但如果决定趴倒接着睡的话睡他个两节课也无压力。所以必修课选睡选修课必睡——可能是在教室睡也可能是在宿舍，取决于教室与宿舍的距离。 1.2. 入睡情况 午觉通常能迅速睡着，晚上则大概率不可以。说起来我应该算是夜里精神的一类人，即使在全国大学生天文爱好者——勉强算是世界上最能熬夜的一批人——云集的活动里也是少数能连续通宵的……不过毕竟野外天冷，刺激肾上腺素分泌，而且鼓捣些器材啥的也不算废脑子，熬夜难度比不上修福报的程序员。 晚上临睡会刷B站，上床后入睡前没有玩手机的习惯，但通常会听些什么，郭德纲、唱间小姐姐直播、音声故事和ASMR都有听，主要是为了遮蔽舍友闹出的动静。大晚上的跟那洗衣服洗头也就算了，一会嘿嘿嘿嘿一会哈哈哈哈一会输钱了砸桌子的。 1.3. 计划 睡午觉可能是导致晚上难以迅速入睡的重要原因，大约从高一或略微更早养成的这个习惯，考虑戒掉。其实从三五天前起就开始强制自己不睡午觉了——上课也不睡——目前感受不太好，尤其是下午的课，别说听课，连网络小说都看不太懂了，晚上会有好转，写写作业看看书的智力水平勉强能保持。再过一段时间看看。 【W+1】好像现在影响不大了。但还是有影响而且想睡。试试中午看人文社科类的书。 不睡午觉的话晚上的睡眠时间可能需要相应增加。暂且尝试11点前出现在床上，如果不睡午觉达成了晚上可以快速入眠的目的的话就是可以睡7个半到八个小时，早晨早起些，把晚上刷B站放在早晨，也算是刺激刺激大脑。 另外有人整天讲什么蓝光什么褪黑素什么的，强烈怀疑是为了卖保健品。听说蓝色可以使人冷静而理性，所以码代码时把编辑器调成深蓝色背景，蓝色够多吧抑制褪黑素吧，照样困。 2. 饮食 2.1. 概况 早餐10点吃（起得晚来不及只能抽课间），1点以后吃午餐（人少不用排队）。晚餐5点到7点间吃，内容都是食堂标配。 基本不喝牛奶，每天都吃水果。 2.2. 计划 有一些人提到饮食的影响，尤其是具体到午睡时比较常见的说法是“中国人午餐吃米高碳水血糖高所以下午困”，早餐上的建议与之类似，也是高蛋白低碳水啥啥啥的。另外也有讨论高油盐、喝水少的影响的。 高碳水、高油盐这些问题几乎不可能解决，食堂里能顶饱的也就是米饭了，而肉类主要是炸鸡腿、炸鸡排、炸鸡块，少见的家常做法的肉通常比较咸。另外——某些人每顿饭都强调要低碳水、高蛋白——这是不把膳食指南放在眼里吗？ 多喝水是容易做到的。另外可以一定程度上考虑早晨和中午时减少碳水摄入以期在下午获得更好的表现。 考虑早餐分开两次在8点和10点吃茶鸡蛋，午餐以肉类为主，已屯三箱王光烧牛肉，晚餐照常。 【W+1】午餐只吃肉胃受不了，挺难受的。王光烧牛肉的油冬天会冻成粉状，超级恶心。 保持吃水果的习惯，另外临睡加一包奶。 吃上的开销几乎不会增加。 3. 运动 3.1. 概况 通常不专门运动，但学校大，日常上课破万步。 3.2. 计划 把每天晚上刷B站的时间用来跑步试试。 【W+1】也不一定跑步，总之晚上不要娱乐，放在早晨起来不太清醒的时候加速清醒。","categories":[{"name":"柴米","slug":"柴米","permalink":"http://yoursite.com/categories/%E6%9F%B4%E7%B1%B3/"}],"tags":[]},{"title":"虚拟存储器","slug":"虚拟存储器","date":"2019-11-11T07:35:40.000Z","updated":"2019-11-10T16:00:00.000Z","comments":true,"path":"2019/11/11/虚拟存储器/","link":"","permalink":"http://yoursite.com/2019/11/11/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/","excerpt":"坑待填","text":"坑待填 1 +-----------------------+ +-----------------------+2 |1 2 3 4 1 2 5 1 2 3 4 5| |1 2 3 4 1 2 5 1 2 3 4 5|3++----------------------++ ++----------------------++4|1|1|1|4|4|4|5| | |5|5| | |1|1|1|1| | |5|5|5|5|4|4|5| |2|2|2|1|1|1| | |3|3| | | |2|2|2| | |2|1|1|1|1|5|6| | |3|3|3|2|2| | |2|4| | | | |3|3| | |3|3|2|2|2|2|7+-----------------------+ | | | |4| | |4|4|4|3|3|3|8 1 2 3 4 5 6 +-----------------------+9 1 2 3 4 5 61011 +-----------------------+ +-----------------------+12 |1 2 3 4 1 2 5 1 2 3 4 5| |1 2 3 4 1 2 5 1 2 3 4 5|13++----------------------++ ++----------------------++14|1|1|1|4|4|4|5| | |3|3|3| |1|1|1|1| | |1| | |1|1|5|15| |2|2|2|1|1|1| | |1|4|4| | |2|2|2| | |2| | |2|2|2|16| | |3|3|3|2|2| | |2|2|5| | | |3|3| | |5| | |5|4|4|17+-----------------------+ | | | |4| | |4| | |3|3|3|18 1 2 3 4 5 6 7 +-----------------------+19 1 2 3 42021 +-----------------------------------------------------------------+22 |5 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 5 0 1 |23+-+---------------------------------------------------------+-------+24|51|51|51|21| |20|01|00|21| |20|31|21|20| |01| |00| | |25| |01|01|00| |31|31|30|30| |01|01|00|11| |11| |10| | |26| | |11|10| |10|10|41|41| |41|41|40|40| |40| |51| | |27+-----------------------------------------------------------+28 1 2 3 4 5 6 7 8 9 10 11","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://yoursite.com/categories/%E6%B7%B1%E8%93%9D/"},{"name":"操作系统","slug":"深蓝/操作系统","permalink":"http://yoursite.com/categories/%E6%B7%B1%E8%93%9D/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Struts2中Action的几种传值方式","slug":"Struts2中Action的几种传值方式","date":"2019-11-07T12:09:33.000Z","updated":"2019-11-07T12:09:33.000Z","comments":true,"path":"2019/11/07/Struts2中Action的几种传值方式/","link":"","permalink":"http://yoursite.com/2019/11/07/Struts2%E4%B8%ADAction%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/","excerpt":"struts2中，传统的servlet中的request和response传递参数法仍可使用（但略有不同），并且增加了船新的传值方式。","text":"struts2中，传统的servlet中的request和response传递参数法仍可使用（但略有不同），并且增加了船新的传值方式。 0. 环境 Tomcat 9.0 MyEclipse 2017 ci10 Struts 2.5.20 Manjaro Linux 18.1.0 JDK 1.8u221 1. request/response 为避免与Servlet API耦合在一起，方便Action类做单元测试，Struts2对HttpServletRequest、HttpSession、ServletContext进行了封装，构造了三个Map对象来替代这三种对象。注意，这三个对象与Servlet API中的三个对象是相同的，即，在Action中放入Session中信息，在JSP页面中是可以读出来的。 在Action类中引入上下文类ActionContext，使用getContext()实例化一个对象，就可以通过这个对象获取session和application的map对象，而ActionContext对象本身包含了request的map对象。 向它们中添加属性只需使用put()方法，若向request添加属性，只需向ActionContext对象中添加。 2. get/set 之前带有传值的示例就是用的这种方式。在action类中定义与jsp页面中上传参数的东西同名的私有成员变量并生成get/set方法即可直接使用，贼方便。 这种方法的进阶版是传JavaBean——而不是一个个传数据。也非常简单，唯一需要注意的是jsp页面中上传参数的东西的name必须是&lt;JavaBean的名字&gt;.名字。 3. 示例 一个学生登录的界面。用户在index.jsp填写表单，提交后跳转至欢迎界面，在欢迎界面显示输入的信息。 3.1. index.jsp 1&lt;body&gt;2 &lt;h1&gt;使用JavaBean传递参数：&lt;/h1&gt;3 &lt;form action=\"transJB\"&gt;4 &lt;label for=\"stud.id\"&gt;学号&lt;/label&gt;5 &lt;input type=\"text\" name=\"stud.id\"&gt;6 &lt;br/&gt;7 &lt;label for=\"stud.name\"&gt;姓名&lt;/label&gt;8 &lt;input type=\"text\" name=\"stud.name\"/&gt;9 &lt;br/&gt;10 &lt;label for=\"stud.school\"&gt;学院&lt;/label&gt;11 &lt;input type=\"text\" name=\"stud.school\"/&gt;12 &lt;br/&gt;13 &lt;label for=\"stud.pw\"&gt;口令&lt;/label&gt;14 &lt;input type=\"password\" name=\"stud.pw\"/&gt;15 &lt;br/&gt;16 &lt;label for=\"stud.mail\"&gt;邮箱&lt;/label&gt;17 &lt;input type=\"text\" name=\"stud.mail\"/&gt;18 &lt;br/&gt;19 &lt;input type=\"submit\" value=\"登录\"/&gt;20 &lt;/form&gt;21 &lt;h1&gt;使用HttpServletRequest传递参数：&lt;/h1&gt;22 &lt;form action=\"transSERVLET\"&gt;23 &lt;label for=\"id\"&gt;学号&lt;/label&gt;24 &lt;input type=\"text\" name=\"id\"&gt;25 &lt;br/&gt;26 &lt;label for=\"name\"&gt;姓名&lt;/label&gt;27 &lt;input type=\"text\" name=\"name\"/&gt;28 &lt;br/&gt;29 &lt;label for=\"school\"&gt;学院&lt;/label&gt;30 &lt;input type=\"text\" name=\"school\"/&gt;31 &lt;br/&gt;32 &lt;label for=\"pw\"&gt;口令&lt;/label&gt;33 &lt;input type=\"password\" name=\"pw\"/&gt;34 &lt;br/&gt;35 &lt;label for=\"mail\"&gt;邮箱&lt;/label&gt;36 &lt;input type=\"text\" name=\"mail\"/&gt;37 &lt;br/&gt;38 &lt;input type=\"submit\" value=\"登录\"/&gt;39 &lt;/form&gt;40&lt;/body&gt; 3.2. struts.xml 1&lt;package name=\"TransTestPkg\" extends=\"struts-default\"&gt;2 &lt;action name=\"transJB\" class=\"transTest.JBtrans\" method=\"execute\"&gt;3 &lt;result name=\"success\"&gt;/succJB.jsp&lt;/result&gt;4 &lt;/action&gt;5 &lt;action name=\"transSERVLET\" class=\"transTest.SERVLETtrans\" method=\"execute\"&gt;6 &lt;result name=\"success\"&gt;/succSERVLET.jsp&lt;/result&gt;7 &lt;/action&gt;8&lt;/package&gt; 3.3. transTest 3.3.1. SERVLETtrans.java 1package transTest;23import java.util.Map;4import javax.servlet.http.HttpServletRequest;5import com.opensymphony.xwork2.ActionContext;6import org.apache.struts2.ServletActionContext; 78public class SERVLETtrans&#123;9 public String execute()&#123;10 ActionContext ctx=ActionContext.getContext();11 HttpServletRequest request = (HttpServletRequest) ctx.get(ServletActionContext.HTTP_REQUEST);12 Map&lt;String,Object&gt; application=ctx.getApplication();1314 String id=request.getParameter(\"id\");15 String name = request.getParameter(\"name\");16 String school = request.getParameter(\"school\");17 String pw = request.getParameter(\"pw\");18 String mail = request.getParameter(\"mail\");1920 System.out.println(\"id: \" + id);21 System.out.println(\"name: \" + name);22 System.out.println(\"school: \" + school);23 System.out.println(\"pw: \" + pw);24 System.out.println(\"mail: \" + mail);25 26 application.put(\"id\",id);27 application.put(\"name\",name);28 application.put(\"school\",school);29 application.put(\"pw\",pw);30 application.put(\"mail\",mail);31 32 return \"success\";33 &#125;34&#125; 3.3.2. JBtrans.java 1package transTest;2import com.opensymphony.xwork2.ActionSupport;3import transTest.StudentBean;45public class JBtrans extends ActionSupport &#123;6 /**7 * 8 */9 private static final long serialVersionUID = 1L;10 11 private StudentBean stud;12 public StudentBean getStud() &#123;13 return stud;14 &#125;15 public void setStud(StudentBean stud) &#123;16 this.stud = stud;17 &#125;18 19 //public StudentBean stud = new StudentBean();20 21 public String execute()&#123;22 /*System.out.println(stud.getName());23 System.out.println(stud.getSchool());24 System.out.println(stud.getPw());25 System.out.println(stud.getMail());26 System.out.println(stud.getId());*/27 return \"success\";28 &#125;29&#125; 3.3.3. StudentBean.java 1package transTest;23public class StudentBean &#123;4 public String name,id,school,pw,mail;5 public String getName() &#123;6 return name;7 &#125;8 public void setName(String name) &#123;9 this.name = name;10 &#125;11 public String getId() &#123;12 return id;13 &#125;14 public void setId(String id) &#123;15 this.id = id;16 &#125;17 public String getSchool() &#123;18 return school;19 &#125;20 public void setSchool(String school) &#123;21 this.school = school;22 &#125;23 public String getPw() &#123;24 return pw;25 &#125;26 public void setPw(String pw) &#123;27 this.pw = pw;28 &#125;29 public String getMail() &#123;30 return mail;31 &#125;32 public void setMail(String mail) &#123;33 this.mail = mail;34 &#125;35&#125; 3.4. succJB和succSERVLET.jsp 1jb:2&lt;body&gt;3 &lt;h1&gt;欢迎你，学号&lt;s:property value=\"stud.id\"/&gt;，&lt;s:property value=\"stud.school\"/&gt;学院的&lt;s:property value=\"stud.name\"/&gt;同学！&lt;/h1&gt;4 &lt;p&gt;你登记的邮箱是&lt;s:property value=\"stud.mail\"/&gt;，口令是&lt;s:property value=\"stud.pw\"/&gt;。&lt;/p&gt;5&lt;/body&gt;67servlet:8&lt;body&gt;9 &lt;h1&gt;欢迎你，学号$&#123;applicationScope.id&#125;，$&#123;applicationScope.school&#125;学院的$&#123;applicationScope.name&#125;同学！&lt;/h1&gt;10 &lt;p&gt;你登记的邮箱是$&#123;applicationScope.mail&#125;，口令是$&#123;applicationScope.pw&#125;。&lt;/p&gt;11&lt;/body&gt;","categories":[{"name":"表世界","slug":"表世界","permalink":"http://yoursite.com/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"JSP","slug":"表世界/JSP","permalink":"http://yoursite.com/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/JSP/"}],"tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://yoursite.com/tags/MyEclipse/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Struts","slug":"Struts","permalink":"http://yoursite.com/tags/Struts/"}]},{"title":"Struts2中Action的几种Result","slug":"Struts2中Action的几种Result","date":"2019-11-02T08:53:30.000Z","updated":"2019-11-02T08:53:30.000Z","comments":true,"path":"2019/11/02/Struts2中Action的几种Result/","link":"","permalink":"http://yoursite.com/2019/11/02/Struts2%E4%B8%ADAction%E7%9A%84%E5%87%A0%E7%A7%8DResult/","excerpt":"action跳转至页面、URL或另一个action。","text":"action跳转至页面、URL或另一个action。 Struts中调用Action后应当获得一个Result。它告诉Struts接下来该干啥。它的属性可以是以下类型： dispatcher：请求转发，用于整合JSP的结果类型。 redirect：请求重定向。值为一个请求URL。 redirect-action：请求重定向到action。值为定义的action的name。 plaintext：用于显示某个页面的源代码。 还有好多种不会的…… 0. 环境 Tomcat 9.0 MyEclipse 2017 ci10 Struts 2.5.20 Manjaro Linux 18.1.0 JDK 1.8u221 1. dispatcher 如果在result标签中没有指定type，则默认是dispatcher类型。此时它指定一个视图资源——通常是JSP页面。 2. redirect 使用该type的action重定向到一个页面，另一个action或一个网址。 3. redirect-action 使用该type的action使用ActionMapperFactory提供的ActionMapper来重定向请求到另外一个action。与redirect相比，在使用上没有什么区别。 4. 测试 4.1. struts.xml中的packge 1&lt;package name=\"ActionTestPkg\" extends=\"struts-default\"&gt; 2 &lt;action name=\"action2JSP\" class=\"actionTest.JSPaction\" method=\"execute\"&gt;3 &lt;result name=\"success\"&gt;/succ.jsp&lt;/result&gt;4 &lt;result name=\"failed\"&gt;/fail.jsp&lt;/result&gt;5 &lt;/action&gt;6 &lt;action name=\"action2URL\" class=\"actionTest.URLaction\" method=\"execute\"&gt;7 &lt;result name=\"success\" type=\"redirect\"&gt;http://www.bing.com&lt;/result&gt;8 &lt;/action&gt;9 &lt;action name=\"action2ACT\" class=\"actionTest.ACTaction\" method=\"execute\"&gt;10 &lt;result name=\"success\" type=\"redirectAction\"&gt;action2URL&lt;/result&gt;11 &lt;/action&gt;12&lt;/package&gt; 4.2. actionTest包 4.2.1. JSPaction类 1package actionTest;23public class JSPaction &#123;4 private String text;5 6 public void setText(String text) &#123;7 System.out.println(\"JSPaction set text:\"+this.text);8 this.text = text;9 &#125;10 public String getText() &#123;11 System.out.println(\"JSPaction get text:\"+text);12 return text;13 &#125;14 15 public String execute() throws Exception &#123;16 if(\"hello world\".equals(this.text))&#123;17 System.out.println(\"JSPaction execute success.\");18 return \"success\";19 &#125;20 else &#123;21 System.out.println(\"JSPaction execute failed.\");22 return \"failed\";23 &#125;24 &#125;25&#125; 4.2.2. URLaction类 1package actionTest;23public class URLaction &#123;4 public String execute() throws Exception &#123;5 System.out.println(\"URLaction execute success.\");6 return \"success\";7 &#125;8&#125; 4.2.3. ACTaction类 1package actionTest;23public class ACTaction &#123;4 public String execute() throws Exception &#123;5 System.out.println(\"ACTaction return success.\");6 return \"success\";7 &#125;8&#125; 4.3. JSP页面 4.3.1. index 1&lt;form action=\"action2JSP\"&gt;2 &lt;label for=\"text\"&gt;Please enter hello world&lt;/label&gt;3 &lt;br/&gt;4 &lt;input type=\"text\" name=\"text\"/&gt;5 &lt;br/&gt;6 &lt;input type=\"submit\" value=\"call JSP action\"/&gt;7&lt;/form&gt;8&lt;form action=\"action2URL\"&gt;9 &lt;input type=\"submit\" value=\"call URL action\"/&gt;10&lt;/form&gt;11&lt;form action=\"action2ACT\"&gt;12 &lt;input type=\"submit\" value=\"call ACT action\"/&gt;13&lt;/form&gt; 4.3.2. succ和fail 1&lt;p&gt;success或者fial:get &lt;s:property value=\"text\"/&gt; .&lt;/p&gt; 5. 带参数的重定向 5.1. redirect&quot; 1&lt;result name=\"success\" type=\"redirect\"&gt;/login.do?userId=$&#123;userId &#125;&lt;/result&gt; 5.2. redirect-action&quot;： 1&lt;result name=\"success\" type=\"redirect-action\"&gt; 2 &lt;param name=\"actionName\"&gt;login.do&lt;/param&gt; 重定向action名3 &lt;param name=\"userId\"&gt;userId&lt;/param&gt;带的参数4&lt;/result&gt;","categories":[{"name":"表世界","slug":"表世界","permalink":"http://yoursite.com/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"JSP","slug":"表世界/JSP","permalink":"http://yoursite.com/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/JSP/"}],"tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://yoursite.com/tags/MyEclipse/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Struts","slug":"Struts","permalink":"http://yoursite.com/tags/Struts/"}]},{"title":"自底向上语法分析","slug":"自底向上语法分析","date":"2019-10-28T11:54:06.000Z","updated":"2019-12-08T16:00:00.000Z","comments":true,"path":"2019/10/28/自底向上语法分析/","link":"","permalink":"http://yoursite.com/2019/10/28/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/","excerpt":"优先分析法和LR(0)、SLR(1)、LR(1)三种LR分析法。","text":"优先分析法和LR(0)、SLR(1)、LR(1)三种LR分析法。 概述 基本思想 从输入符号串出发，在每一分析步对相应句型中的某个简单短语进行归约。如果最终能归约到识别符号，则该输入符号串是相应文法的句子，否则就不是。 基本问题 （假设句型分析过程中每个分析步都对最左的简单短语进行直接归约）如何找出句柄及把此句柄直接归约为哪个非终结符号。 基本思路 找出句柄\\(u\\) 找出规则\\(U\\rightarrow u\\) 把\\(u\\)直接归约成\\(U\\) 基本概念 活前缀:右句型（最右推导可得到的句型）的前缀（如abc的前缀为a、ab、abc），而且其右端不会超过该句型的最右边句柄（句柄是和某个产生式右部匹配的字符串，可以把句柄归约成产生式左部的非终结符）的末端。 举例，设有文法\\(G[E]\\)： \\[ E\\rightarrow E+E|E\\times E \\] \\(E+E\\times E\\)归约成\\(E+E\\)，句柄是\\(E\\times E\\)，那么它的活前缀就是\\(E\\)、\\(E+\\)、\\(E+E\\)、\\(E+E\\times\\)、\\(E+E\\times E\\)。 这里又可以分为两种情况： 归态活前缀： 活前缀的尾部正好是句柄之尾，这时可以进行规约，规约之后又成为另一句型的活前缀。 非归态活前缀：句柄尚未形成，需继续移入若干符号之后才能形成句柄。 自底向上优先分析 简单优先分析法 如果可以确定所有符号的优先级，则只需按优先级顺序规约（当一个符号优先级高于它后面的符号时，向前匹配一个产生式右部进行规约）即可。如果一个文法其任意两个符号间最多只有一种优先关系成立并且所有产生式的右部均不相同，则这么做是可行的，这种文法称为简单优先文法。这种分析方式有时用在表达式的分析上，大部分时候不实用。 算符优先分析法 如果只确定终结符之间的关系，则可大大提高适用性，但这时的规约不再是规范的。想通过终结符规约，需要所有产生式右部均没有相邻的非终结符（满足此条件称为算符文法）且任一对终结符之间仅有大于、小于或等于一种优先关系存在（满足此条件称为算符优先文法）。 如果两个终结符出现在了同一个产生式右部，称他俩优先级相等，写作\\(a\\doteq b\\)（点在中间，不会打，下面所有符号同）。 有类似\\(A\\to \\dots aB\\ldots\\)的产生式且有\\(B\\Rightarrow^{+} \\Rightarrow Cb\\ldots\\)（\\(C\\)可以为空）的\\(a\\)和\\(b\\)，这种要规约的话肯定是先把含\\(b\\)的式子规约到\\(B\\)再规约\\(a\\)，所以称为\\(a\\)的优先级小于\\(b\\)，写作\\(a\\dot&lt; b\\)。 有类似\\(A\\to \\dots Bb\\ldots\\)的产生式且有\\(B\\Rightarrow^{+} \\Rightarrow \\ldots aC\\)（\\(C\\)可以为空）的\\(a\\)和\\(b\\)，这种要规约的话肯定是先把含\\(a\\)的式子规约到\\(B\\)再规约\\(b\\)，所以称为\\(a\\)的优先级大于\\(b\\)，写作\\(a\\dot&gt; b\\)。 以\\(G[S]\\)为例： \\[ \\begin{aligned} &amp; S\\rightarrow S;G|G\\\\ &amp; G\\rightarrow G(T)|H\\\\ &amp; H\\rightarrow a|(S)\\\\ &amp; T\\rightarrow T+S|S \\end{aligned} \\] 判断\\(\\doteq\\)关系，只需硬看产生式。这里可知\\((\\doteq )\\)和隐式的\\(\\# \\doteq \\#\\)。 判断\\(\\dot&lt;\\)关系，需先找到所有终结符后跟非终结符的情况，有\\(;G\\)、\\((T\\)、\\((S\\)、\\(+S\\)和隐式的\\(\\#S\\)、\\(\\#G\\)。这几个关系中，在前面的终结符的优先级小于后面的非终结符的First中元素。 判断\\(\\dot&gt;\\)关系，需先找到所有非终结符后跟终结符的情况，有\\(S;\\)、\\(G(\\)、\\(T)\\)、\\(S)\\)和隐式的\\(G\\#\\)。这几个关系中，在前面的非终结符的Last集中元素优先级大于后面的终结符。 将这些关系构建为一张表： ; ( ) + a # ; ( ) + a # 没有冲突，该文法是算符优先文法。 引入最左素短语概念以确定算符优先分析的句柄，素短语是一个包含终结符的短语，且不包含除自身外的其它素短语。最左素短语就是最左的没啥好说的。可以看出，我们可以通过每次规约最左素短语进行规约。在算符优先文法的输入串中，如果一个终结符的优先级大于它两边的终结符的优先级，则它（和它两边的非终结符，如果有）是素短语。故对于算符优先文法的输入串，每次规约最左的、优先级比两边的终结符大的终结符即可，例如a;(a+a)之于上面的文法： 步骤 句型 优先关系 最左素短语 规约 1 #a;(a+a)# #&lt;a&gt;;&lt;(&lt;a&gt;+&lt;a&gt;)&gt;# a H 2 #H;(a+a)# #&lt;;&lt;(&lt;a&gt;+&lt;a&gt;)&gt;# a H 3 #H;(H+a)# #&lt;;&lt;(&lt;+&lt;a&gt;)&gt;# a H 4 #H;(H+H)# #&lt;;&lt;(&lt;+&gt;)&gt;# T+S T 5 #H;(T)# #&lt;;&lt;(=)&gt;# (T) S 这一步把(T)规约到S。这里只要求形式相同，具体非终结符是哪个并不关心。 步骤 句型 优先关系 最左素短语 规约 6 #H;S# #&lt;;&gt;# H;S S 7 #S# 虽然接受了，但该字符串其实不是文法的句子。毕竟它不是规范的，难免。因此只适合表达式的分析。 LR分析 概述 LR(K)分析器包括总控程序和分析表。 总控程序根据不同的分析表决定下一步的处理动作。不同文法的总控程序相同，只是分析表不同。 分析表是LR(K)分析技术的核心，根据具体文法按某种规则构造，由分析动作表和转换表构成。 分析动作表ACTION[S,y]指明当状态S与向前看符号串y相匹配时所应采取的动作。包括：移进、归约、接受、出错 。 状态转换表GOTO[S,U]指明当状态S与非终结符号U相匹配时所转换到的下一状态。 分析过程 将初始状态S0与#压进分析栈 根据栈顶状态和当前输入符号查动作表进行以下工作 移进(Si)：当前输入符号进符号栈,新的状态进状态栈,继续扫描. 归约(rj)：按某规则归约,若规则的右部长度n,则符号栈顶和状态栈顶n个元素同时退栈. 把归约后的左部符号进符号栈,查状态转换表,新的状态进状态栈. 接受(acc): 分析成功,结束. 出错(空白): 报告出错信息. 重复(1),直到接受或出错为止. LR(0)分析 设有文法\\(G[S]\\)： \\[ \\begin{aligned} &amp;(1)S\\rightarrow A\\\\ &amp;(2)S\\rightarrow B\\\\ &amp;(3)A\\rightarrow aAb\\\\ &amp;(4)A\\rightarrow c\\\\ &amp;(5)B\\rightarrow aBb\\\\ &amp;(6)B\\rightarrow d\\\\ \\end{aligned} \\] 为了确保起始符号不出现在产生式右部，并显式地表示EOF，增加一个起始符号S'，得到增广文法\\(G&#39;[S&#39;]\\)： \\[ \\begin{aligned} &amp;(0)S&#39;\\rightarrow S\\#\\\\ &amp;(1)S\\rightarrow A\\\\ &amp;(2)S\\rightarrow B\\\\ &amp;(3)A\\rightarrow aAb\\\\ &amp;(4)A\\rightarrow c\\\\ &amp;(5)B\\rightarrow aBb\\\\ &amp;(6)B\\rightarrow d\\\\ \\end{aligned} \\] 并引入一个“・”记号，这个记号之前的部分为已经读入（并且匹配）的部分，之后的部分为期望为读入的部分匹配的部分。为了便于识别，手写时将点记号写作“\\(\\Delta\\)”。 为了得到想要的两个表，需要先构建这个文法的自动机。 首先看起始状态，现在面对一个未知的串，期望其匹配G'，也就是未读入的部分匹配\\(S \\#\\)。将现在的状态称为\\(S_0\\)，也就是： 状态 项目 后继符号 后继状态 \\(S_0\\) \\(S&#39;\\rightarrow \\Delta S\\) \\(S\\) 既然期待\\(S\\)，那左部符号为\\(S\\)的产生式也可以被期待。加进去，就变成： 状态 项目 后继符号 后继状态 \\(S_0\\) \\(S&#39;\\rightarrow \\Delta S\\) \\(S\\) \\(S_0\\) \\(S\\rightarrow \\Delta A\\) \\(A\\) \\(S_0\\) \\(S\\rightarrow \\Delta B\\) \\(B\\) 同理，都期待\\(A\\)和\\(B\\)了，那左部符号为\\(A\\)和\\(B\\)的产生式也可以被期待： 状态 项目 后继符号 后继状态 \\(S_0\\) \\(S&#39;\\rightarrow \\Delta S\\) \\(S\\) \\(S_0\\) \\(S\\rightarrow \\Delta A\\) \\(A\\) \\(S_0\\) \\(S\\rightarrow \\Delta B\\) \\(B\\) \\(S_0\\) \\(A\\rightarrow \\Delta aAb\\) \\(a\\) \\(S_0\\) \\(A\\rightarrow \\Delta c\\) \\(c\\) \\(S_0\\) \\(B\\rightarrow \\Delta aBb\\) \\(a\\) \\(S_0\\) \\(B\\rightarrow \\Delta d\\) \\(d\\) 现在假设对每个项目，真的都读到了它的后继符号，那将进入新的状态。给它们起名字： 状态 项目 后继符号 后继状态 \\(S_0\\) \\(S&#39;\\rightarrow \\Delta S\\) \\(S\\) \\(S_1\\) \\(S_0\\) \\(S\\rightarrow \\Delta A\\) \\(A\\) \\(S_2\\) \\(S_0\\) \\(S\\rightarrow \\Delta B\\) \\(B\\) \\(S_3\\) \\(S_0\\) \\(A\\rightarrow \\Delta aAb\\) \\(a\\) \\(S_4\\) \\(S_0\\) \\(A\\rightarrow \\Delta c\\) \\(c\\) \\(S_5\\) \\(S_0\\) \\(B\\rightarrow \\Delta aBb\\) \\(a\\) \\(S_4\\) \\(S_0\\) \\(B\\rightarrow \\Delta d\\) \\(d\\) \\(S_6\\) 对于两个后继为\\(a\\)的，由于其都是“第一个读到\\(a\\)”的情况，所以对应的下一个状态是相同的。 现在考虑\\(S_1\\)。现在已经读入了\\(S\\)（或者不能叫读入了，因为\\(S\\)并不是一个终结符，不过意思是这么个意思……），所以\\(\\Delta\\)要放在\\(S\\)后面，那就是后面没有没有待匹配的东西了，期望读入EOF： 状态 项目 后继符号 后继状态 \\(S_1\\) \\(S&#39;\\rightarrow S\\Delta\\) \\(\\#\\) END \\(S_2\\)和\\(S_3\\)同理： 状态 项目 后继符号 后继状态 \\(S_2\\) \\(S\\rightarrow A\\Delta\\) \\(\\#\\) END \\(S_3\\) \\(S\\rightarrow B\\Delta\\) \\(\\#\\) END 对\\(S_4\\)，已经读入了\\(a\\)，对于\\(A\\rightarrow aAb\\)，期望看到\\(A\\)；对于\\(B\\rightarrow aBb\\)，期望看到\\(B\\)，所以左部符号为\\(A\\)和\\(B\\)的产生式也可以被期待——注意此时的\\(\\Delta\\)在右部式的最左，而不是\\(a\\)后，因为这个期待的\\(A\\)或\\(B\\)还没被读取： 状态 项目 后继符号 后继状态 \\(S_4\\) \\(A\\rightarrow a\\Delta Ab\\) \\(A\\) \\(S_7\\) \\(S_4\\) \\(B\\rightarrow a\\Delta Bb\\) \\(B\\) \\(S_8\\) \\(S_4\\) \\(A\\rightarrow \\Delta aAb\\) \\(a\\) \\(S_4\\) \\(S_4\\) \\(A\\rightarrow \\Delta c\\) \\(c\\) \\(S_5\\) \\(S_4\\) \\(B\\rightarrow \\Delta aBb\\) \\(a\\) \\(S_4\\) \\(S_4\\) \\(B\\rightarrow \\Delta d\\) \\(d\\) \\(S_6\\) 这里头两个项目时已经读入了\\(a\\)，期待\\(A\\)或\\(B\\)，是新状态；之后的是已有的状态。 对于\\(S_5\\)和\\(S_6\\)，当读到期待的符号后后面就没了，期待EOF： 状态 项目 后继符号 后继状态 \\(S_5\\) \\(A\\rightarrow c\\Delta\\) \\(\\#\\) END \\(S_6\\) \\(B\\rightarrow d\\Delta\\) \\(\\#\\) END 对于\\(S_7\\)和\\(S_8\\)，当读到期待的符号后再后还有得读，又多了两种状态： 状态 项目 后继符号 后继状态 \\(S_7\\) \\(A\\rightarrow aA\\Delta b\\) \\(b\\) \\(S_9\\) \\(S_8\\) \\(B\\rightarrow aB\\Delta b\\) \\(b\\) \\(S_{10}\\) 对于\\(S_9\\)和\\(S_10\\)，当读到期待的符号后期待EOF： 状态 项目 后继符号 后继状态 \\(S_9\\) \\(A\\rightarrow aAb\\Delta\\) \\(\\#\\) END \\(S_10\\) \\(B\\rightarrow aBb\\Delta\\) \\(\\#\\) END 这样所有的状态都分析完了。整合一下这个表，就是： 状态 项目集 后继符号 后继状态 \\(S_0\\) \\(\\{\\\\S&#39; \\rightarrow \\Delta S\\\\S\\rightarrow \\Delta A\\\\S\\rightarrow \\Delta B\\\\A\\rightarrow \\Delta aAb\\\\A\\rightarrow \\Delta c\\\\B\\rightarrow \\Delta aBb\\\\B\\rightarrow \\Delta d\\\\\\}\\) \\(S\\\\A\\\\B\\\\a\\\\c\\\\a\\\\d\\) \\(S_1\\\\S_2\\\\S_3\\\\S_4\\\\S_5\\\\S_4\\\\S_6\\) \\(S_1\\) \\(\\{\\\\S&#39;\\rightarrow S\\Delta\\\\\\}\\) \\(\\#\\) END \\(S_2\\) \\(\\{\\\\S\\rightarrow A\\Delta\\\\\\}\\) \\(\\#\\) END \\(S_3\\) \\(\\{\\\\S\\rightarrow B\\Delta\\\\\\}\\) \\(\\#\\) END \\(S_4\\) \\(\\{\\\\A\\rightarrow a\\Delta Ab\\\\B\\rightarrow a\\Delta Bb\\\\A\\rightarrow \\Delta aAb\\\\A\\rightarrow \\Delta c\\\\B\\rightarrow \\Delta aBb\\\\B\\rightarrow \\Delta d\\\\\\}\\) \\(A\\\\B\\\\a\\\\c\\\\a\\\\d\\) \\(S_7\\\\S_8\\\\S_4\\\\S_5\\\\S_4\\\\S_6\\) \\(S_5\\) \\(\\{\\\\A\\rightarrow c\\Delta\\\\\\}\\) \\(\\#\\) END \\(S_6\\) \\(\\{\\\\B\\rightarrow d\\Delta\\\\\\}\\) \\(\\#\\) END \\(S_7\\) \\(\\{\\\\A\\rightarrow aA\\Delta b\\\\\\}\\) \\(b\\) \\(S_9\\) \\(S_8\\) \\(\\{\\\\B\\rightarrow aB\\Delta b\\\\\\}\\) \\(b\\) \\(S_10\\) \\(S_9\\) \\(\\{\\\\A\\rightarrow aAb\\Delta\\\\\\}\\) \\(\\#\\) END \\(S_{10}\\) \\(\\{\\\\B\\rightarrow aBb\\Delta\\\\\\}\\) \\(\\#\\) END END 这样就获得了这个文法的自动机。为了方便程序查找在啥状态下读到啥时该做啥，需要构建分析表。 当位于状态\\(S_0\\)时，下一位可能的符号有\\(a\\)，\\(b\\)，\\(c\\)，\\(d\\)和\\(\\#\\)。由自动机知此时下一位若为\\(a\\)，\\(c\\)，\\(d\\)是符合规则的。因此若下一位是\\(a\\)则移进（shift）一位（就是把\\(S_0,a\\)入分析栈，读入的指针右移一位）并转换到到\\(S_4\\)，\\(c\\)则\\(S_5\\)，\\(d\\)则\\(S_6\\)。 状态 \\(a\\) \\(b\\) \\(c\\) \\(d\\) \\(\\#\\) \\(S_0\\) s4 s5 s6 也就是从这样： 1+-----------------+ +----------------------------------+2|status |symble | |...a... |3+-----------------+ +---^------------------------------+4| | | |5| | | |6| | | +7| | |8+-----------------+9|S0 |x |10+-----------------+11|... |... |12+-----------------+13|S0 |# |14+-----------------+ 变成这样： 1+-----------------+ +----------------------------------+2|status |symble | |...a... |3+-----------------+ +----^-----------------------------+4| | | |5| | | |6| | | +7| | |8+-----------------+9|S4 |a |10+-----------------+11|S0 |x |12+-----------------+13|... |... |14+-----------------+15|S0 |# |16+-----------------+ 当位于状态\\(S_1\\)时，如果遇到\\(\\#\\)就是分析完了，称之为“acc(ept)”，其它情况不符合自动机。 状态 \\(a\\) \\(b\\) \\(c\\) \\(d\\) \\(\\#\\) \\(S_1\\) acc 当位于状态\\(S_2\\)时，栈中的内容是\\(A\\)，要进行规约（reduce）。 根据\\(S_2\\)的规则，也就是规则1，\\(A\\)规约后将变成\\(S\\)。所以在表里填上“r1”表示根据规则1规约，并弹出被规约的内容，这里只有\\(S_2,A\\)，规约后得到的非终结符是使用的规则的左部符号，到达栈顶状态遇到这一符号的状态。 状态 \\(a\\) \\(b\\) \\(c\\) \\(d\\) \\(\\#\\) \\(S_2\\) r1 r1 r1 r1 r1 也就是由（这个例子中只有\\(S_0\\)后继符号是\\(S\\)，此时后继状态是\\(S_1\\)）： 1+-----------------+ +----------------------------------+2|status |symble | |....... |3+-----------------+ +---^------------------------------+4| | | |5| | | |6| | | +7+-----------------+8|S2 |A |9+-----------------+10|S0 |# |11+-----------------+ 变成： 1+-----------------+ +----------------------------------+2|status |symble | |....... |3+-----------------+ +---^------------------------------+4| | | |5| | | |6| | | +7+-----------------+8|S1 |S |9+-----------------+10|S0 |# |11+-----------------+ 为方便查找，还要再搞一个将状态与非终结符联系起来的表，为表区分，之前的称为“ACTION”表，后者称为“GOTO”表。 状态 \\(S\\) \\(A\\) \\(B\\) \\(S_0\\) 1 \\(S_3\\)同样是要规约，要从\\(B\\)规约到\\(S\\)也就是按规则2: 状态 \\(a\\) \\(b\\) \\(c\\) \\(d\\) \\(\\#\\) \\(S_3\\) r2 r2 r2 r2 r2 依此类推即可获得分析表。 这种分析方法的问题在于，一旦进入某个可以规约的状态，无论输入是什么都会规约。这可能导致错误的规约。 SLR(1)分析 但是对大部分文法，会出现移进与规约的冲突和规约与规约的冲突。 设有文法\\(G[S]\\)： \\[ \\begin{aligned} &amp;(1)S\\rightarrow A\\\\ &amp;(2)A\\rightarrow aAd\\\\ &amp;(3)A\\rightarrow aAb\\\\ &amp;(4)A\\rightarrow \\epsilon \\end{aligned} \\] 构造自动机： 状态 项目集 后继符号 后继状态 \\(S_0\\) \\(\\{\\\\S\\rightarrow \\Delta A\\\\A\\rightarrow \\Delta aAd\\\\A\\rightarrow \\Delta aAb\\\\A\\rightarrow \\epsilon \\Delta \\\\\\}\\) \\(A\\\\a\\\\a\\\\\\#A\\rightarrow \\epsilon\\) \\(S_1\\\\S_2\\\\S_2\\\\END\\) 可以发现这里面既有移进项又有规约项。这种情况就说这个文法不是LR(0)的。如果一个文法的自动机同时存在不止一个规约项目，它也不是LR(0)的。 但\\(A\\)的Follow集和这里的两个\\(a\\)无交集，故可以根据这个进行判断是移进还是规约，这种叫SLR(1)文法，因为根据下一个输入字符即可判断执行什么操作。之所以是SLR而不是LR，是因为它仅在冲突时进行判断，不冲突时仍然是不管输入啥都规约。这导致有时仍然会错误地规约。一个项目集中有两个规约的情况类似，考察两个左部符号的Follow集，没有交集的话也OK。 类似LR(0)地可获得分析表。唯一区别就是有些地方状态既可能要移进也可能要规约，而不是要规约一整行都是规约。以状态\\(S_0\\)为例： 状态 a b d # A \\(S_0\\) s2 r4 r4 r4 1 LR(1)分析 上面讲项目集规约与移进、规约与规约出现冲突时考察交集，那万一有呢？当时是通过比较Follow集，但Follow集只是个笼统的说法，一个非终结符的Follow集中的某个元素可能在某些句型中并不会出现。考虑在自动机的每一个产生式中标注其推导出的句型可能的后缀，当遇到可能遇到的后缀时才进行规约。这不止可以避免冲突，还可以避免误规约。","categories":[{"name":"深蓝","slug":"深蓝","permalink":"http://yoursite.com/categories/%E6%B7%B1%E8%93%9D/"},{"name":"编译原理","slug":"深蓝/编译原理","permalink":"http://yoursite.com/categories/%E6%B7%B1%E8%93%9D/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"语法分析","slug":"语法分析","permalink":"http://yoursite.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"}]},{"title":"在MyEclipse中使用Struts框架","slug":"在MyEclipse中使用Struts框架","date":"2019-10-24T10:32:29.000Z","updated":"2019-10-24T10:32:29.000Z","comments":true,"path":"2019/10/24/在MyEclipse中使用Struts框架/","link":"","permalink":"http://yoursite.com/2019/10/24/%E5%9C%A8MyEclipse%E4%B8%AD%E4%BD%BF%E7%94%A8Struts%E6%A1%86%E6%9E%B6/","excerpt":"贼难配的环境。学委甚至到快结课才配好……","text":"贼难配的环境。学委甚至到快结课才配好…… CSDN——尤其是CSDN论坛，是好东西，也是坏东西。里面有许许多多大神分享有用的经验，但更多的是半吊子误人子弟，给出一些过时的、没用的建议。小白面对茫茫多的信息只能一边望洋兴叹，祈祷下一个看到的解决方案能稍微粘点边；一边对遇到的每行代码、每条命令追根究底，努力摆脱NOOB的身份。 0. 环境 Tomcat 9.0 MyEclipse 2017 ci10 Struts 2.5.20 Manjaro Linux 18.1.0 JDK 1.8u221 1. Struts2的下载 在http://struts.apache.org/download.cgi下载zip包struts-版本-min-lib.zip和struts-版本-all.zip。 前者包含的Struts2所必须的最少的包，后者包含了所有的包和例程。 2. 新建项目与导包 新建一个动态Web项目——有人说这里对动态Web项目的版本有要求需要2.5，实测没有——然后例如取名为“Struts2_HelloWorld”。先不急着完成，去下一步勾选“Generate Web.xml 啥啥啥”那一项和“Generate index.jsp 啥啥啥”（这个缺省是勾选的）。前者将在WEB-INF下创建一个Web.xml，Struts2请求需要先通过其中定义的过滤器。有人说这里需要将“WebRoot”修改为“WebContent”，实测两者均可，估计改其它名也没影响。 将前面下载的struts-版本-min-lib.zip中的包丢到WEB-INF/lib/，选中这些包（选中的是包而不是文件夹lib），右键构建路径。随后工作空间栏中项目根目录下将出现一个“Web应用程序库”，里面显示这些包。不要导入ALL版的lib，因为这些包有一些冲突，最简单的冲突原因例如如果两个包中有同样路径的类，此时某包先加载，则后加载的包中同名的类无法加载，导致一些函数无法找到等。网上很多人都介绍了最小需求包集合，但不少都与官方的有出入。 如果包导多了，由于已经建立了依赖所以无法直接删除。在工作目录视图中右击项目根文件夹，选构建路径，配置构建路径，这里显示了所有已导入的包，移除想删的——或者所有的也行，再移除整个Web应用程序库。然后可以在lib文件夹下删除包，再重新导入即可。 3. 编写Action 在src/新建一个类，例如包名为“helloWorld.action”，类名为“HelloWorld”。在自动生成的类中添加一个execute()： 1public String execute() throws Exception &#123;2 System.out.println(\"进入action。\");3 return \"success\";4&#125;5public String getText() &#123;6 System.out.println(\"赋值text。\");7 return \"Hello World !\";8&#125; 这里HelloWorld类并不需要继承什么东西，有execute()并返回一个String即可。这里希望执行action后跳转到的页面能够根据action的情况决定显示什么内容，而不是一个写死的jsp，所以加一个get函数，命名规则和JavaBean一样，跳转过去后struts2的s:property标签可以通过函数名找到这个函数从中获取值。多加一个println()便于判断是否成功进入action。 4. 编写页面 这个测试例程将有两个页面，一个是主页，一个是执行action后将要跳转到的页面。主页已经生成好了，为body添加一个按钮： 1&lt;form action=\"hello\"&gt;2 &lt;input type=\"submit\" value=\"Say Hello to the World!\"/&gt;3&lt;/form&gt; 用户按下这个按钮，将调用hello.action。 除此之外还需要在jsp第一行加上&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;，这句话指明了这个页面将使用struts2的标签，而且这些标签将在s之前。 另外再创建action将跳转到的页面，例如命名为helloworld.jsp，与index同样位于WebRoot/。 在body中添加&lt;h1&gt;&lt;s:property value=&quot;text&quot;/&gt;&lt;/h1&gt;，并在一开始添加&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt;。 5. 添加配置文件 5.1. struts.xml struts.xml将URL、action类和jsp页面相关联。它规定了当收到某个URL请求时应当调用哪个类，并根据这个类的返回值决定跳转至哪个jsp页面。 可以从之前下载的struts-版本-all.zip中的apps/找一个例程，在其WEB-INF/classes/会有一个该文件。将该文件复制到项目的src/——或者什么其它地方，这个似乎无所谓，无论这个文件在项目的哪里IDE都会在WEB-INF/classes/下创建一个对应的配置文件。建议复制例程的该文件而不是自己编写，因为这样更不容易出错。 复制过来后将&lt;struts&gt;&lt;/struts&gt;中的内容修改为： 1&lt;constant name=\"struts.devMode\" value=\"true\" /&gt;2&lt;package name=\"HelloWorldPkg\" extends=\"struts-default\"&gt; 3 &lt;action name=\"hello\" class=\"helloWorld.action.HelloWorld\" method=\"execute\"&gt;4 &lt;result name=\"success\"&gt;/helloworld.jsp&lt;/result&gt;5 &lt;/action&gt;6&lt;/package&gt; 设置struts.devMode为true可以输出更多日志信息，HelloWorldPkg中的hello这个action规定：当URL为&lt;网站地址&gt;/hello时，调用helloWorld.action包中的HelloWorld类，根据execute()的返回值决定跳转；当返回值为&quot;success&quot;时跳转至/helloworld.jsp。 5.2. Web.xml 新建项目时已经自动生成了这个文件。将&lt;Web-app&gt;&lt;/Web-app&gt;内的内容修改为： 1&lt;display-name&gt;Struts2_HelloWorld&lt;/display-name&gt;2&lt;welcome-file-list&gt;3 &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;4&lt;/welcome-file-list&gt;5&lt;filter&gt;6 &lt;filter-name&gt;struts2&lt;/filter-name&gt;7 &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;8&lt;/filter&gt;9&lt;filter-mapping&gt;10 &lt;filter-name&gt;struts2&lt;/filter-name&gt;11 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;12&lt;/filter-mapping&gt; 这一段内容指定index.jsp为welcome文件。然后配置了Struts2的过滤器来运行任何匹配模式/*的URL，即所有的URL都需要拦截后由Struts进行判断，如果程序决定要调用某个action，再由前面的struts.xml决定调用哪一个。这需要使用一个org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter类。注意在不同版本中这个类是不同的。 有帖子指出welcome-file-list必须放在最后。似乎这并不是必须的。 5.3. log4j2.xml 这个包似乎与日志生成有关，导入方法类似struts.xml，不导入的话会报错ERROR StatusLogger Log4j2 could not find a logging implementation.，但因为只是日志相关所以不影响使用。我导入了也会报错。可能是因为有依赖没搞好？先不管它。 6. 尾声 右击项目，运行方式-&gt;在服务器上运行即可。","categories":[{"name":"戏法","slug":"戏法","permalink":"http://yoursite.com/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://yoursite.com/tags/MyEclipse/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Struts","slug":"Struts","permalink":"http://yoursite.com/tags/Struts/"}]},{"title":"编写一个注册页面并使用JS函数校验","slug":"编写一个注册页面并使用JS函数校验","date":"2019-10-11T12:09:01.000Z","updated":"2019-10-10T16:00:00.000Z","comments":true,"path":"2019/10/11/编写一个注册页面并使用JS函数校验/","link":"","permalink":"http://yoursite.com/2019/10/11/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2%E5%B9%B6%E4%BD%BF%E7%94%A8JS%E5%87%BD%E6%95%B0%E6%A0%A1%E9%AA%8C/","excerpt":"实现了简单的参数传递与判断。不连接数据库。","text":"实现了简单的参数传递与判断。不连接数据库。 首先新建一个Web Project，在WebRoot下新建一个html、一个js和一个css文件。将html自动生成的添加css文件的那段注释改成能用的，再添加&lt;script type=&quot;text/javascript&quot; src=&quot;./js.js&quot;&gt;&lt;/script&gt;引入js文件。 body中就是一个表格，action是跳转，单击时希望使用js文件中的函数进行校验。 在表单中加上οnsubmit=&quot;return false;&quot;可以阻止表单提交。但是对于如下的代码οnsubmit=&quot;submitTest();&quot;，如果提交表单时submitTest()返回false，实际情况是表单正常提交。原因在于如果这样写，相当于： 1Form.prototype.onsubmit &#x3D; function() &#123;2 submitTest();3&#125;; 而我们希望得到这样的函数： 1Form.prototype.onsubmit &#x3D; function() &#123;2 return submitTest();3&#125;; 1&lt;form action=\"succ.jsp\" name=\"form\" onsubmit=\"return signIn();\" method=\"post\"&gt;2 &lt;table border=\"\"&gt;3 4 &lt;caption&gt;注册页面&lt;/caption&gt;5 6 &lt;tr&gt;7 &lt;td&gt;用户名&lt;/td&gt;8 &lt;td&gt;9 &lt;input type=\"text\" 10 required=\"required\" 11 name=\"name\" 12 id=\"name\" 13 onblur=\"checkName();\" 14 onfocus=\"clearName();\" 15 value=\"在此输入用户名\"&gt;16 &lt;/td&gt;17 &lt;td&gt;&lt;label id=\"tip_name\"&gt;请输入用户名&lt;/label&gt;&lt;/td&gt;18 &lt;/tr&gt;19 20 &lt;tr&gt;21 &lt;td&gt;密码&lt;/td&gt;22 &lt;td&gt;23 &lt;input type=\"password\" 24 required=\"required\" 25 name=\"pw\" 26 id=\"pw\" 27 onblur=\"checkPw();\"&gt;28 &lt;/td&gt;29 &lt;td&gt;&lt;label id=\"tip_pw\"&gt;密码由六个或以上字符组成&lt;/label&gt;&lt;/td&gt;30 &lt;/tr&gt;31 32 &lt;tr&gt;33 &lt;td&gt;确认密码&lt;/td&gt;34 &lt;td&gt;35 &lt;input type=\"password\" 36 required=\"required\" 37 name=\"repw\" 38 id=\"repw\" 39 onblur=\"checkRepw();\"&gt;40 &lt;/td&gt;41 &lt;td&gt;&lt;label id=\"tip_repw\"&gt;请确认密码&lt;/label&gt;&lt;/td&gt;42 &lt;/tr&gt;4344 &lt;tr&gt;45 &lt;td&gt;性别&lt;/td&gt;46 &lt;td colspan=\"2\"&gt;47 男&lt;input type=\"radio\" name=\"sex\" id=\"sex1\" value=\"male\" required=\"required\"/&gt;48 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;49 女&lt;input type=\"radio\" name=\"sex\" id=\"sex0\" value=\"female\" required=\"required\"/&gt;50 &lt;/td&gt;51 &lt;/tr&gt;52 53 &lt;tr&gt;54 &lt;td&gt;爱好&lt;/td&gt;55 &lt;td colspan=\"2\"&gt;56 &lt;input type=\"checkbox\" name=\"habit\" value=\"PE\"&gt;体育57 &lt;input type=\"checkbox\" name=\"habit\" value=\"music\"&gt;音乐58 &lt;input type=\"checkbox\" name=\"habit\" value=\"chinese\"&gt;文学59 &lt;input type=\"checkbox\" name=\"habit\" value=\"other\"&gt;其他60 &lt;/td&gt;61 &lt;/tr&gt;62 63 &lt;tr&gt;64 &lt;td&gt;出生年月&lt;/td&gt;65 &lt;td colspan=\"2\"&gt;66 &lt;select name=\"year\"&gt;67 &lt;option selected=\"selected\"&gt;2000&lt;/option&gt;68 &lt;option value=\"1990\"&gt;1990&lt;/option&gt;69 &lt;option value=\"1991\"&gt;1991&lt;/option&gt;70 &lt;option value=\"1992\"&gt;1992&lt;/option&gt;71 &lt;option value=\"1993\"&gt;1993&lt;/option&gt;72 &lt;option value=\"1994\"&gt;1994&lt;/option&gt;73 &lt;option value=\"1995\"&gt;1995&lt;/option&gt;74 &lt;option value=\"1996\"&gt;1996&lt;/option&gt;75 &lt;option value=\"1997\"&gt;1997&lt;/option&gt;76 &lt;option value=\"1998\"&gt;1998&lt;/option&gt;77 &lt;option value=\"1999\"&gt;1999&lt;/option&gt;78 &lt;option value=\"2000\"&gt;2000&lt;/option&gt;79 &lt;/select&gt;年80 &lt;select name=\"month\" &gt;81 &lt;option selected=\"selected\"&gt;1&lt;/option&gt;82 &lt;option value=\"1\"&gt;1&lt;/option&gt;83 &lt;option value=\"2\"&gt;2&lt;/option&gt;84 &lt;option value=\"3\"&gt;3&lt;/option&gt;85 &lt;option value=\"4\"&gt;4&lt;/option&gt;86 &lt;option value=\"5\"&gt;5&lt;/option&gt;87 &lt;option value=\"6\"&gt;6&lt;/option&gt;88 &lt;option value=\"7\"&gt;7&lt;/option&gt;89 &lt;option value=\"8\"&gt;8&lt;/option&gt;90 &lt;option value=\"9\"&gt;9&lt;/option&gt;91 &lt;option value=\"10\"&gt;10&lt;/option&gt;92 &lt;option value=\"11\"&gt;11&lt;/option&gt;93 &lt;option value=\"12\"&gt;12&lt;/option&gt;94 &lt;/select&gt;月95 &lt;/td&gt;96 &lt;/tr&gt;97 98 &lt;tr&gt;99 &lt;td&gt;个人简介&lt;/td&gt;100 &lt;td colspan=\"2\"&gt;&lt;textarea rows=\"4\" cols=\"25\" required=\"required\"&gt;&lt;/textarea&gt;&lt;/td&gt;101 &lt;/tr&gt;102103 &lt;tr&gt;104 &lt;td colspan=\"3\"&gt;105 &lt;input type=\"submit\" value=\"提交\" class=\"bt\"&gt;106 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;107 &lt;input type=\"reset\" value=\"重置\" class=\"bt\"&gt;108 &lt;/td&gt;109 &lt;/tr&gt;110 &lt;/table&gt;111&lt;/form&gt; required=&quot;required&quot;可以要求该项为必填，否则无法提交。select中无法使用该属性，可以使用&lt;option selected=&quot;selected&quot;&gt;2000&lt;/option&gt;设定默认选择的项。 onblur和onfocus分别在对象失去和获得焦点时调用函数，可以实时地提醒用户一些信息。 比如将检查是否提交的函数分为几个小部分，在用户填写表单各小部分对应的对象获得和失去焦点时就调用，即时地给出提醒： 1function clearName()2&#123;3 if(document.getElementById('name').value==\"在此输入用户名\")4 document.getElementById('name').value = null;5&#125;67function checkName()8&#123;9 if(document.getElementById('name').value !=\"在此输入用户名\"&amp;&amp;document.getElementById('name').value!=\"\")10 &#123;11 document.getElementById('tip_name').innerHTML=\"你好，\"+document.getElementById('name').value;12 return true;13 &#125;14 else15 &#123;16 document.getElementById('tip_name').innerHTML=\"请输入用户名\";17 document.getElementById('name').value=\"在此输入用户名\";18 return false;19 &#125;20&#125;2122function checkPw()23&#123;24 if(/^(?=.&#123;6,16&#125;)([0-9A-Za-z]*[\\x00-\\x2F\\x3A-\\x40\\x5B-\\xFF][0-9A-Za-z]*)&#123;2,&#125;$/.test(document.getElementById('pw').value))25 &#123;26 document.getElementById('tip_pw').innerHTML=\"天呐这么复杂的密码你记得住？\";27 return true;28 &#125;29 else if(/^(?=.&#123;6,16&#125;)[0-9A-Za-z]*[\\x00-\\x2f\\x3A-\\x40\\x5B-\\xFF][0-9A-Za-z]*$/.test(document.getElementById('pw').value))30 &#123;31 document.getElementById('tip_pw').innerHTML=\"这强度凑活吧……\";32 return true;33 &#125;34 else if(/^[0-9A-Za-z]&#123;6,16&#125;$/.test(document.getElementById('pw').value))35 &#123;36 document.getElementById('tip_pw').innerHTML=\"这密码我一刻钟就能破解！\";37 return true;38 &#125;39 else40 &#123;41 document.getElementById('tip_pw').innerHTML=\"密码由六至十六个字符组成\";42 return false;43 &#125;44&#125;4546function checkRepw()47&#123;48 var pw = document.getElementById('pw');49 var repw = document.getElementById('repw');50 var tip_repw = document.getElementById('tip_repw');51 52 if(pw.value == repw.value&amp;&amp;pw.value!=\"\")53 &#123;54 tip_repw.innerHTML=\"√\";55 return true;56 &#125;57 else if(repw.value==\"\")58 &#123;59 tip_repw.innerHTML=\"请确认密码\";60 return false;61 &#125;62 else63 &#123;64 tip_repw.innerHTML=\"密码不一致\";65 return false;66 &#125;67&#125;6869function signIn()70&#123;71 if(!checkName())72 &#123;73 alert(\"请检查用户名！\");74 return false;75 &#125;76 if(!checkPw())77 &#123;78 alert(\"请检查密码！\");79 return false;80 &#125;81 if(!checkRepw())82 &#123;83 alert(\"请重新确认密码！\");84 return false;85 &#125;86 return true;87&#125; HTML DOM 定义了多种查找元素的方法，如果需要查找文档中的一个特定的元素，最有效的方法是 getElementById()。在写html时给需要被查找的元素一个id属性，为它指定一个（在文档中）唯一的名称，然后就可以用该id查找想要的元素，该函数返回元素对象。注意要用.value获取它的“值”，因为返回的只是标签，而想要的“值”是标签里的东西。而修改的话就是修改innerHTML也就是标签里面的html语句，另外还有一个innerText类似前者，但是把内容都当文本理解（有点类似赋值给value？）。例如添加&lt;h1&gt;test&lt;\\h1&gt;，前者显示h1级别的test，后者显示&lt;h1&gt;test&lt;\\h1&gt;。","categories":[{"name":"表世界","slug":"表世界","permalink":"http://yoursite.com/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/"},{"name":"JavaScript","slug":"表世界/JavaScript","permalink":"http://yoursite.com/categories/%E8%A1%A8%E4%B8%96%E7%95%8C/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Html","slug":"Html","permalink":"http://yoursite.com/tags/Html/"}]},{"title":"Manjaro Linux下配置JS&jQuery开发环境","slug":"Manjaro-Linux下配置JS-jQuery开发环境","date":"2019-10-11T12:07:10.000Z","updated":"2019-12-08T12:46:46.790Z","comments":true,"path":"2019/10/11/Manjaro-Linux下配置JS-jQuery开发环境/","link":"","permalink":"http://yoursite.com/2019/10/11/Manjaro-Linux%E4%B8%8B%E9%85%8D%E7%BD%AEJS-jQuery%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"javaScript是一种脚本语言。可以以&lt;script&gt; code &lt;/script&gt;的形式混合在HTML页面中编写动态网页。之前的JSP环境直接就可以拿来写JS,但是并没有语法提示等,因此需要装个插件解决这个问题。","text":"javaScript是一种脚本语言。可以以&lt;script&gt; code &lt;/script&gt;的形式混合在HTML页面中编写动态网页。之前的JSP环境直接就可以拿来写JS,但是并没有语法提示等,因此需要装个插件解决这个问题。 0. 环境 MyEclipse 2017 Ci10 jquery-migrate-1.4.1.js spket-1.6.23 1. 安装spket spket是一个JS的IDE，但也可以作为eclipse或MyEclipse的插件使用。下载https://spket.com/download.html中的plugin版本得到一个zip，将其中两个文件夹直接与MyEclipse目录下同名文件夹合并即可。 为了让它可以对jQuery进行智能提示，还需为它指定jQuery的文件，在https://jquery.com/download/右击另存为uncompressed版本。网上说压缩过的min版本会各种报错。 2. 配置spket 使用.../&quot;MyEclipse 2017 CI&quot;/myeclipse -clean启动MyEclipse。直接启动会报错，可能是因为插件缓存的缘故。注意因为MyEclipse 2017默认安装目录中间有空格所以要加引号。启动后在窗口-&gt;首选项-&gt;spket-&gt;JavaScript Profiles中new一个profile，比如取名为”jQuery“，点击Add Library，选择jQuery；再点击Add File，选择jQuery的.js。最后点Default。 在窗口-&gt;首选项–&gt;常规–&gt;编辑器–&gt;文件关联中将*.js的缺省编辑器设为“Spket JavaScript Editor”即可。 右键项目名称，点击Reload JavaScript Profile然后再打开JS文件（可能需要重启），应当会出现语法提示和智能补全。","categories":[{"name":"戏法","slug":"戏法","permalink":"http://yoursite.com/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://yoursite.com/tags/MyEclipse/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"《城市：天际线》中的有用模组","slug":"《城市：天际线》中的有用模组","date":"2019-10-07T12:49:21.000Z","updated":"2019-12-07T16:00:00.000Z","comments":true,"path":"2019/10/07/《城市：天际线》中的有用模组/","link":"","permalink":"http://yoursite.com/2019/10/07/%E3%80%8A%E5%9F%8E%E5%B8%82%EF%BC%9A%E5%A4%A9%E9%99%85%E7%BA%BF%E3%80%8B%E4%B8%AD%E7%9A%84%E6%9C%89%E7%94%A8%E6%A8%A1%E7%BB%84/","excerpt":"记录好用的《发际线》模组。感谢所有模组的作者！常年更新。","text":"记录好用的《发际线》模组。感谢所有模组的作者！常年更新。 尽管即使打开蓝灯也无法在steam客户端和游戏内访问创意工房，但在浏览器中的订阅也可以立即生效。因此可以在游戏中打开游戏内浏览器，再将地址复制至浏览器进行订阅操作。 影响建造的模组 fine road anarchy和fine road tool 前者屏蔽道路的碰撞判定。是极重要的前置模组。后者 强化了道路编辑模式下那个调整每次抬升高度的功能，点开后分为三行，除第一行保留原有功能外，第二行允许强制道路类型，第三行四个功能分别为取消道路角度限制、智能弯曲道路、自动吸附和道路与其它元素的无冲突（例如开启后升级道路不会挤没建筑）。 Move It 启用该模组后将在右下角推土机的左边新增一个十字箭头样的按钮，提供了移动已安放物品的功能。 点开后从左至右共九个按钮。 前两个按钮是导入与导出，可以导入与导出当前选中的元素。导出似乎与主题相关，将导出的内容导入到不同主题的地图时，不兼容的建筑不会被导入（似乎是因为这个，有待继续测试，总之道路没问题，低密度住宅区没问题，会成为“历史性建筑”出现，太阳能发电站垃圾焚烧厂收费站电车站各种直升机中心没问题，而小学警局消防局等和商业区等都无法导入）。之后两个选项是地形跟随与辅助线，前者控制在移动部分类型元素如房屋时其高度是否跟随地形变化，后者开启时为道路等提供角度为90°的整倍时的吸附。 之后的四个选项提供点选择（可使用shift多选）、区域选择、复制和删除的功能。其中复制可以使用ctrl+c，并支持ctrl+z撤销，区域选择功能提供了大量完善的分类功能，且可使用类似Ps中吸管的类型选定工具。 最后一个上三角图标提供了大量有用功能。从下往上数第一个柱状图一样的图标，先选中一个建筑或道路节点等，再选中它，再选另一个元素，即可使前者与后者同高。选中一个元素后再点一下第二个长相与第一个类似的图标就可以使它的高度恢复贴地状态（注意，对高架等使用此功能会使路面和柱子全部贴地，但不影响通行）。选中一段路的所有点和段后再点一下第三个像线性拟合一样的图标后再点击某两个节点，则选中道路的角度将与两点连线与地面之夹角相同。选中一些建筑后点击第四个五边形图标或第五个闪电形图标再点击其中或另外的一建筑，可使所有被选中建筑朝向被点击建筑的方向，区别在于前者的旋转中心为各建筑中心，后者为整体的中心。选中后点击第六个图标则可打乱方向。选中一些元素后点击上数第一个图标再点一个线性元素可实现镜面复制。 另外贴合右侧边缘处还提供了两个视图。 network extentions 2 提供更多道路种类。例如公交车道与人行道。尤其人行道可做成低级道路避免车辆抄近道。 Ploppable RICO RICO指的是住宅、商业等四个区那种会生长的建筑（Residential住宅、Industrial工业、Commerical商业、Office办公，首字母RICO）的一种创意工房版本。启用此模组后会在工具栏右侧出现一个新的左绿右黄下蓝的图标，在创意工房订阅了“RICO”之后可以从此处“噗通”出建筑。也可以从弹出的面板右上角的设置中添加游戏自带的建筑并设置其属性使之成为“RICO”，此操作重启后生效。 Plop the Growables 原本Find It只能放置“RICO”，该模组可让游戏自带的“Growables”可通过Find It放置。 Precision Engineering 修路时按住shift显示更多参数。 影响经营的模组 extra landscaping tools 在工具栏上预算图标右侧新增矿物和水体两个图标，可编辑矿物与水的分布。 Improved Public Transport 2 在查看公共交通面板时提供时速等信息。 No Problem Notifications 作 quay anarchy 允许小河堤在任何地方建造。小河堤平整坡面很有用也很好看。 Prop &amp; Tree Anarchy 作 Prop Line Tool [PLT] (vAlpha) 作 摆放prop时可使用类似修路的工具进行线性摆放。 Prop Precision 变大变小 Procedural Objects 变大变小 Prop Scaling 0.3 [Experimental ALPHA] 允许贴在表面 影响城展的模组 Adaptive Prop Visibility Distance 允许调整元素距离多远可见。 Dynamic Resolution (Fixed for 1.9!) 动态抗拒齿。 first person auto walking 提供第一人称行走功能。 LOD Toggler (deprecated) 允许手动调整细节程度。封面图是“READY TO MELT YOUR GPU？”。 影响外观的模组 network skins 提供道路皮肤。在道路编辑模式下会在右下角出现小窗口用以选择。 Road Options (Road Colors Changer ++) 和 Painter Relight 作显示设置中“色彩矫正覆盖”中提供一些滤镜。 Theme Mixer 在该模组的选项中可以修改每种元素使用那个主题的样式，只支持创意工房的主题。 Surface Painter 在工具栏右侧增加一个“地表工具”图标，允许涂画地表。譬如建筑之间的缝隙原本是草坪，就可以用它涂成水泥，变得更工业风，非常有用。 方便操作的模组 Loading Screen Mod 加载时显示加载信息。可提供缺失资产的信息，可禁止部分资产的加载。 Automatic Bulldoze v2 建筑废弃后自动拆除。 Find It! 在工具栏右侧提供一个放大镜图标用于搜索资产。 More Beautification 为铲子那个图标提供更多分栏。 Advanced Toolbar 在左下方问号图标旁提供一个加号图标，可将下方道具栏展开后的状态由显示一行提升为三行。","categories":[{"name":"丧志","slug":"丧志","permalink":"http://yoursite.com/categories/%E4%B8%A7%E5%BF%97/"},{"name":"城市：天际线","slug":"丧志/城市：天际线","permalink":"http://yoursite.com/categories/%E4%B8%A7%E5%BF%97/%E5%9F%8E%E5%B8%82%EF%BC%9A%E5%A4%A9%E9%99%85%E7%BA%BF/"}],"tags":[{"name":"城市：天际线","slug":"城市：天际线","permalink":"http://yoursite.com/tags/%E5%9F%8E%E5%B8%82%EF%BC%9A%E5%A4%A9%E9%99%85%E7%BA%BF/"}]},{"title":"Manjaro Linux因显卡驱动无法进入图形界面之处理方法","slug":"Manjaro-Linux因显卡驱动无法进入图形界面之处理方法","date":"2019-09-30T08:40:32.000Z","updated":"2019-09-30T08:40:32.000Z","comments":true,"path":"2019/09/30/Manjaro-Linux因显卡驱动无法进入图形界面之处理方法/","link":"","permalink":"http://yoursite.com/2019/09/30/Manjaro-Linux%E5%9B%A0%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E4%B9%8B%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/","excerpt":"因尝试更换显卡驱动为nVIDIA 430xx导致重启后无法进入图形界面，只是黑屏并在屏幕左上角显示一个光标。","text":"因尝试更换显卡驱动为nVIDIA 430xx导致重启后无法进入图形界面，只是黑屏并在屏幕左上角显示一个光标。 0. 环境 Manjaro Linux 18.1.0 video-hybrid-intel-nvidia-430xx-bumblebee VERSION 2019.08.24 1. 进入tty界面 tty，源于Teletypes，原指电传打字机，对于现在的电脑来讲可以叫终端。可以使用w查看当前使用的终端。在使用GNOME+GDM的manjaro下，共有6个tty。登录界面在tty1运行，登录成功后进入在tty2运行的图形界面（登录界面仍保持在tty1运行）。其余界面为文本界面。现在的问题在于由于显卡驱动问题无法进入tty2，因此只需在文字界面下解决驱动问题即可。 使用ctrl+alt+Fx可以切换到ttyx，现在切换到tty3，输入用户名，回车，密码，回车，即可进入tty3。 2. 修改语言配置 tty3-6不能支持中文，而配置的语言是中文的，因此凡是中文会显示为方块。其实在输命令的时候没太大影响，但后面连Wifi的界面全是中文，所以要改成英文。 使用export命令可以修改语言，且仅对当次进入终端有效。 Linux export 命令用于设置或显示环境变量。 在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。 通过export -p可以查看当前的环境变量，有关语言的环境变量（也就是locale，也可以直接用locale查看，根据计算机用户所使用的语言、所在国家或地区以及当地的文化传统所定义的一个软件运行时的语言环境。locale的命名规则为_.，如zh_CN.UTF-8，zh代表中文，CN代表大陆地区，UTF-8表示字符集）默认都是“zh_CN.UTF-8”，执行export xxx=xxx可以修改变量的值。 印象中当时是使用export LC_ALL=en_US.UTF-8和export LANG=en_US.UTF-8。这堆LC_xxx有一堆优先级规则，显而易见LC_ALL是老大。它是一个宏，如果该值设置了，则该值会覆盖所有LC_xxx的设置值。注意，LANG的值不受该宏影响。 【其它有关内容】 locale -a：查看本机可选的配置。可通过诸如sudo locale-gen &quot;zh_CN.gbk&quot;增加。 C和POSIX：默认配置，例如export LC_ALL=C。 3. 连接Wifi 因为需要下载安装原本使用的驱动，所以先连Wifi。 一些Linux中连接Wlan专门有个界面，叫nmtui，即“Network Manager TextUI”，nmtui即可进入。 其中中间的三个选项，第一个是编辑保存的链接，第二个是进行连接。进去第二个等一会，扫描出来之后连上即可。 4. 更换驱动 manjaro提供了方便的驱动管理工具，叫mhwd，即“Manjaro Hardware Detection”，mhwd即可进入，mhwd-tui可进入TUI。在TUI中很方便地选择“Use nonfree graphics”就好了。更新引导sudo mkinitcpio -P即可。 5. 尾声 这个默认的闭源驱动是真的不错。 NVIDIA的Optimus（擎天柱）技术可让笔记本根据性能需要在英特尔集成显卡和NVIDIA独显之间自动切换（其实不是切换而是“是否开启独显”，显示一直都是由集显完成的，只是独立显卡按需渲染并传输给集成显卡显示功能），以达到节约能耗与平衡性能双需求，但此项技术仅仅支持Windows系统。 而默认的“video-hybrid-intel-nvidia-bumblebee”，也就是那个著名的把rm -rf /usr/lib/nvidia-current/xorg/xorg写成rm -rf /usr /lib/nvidia-current/xorg/xorg的软件，可以实现手动的切换。只需在命令前添加optirun即可指定该命令由独显执行。在Steam下，修改游戏属性中的高级启动选项为optirun %command%可指定游戏运行在独立显卡上。原本我的古墓丽影只能以720P全低特效运行，添加这一选项后可以1080P全最高特效丝般顺滑。可惜不知道为啥存档没能继承Windows上的…… 不过Bumblebee不兼容Vulkan。可能可以通过“nvidia-xrun”解决，还未尝试。 最开始的时候在steam改高级选项后启动游戏，会闪一下steam的启动界面然后毫无反应。后来解决了，但是忘了怎么弄的了……果然好记性不如双飞燕……可能是一开始没有进行设置： In order to use Bumblebee, it is necessary to add your regular user to the bumblebee group: 需要gpasswd -a &lt;user&gt; bumblebee。 使用bumblebeed --version查看bumblebee版本，optirun nvidia-settings -c :8以设置N卡，optirun glxgears -info进行测试，vblank_mode=0 glxgears查看关闭垂直同步后的帧数。 后记 安装Manjaro后的第一次更新之后，再次出现了无法使用optirun %command%命令进入游戏的情况。从终端通过optirun steam进入游戏，则将以集显进入；通过primusrun steam进入，则报错“glXChooseVisual failed”。 尝试卸载显卡驱动重装，无效。尝试安装网上的驱动前置的东西sudo pacman -S virtualgl lib32-virtualgl lib32-primus primus，无效。有说法认为报错原因是“libGL.so.1指向mesa和nvidia提供的模糊libGL”，因此删除这些（sudo ldconfig -p | grep -i gl.so中查看）指向mesa的.so即可，但我未找到指向mesa的.so。 最后的处理方案是sudo systemctl disable bumblebeed.service禁用了大黄蜂，安装了另一个管理软件sudo pacman -S optimus-manager并reboot后启用systemctl enable optimus-manager.service。该软件可optimus-manager --switch nvidia切换为N卡。但会注销，还是不如大黄蜂好用…… 【第二天的更新】操，不能用，切完之后optimus-manager --status显示还是用的Intel，昨天断电了玩着卡还以为是断电的原因。似乎是因为GDM与之不兼容，还需要装兼容的版本。游戏啥的，戒了算了。","categories":[{"name":"戏法","slug":"戏法","permalink":"http://yoursite.com/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"Manjaro","slug":"Manjaro","permalink":"http://yoursite.com/tags/Manjaro/"},{"name":"BumbleBee","slug":"BumbleBee","permalink":"http://yoursite.com/tags/BumbleBee/"}]},{"title":"Manjaro Linux下配置MySQL并在MyEclipse中使用","slug":"Manjaro-Linux下配置MySQL并在MyEclipse中使用","date":"2019-09-30T08:39:14.000Z","updated":"2019-09-29T16:00:00.000Z","comments":true,"path":"2019/09/30/Manjaro-Linux下配置MySQL并在MyEclipse中使用/","link":"","permalink":"http://yoursite.com/2019/09/30/Manjaro-Linux%E4%B8%8B%E9%85%8D%E7%BD%AEMySQL%E5%B9%B6%E5%9C%A8MyEclipse%E4%B8%AD%E4%BD%BF%E7%94%A8/","excerpt":"配合MyEclipse使用MySQL。","text":"配合MyEclipse使用MySQL。 0. 环境 MyEclipse 2017 ci10 Tomcat 9.0 JDK 8u221 JDBC 8.0.17 1. MySQL安装 只需sudo pacman -S mysql便可以安装MySQL。装好后根据提示sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql，注意此步需root权限，并会返回临时的用户名和密码，在输出的那一堆东西里找一下。随后可sudo systemctl enable mysqld开机自启、sudo systemctl start mysqld启动服务、sudo systemctl status mysqld查看状态。 使用刚刚给出的临时密码登录mysql -uroot -p&lt;密码&gt;后会提示可以sudo mysql_secure_installation，如果运行的话会执行以下安全设置： 为root用户设置密码 删除匿名账号 取消root用户远程登录 删除test库和对test库的访问权限 刷新授权表使修改生效 看心情设置一下。之后通过“添加/删除软件”安装“MySQL WorkBench”即可进行图形化的操作。 2. JDBC下载 https://dev.mysql.com/downloads/connector/j/下载Platform Independent版本，解压。因为需要与MyEclipse链接，为了方便，丢到家目录下。 3. 与MyEclipse链接 在MyEclipse中点击窗口-&gt;Perspective-&gt;打开透视图-&gt;Database Explorer，在左侧“DB Broster”中空白处右击new一数据库，弹出“DataBase Driver”界面： Driver template：选择MySQL Connector/J Driver name：编个名字 Connection URL：改为 jdbc:mysql://localhost:3306/ User name ：数据库用户名，默认root Password：访问密码 Add Jar：JDBC的jar包的路径 Driver classname：系统会自动匹配 Test一下成功后点完成即可。此时“DB Broster”中会多出MySQL数据库，双击即可链接上。 4. 测试链接 使用MySQL WorkBench新建一个Schema（注意在Collation下拉列表中选择数据库需要修改为的字符集），并新建一个Table（不知为啥新建table时如果改table名字会导致无法操作其它内容，只能先设置其它内容应用后再回头改名字），用于测试。 在MyEclipse中新建一个Java项目，在其中新建一个lib文件夹，把JDBC的.jar丢进去，在MyEclipse中右击这个包构建一下路径。此时可以在该项目“引用的库”列表中看到这个包。 再在src/新建一包，在其中新建一类。以包名为testDB、类名为Test、前面新建的table名为new_table、table中有name和pw两列为例： 1package testDB;2import java.sql.*;34public class Test 5&#123; 6 static final String package testDB;7import java.sql.*;89public class Test 10&#123; 11 static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\"; 12 static final String DB_URL = \"jdbc:mysql://localhost:3306/db0?useSSL=false&amp;serverTimezone=UTC\";13 static final String USER = \"root\";14 static final String PASS = \"235604\";1516 public static void main(String[] args) 17 &#123;18 Connection conn = null;19 Statement stmt = null;20 21 try22 &#123;23 // 注册 JDBC 驱动24 Class.forName(JDBC_DRIVER);25 // 打开链接26 System.out.println(\"连接数据库...\");27 conn = DriverManager.getConnection(DB_URL,USER,PASS);28 // 执行查询29 System.out.println(\"实例化Statement对象...\");30 stmt = conn.createStatement();31 String sql;32 sql = \"SELECT name,pw FROM new_table\";33 ResultSet rs = stmt.executeQuery(sql);3435 // 打印结果36 while(rs.next())37 &#123;38 // 通过字段检索39 String name = rs.getString(\"name\");40 String pw = rs.getString(\"pw\");41 42 // 输出数据43 System.out.print(\"账户: \" + name);44 System.out.print(\"\\t\");45 System.out.print(\"密码: \" + pw);46 System.out.print(\"\\n\");47 &#125;48 49 // 完成后关闭50 rs.close();51 stmt.close();52 conn.close();53 54 &#125;catch(SQLException se)&#123;55 // 处理 JDBC 错误56 se.printStackTrace();57 &#125;catch(Exception e)&#123;58 // 处理 Class.forName 错误59 e.printStackTrace();60 &#125;finally&#123;61 // 关闭资源62 try&#123;63 if(stmt!=null) stmt.close();64 &#125;catch(SQLException se2)&#123;65 // 什么都不做66 &#125;67 68 try&#123;69 if(conn!=null) conn.close();70 &#125;catch(SQLException se)&#123;71 se.printStackTrace();72 &#125;73 &#125;74 System.out.println(\"Goodbye!\");75 &#125;76&#125; 【注意】对旧版JDBC，JDBC_DRIVER与DB_URL两项与以上不同。与老版相比，这里使用的新的8.0版本将com.mysql.jdbc.Driver改为com.mysql.cj.jdbc.Driver（需要注意Tomcat也要用JDK8）；另外已不需要建立ssl连接，但需要设置CST时区。 若输出正确，则一切就绪。 5. 尾声 如需在Web开发中使用JDBC，需将.jar放一份到Tomcat的lib目录下，并重启。一定注意跑页面时选择Tomcat，不然连不上数据库。","categories":[{"name":"戏法","slug":"戏法","permalink":"http://yoursite.com/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://yoursite.com/tags/MyEclipse/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Manjaro Linux下配置JSP开发环境","slug":"Manjaro-Linux下配置JSP开发环境","date":"2019-09-26T12:35:52.000Z","updated":"2019-09-26T12:35:52.000Z","comments":true,"path":"2019/09/26/Manjaro-Linux下配置JSP开发环境/","link":"","permalink":"http://yoursite.com/2019/09/26/Manjaro-Linux%E4%B8%8B%E9%85%8D%E7%BD%AEJSP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"MyEclipse的安装。","text":"MyEclipse的安装。 0. 环境 Manjaro Linux 18.1.0 JDK 8u221 tomcat 9.0 Myeclipse 2017 ci10 1. 安装JDK 从官网https://www.oracle.com/technetwork/java/javase/downloads/index.html下载JavaSE的tar.gz格式，完成后提取到随便什么地方，例如家目录下。 在~/.bashrc中添加： 1export PATH&#x3D;&#x2F;home&#x2F;oiljhihai&#x2F;jdk1.8.0_221bin:$PATH2export JAVA_HOME&#x3D;&#x2F;home&#x2F;oiljhihai&#x2F;jdk1.8.0_221&#x2F; 此时运行java -version可判断安装情况。 2. 安装MyEclipse MyEclipse是集成了一些包的Eclipse，与后者不同，这是一个收费软件。 获取Myeclipse的.run文件、破解包和汉化包，进入.run文件目录打开终端，chmod +x myeclipse-2017-ci-10-offline-installer-linux.run增加权限，./myeclipse-2017-ci-10-offline-installer-linux.run运行程序安装。装好后取消勾选launch，不要打开。 打开破解包的patch，使用里面的文件替换掉MyEclipse安装目录下的plugins内的同名文件，再进入破解包另一个文件夹打开终端运行java -jar cracker2017.jar，注意该安装包只能运行在java8下，如果最开始安装的JDK是更新的版本，需要用同样的方法安装java8并修改PATH。进入破解软件界面后输入Usercode（任意字母或者数字），后面的下拉列表选择Blue，点击SystemId两次，点击Active，点击菜单栏-&gt;Tools-&gt;saveProperties。此时启动MyEclipse，在help-&gt;subscription information可见产品已激活。 直接使用汉化包中的文件夹合并MyEclipse安装目录中的同名文件夹并替换其中同名文件即可完成汉化。 在首选项中Maven项下关闭一个什么启动更新的项关掉它。 3. 安装tomcat并将之与MyEclipse关联 从官网http://tomcat.apache.org/下载tar.gz包并提取，例如提取到家目录，可在终端执行bin下的startup.sh和shutdown.sh开启和关闭，开启后通过访问http://localhost:8080/可以看到一个页面。 在首选项中服务器项下的运行时环境项下点击&quot;add&quot;的添加按钮，弹出选项，选择与下载的相同的Tomcat版本，&quot;Next&quot;，选择Tomcat的安装目录，并选择安装的Java环境，&quot;Finish&quot;，完成配置。 新建Web Project时注意一下选项中的Target Runtime是否已经自动配制好了。如果不是刚才配制的则需要点后面的New Runtime再添加一次。创建项目时记得在最后一个选项卡勾选Generate Web.xml...那一项。运行新建的Web Project，可以看到一个有一行文字的网页。","categories":[{"name":"戏法","slug":"戏法","permalink":"http://yoursite.com/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://yoursite.com/tags/MyEclipse/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"}]},{"title":"Manjaro Linux主力机的安装与及基本环境配置","slug":"Manjaro-Linux主力机的安装与及基本环境配置","date":"2019-09-23T13:34:18.000Z","updated":"2019-12-07T16:00:00.000Z","comments":true,"path":"2019/09/23/Manjaro-Linux主力机的安装与及基本环境配置/","link":"","permalink":"http://yoursite.com/2019/09/23/Manjaro-Linux%E4%B8%BB%E5%8A%9B%E6%9C%BA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"双显卡笔记本电脑写代码环境的全配置，包括VSCode、Hexo和日常软件。","text":"双显卡笔记本电脑写代码环境的全配置，包括VSCode、Hexo和日常软件。 环境 本文时效性较强，许多配置方式会因软件的更新与迭代而发生变化。 戴尔Inspiron 15-7567笔记本，英特尔i7-7700HQ（集成HD630）+英伟达GTX1050Ti，三星970EVO500G（NVMe）。 使用32G闪迪酷刃U盘引导安装manjaro-GNOME-18.1.0-rc10-stable-x86_64，经测试兼容良好，触控板灵敏，所有功能键均可正常使用（第一次装的时候Fx键直接按是功能键，按Fn键是Fx，第二次装的时候按Fx直接就是Fx，按住Fn才是功能键，奇怪）。 系统安装 制作引导盘 在中科大镜像站https://mirrors.ustc.edu.cn/manjaro-cd/下载iso镜像（manjaro|乐于简单那个网站似乎是个人的……），再在http://rufus.ie/下载引导盘制作工具Rufus，分区类型GPT，目标系统类型UEFI(非CSM)，其余默认，点击开始。检测到ISOHybrid镜像后以DD镜像模式写入，否则系统无法识别。 应当使用尽可能新的系统镜像，这是由于Manjaro是滚动更新，新的补丁仅针对新的环境进行测试，老系统直接更新最新的内容的话很容易滚挂——基于同样的理由，装好系统后平时也应当保持最新。 BIOS设置 开机闪DELL图标时狂按F12（不用按Fn），进入BIOS界面，选择BIOS SETUP进入图形界面进行设置，在出厂设置下修改Secure Boot-&gt;Secure Boot Enable为Disabled，否则会有一系列错误：微软要求预装Windows的PC需要开启Secure Boot，此时操作系统启动过程中涉及到的无CA数字签名的软件比如Linux这种开源的无签名的系统就会被直接阻止；修改System Configuration-&gt;SATA Operation为AHCI，否则系统将无法识别到NVMe的硬盘：AHCI（Serial ATA Advanced Host Controller Interface，串行ATA高级主控接口/高级主机控制器接口）是以Intel为首的多家公司联合研发的接口标准，它允许存储驱动程序启用高级串行 ATA 功能，如本机命令队列和热插拔等。 系统安装 开机进BIOS界面，选择引导盘启动，进入grub界面，选择语言为中文，将光标移动至BOOT那一项上按E编辑启动设置，或进入那个空白的笔记本一样的选项，将driver=free改为（或直接添加，如果选择进入空白的笔记本一样的选项的话）driver=intel xdriver=mesa acpi_osi=! acpi_osi=&quot;Windows 2009&quot;，否则会因默认的开源驱动nouveau与N卡冲突而卡死。按ctrl+x或F12即可启动。 启动后正常安装即可。 关于分区设置，选择默认的清空磁盘选项，如果选择自定义，应当在硬盘开始处设置1MiB空闲空间。安装完成后选择重启，在出现DELL图标后长按Esc键直至进入grub界面（网络上各路教程都说是按住Shift键进入，但经测试该机器下无效），按E进入编辑模式，在quite后添加nouveau.modeset=0，理由同上，按ctrl+x或F12即可启动。这一设置只影响当次启动，因此在配置好驱动前的每次启动都应做此设置。 系统配置 配置pacman Pacman是Arch Linux的包管理器。提供经过测试的完善支持的程序。应当尽可能使用pacman提供的程序，由社区维护的程序可能会出各种奇怪的问题。 sudo pacman-mirrors -i -c China -m rank，随后会弹出一个图形界面，可在其中选择一些源添加。添加并更新sudo pacman -Syy后在国内也可以方便地下载包了。 pacman中的包通过GPG签名，想要安装一个包，则这个包必须通过检查。因此需要先为计算机安装和更新密钥以识别待安装的包：sudo pacman -S archlinux-keyring，sudo pacman-key --refresh-keys。重新加载sudo pacman-key --init、sudo pacman-key --populate并清除缓存sudo pacman -Scc后应当就没问题了。 此时可能出现仍无法进行验证的错误，将/etc/pacman.conf中的SigLevel项都设为Never即可，此选项决定对密钥的检查级别。记得用完改回来。 接下来（可以等省完系统啥的回来再说）配置额外的源： archlinuxcn是由Arch Linux中国维护的提供具有中国特色的包的仓库。 在/etc/pacman.conf添加： 1[archlinuxcn]2SigLevel&#x3D;Optional TrustedOnly3Server&#x3D;服务器地址 以下地址供参考： CDN (ipv4, http, https) Global CDN (no nodes in mainland China)[archlinuxcn] Server= https://cdn.repo.archlinuxcn.org/$arch 浙江大学 (浙江杭州) (ipv4, ipv6, http, https) Added: 2017-06-05[archlinuxcn] Server= https://mirrors.zju.edu.cn/archlinuxcn/$arch 中国科学技术大学 (ipv4, ipv6, http, https)[archlinuxcn] Server= https://mirrors.ustc.edu.cn/archlinuxcn/$arch 清华大学 (ipv4, ipv6, http, https)[archlinuxcn] Server= https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch xTom (Hong Kong) (ipv4, ipv6, http, https) Added: 2017-09-18 xTom Hong Kong Mirror[archlinuxcn] Server= https://mirror.xtom.com.hk/archlinuxcn/$arch Unique Studio (湖北武汉) (ipv4, http, https) Added: 2017-08-02[archlinuxcn] Server= https://mirrors.hustunique.com/archlinuxcn/$arch 上海科技大学 (上海) (ipv4, http, https) Added: 2016-04-07[archlinuxcn] Server= https://mirrors-wan.geekpie.org/archlinuxcn/$arch 中国科学院开源软件协会 (北京) (ipv4, http) Added: 2017-02-09[archlinuxcn] Server= http://mirrors.opencas.org/archlinuxcn/$arch 电子科技大学凝聚网络安全工作室 (ipv4, http) Added: 2016-05-28[archlinuxcn] Server= http://mirrors.cnssuestc.org/archlinuxcn/$arch 网易 (ipv4, http)[archlinuxcn] Server= http://mirrors.163.com/archlinux-cn/$arch 重庆大学 (ipv4, http)[archlinuxcn] Server= http://mirrors.cqu.edu.cn/archlinuxcn/$arch 然后全面更新一下，再sudo pacman-mirrors -g更新源列表，更新密钥环sudo pacman -S archlinuxcn-keyring（可能需要多试几次）后即可使用。 不太建议使用其它的社区源。 不需要配置yaourt，它已经停止维护了。 系统更新 sudo pacman-mirrors -g更新源列表，这可以使pacman找到最新的仓库，更新系统前最好这么弄一下保证源最新；sudo pacman -Syyu刷新并更新系统（如果报错误：同步所有数据库失败，可sudo pkill pacman）。 N卡驱动的安装 在Manjaro Setting Manager-&gt;Hardware Configuration中选择Auto Install Proprietary Driver，等很久很久很久之后即可。 常用应用安装 输入法 在linux中，输入法是依托于输入法框架的。主要有ibus和fcitx两个框架。不像搜狗输入法只能在fcitx上使用，RIME输入法两者皆可。这里使用fcitx上的RIME，尽管fcitx-rime并非由RIME官方维护。 首先安装fcitx：sudo pacman -S fcitx-im，该命令将安装fcitx所有必要的组件。另外，sudo pacman -S fcitx-configtool，这个包为fcitx的设置提供了图形界面。fcitx自带中文输入法，不过很难用。安装RIME：sudo pacman -S fcitx-rime。 接下来添加配置文件，指定在GTK或QT下使用fcitx输入。在~/下新建.xprofile，添加： 1export GTK_IM_MODULE&#x3D;fcitx2export QT_IM_MODULE&#x3D;fcitx3export XMODIFIERS&#x3D;@im&#x3D;fcitx 注意：文件为~/.xprofile，如果当前用户为root则类似nano ~/.xprofile的命令会把文件新建在/root/，这是不行的。 接下来重启即可，应当可以看到屏幕右上角出现了一个键盘样图标，点进去选择配置当前输入法，用+添加中州韻，用-删去其它输入法，重新部署之后就可以使用了。 与小狼毫不同，fcitx-rime的皮肤和相关设置由fcitx决定，不过从fcitx中配置也极为方便，不过我配置完后fcitx菜单中的虚拟键盘/方案列表/输入法/皮肤一栏的下拉菜单弹出后会立即收回无法选中，因为不影响使用就没管；另其外自带双拼配置文件（位于程序文件夹/usr/share/rime-data，若没有，从https://github.com/rime/rime-double-pinyin可下载），只需在用户配置文件夹~/.config/fcitx/rime（若为ibus，则为~/.config/ibus/rime）中新建一个default.custom.yaml，添加： 1# default.custom.yaml 2# save it to: 3# ~&#x2F;.config&#x2F;ibus&#x2F;rime (linux) 4# ~&#x2F;Library&#x2F;Rime (macos) 5# %APPDATA%\\Rime (windows) 67patch: 8 schema_list: 9 - schema: luna_pinyin # 朙月拼音 10 - schema: luna_pinyin_simp # 朙月拼音 简化字模式 11 - schema: luna_pinyin_tw # 朙月拼音 臺灣正體模式 12 - schema: terra_pinyin # 地球拼音 dì qiú pīn yīn 13 - schema: bopomofo # 注音 14 - schema: jyutping # 粵拼 15 - schema: cangjie5 # 倉頡五代 16 - schema: cangjie5_express # 倉頡 快打模式 17 - schema: quick5 # 速成 18 - schema: wubi86 # 五笔 86 19 - schema: wubi_pinyin # 五笔拼音混合輸入 20 - schema: double_pinyin # 自然碼雙拼 21 - schema: double_pinyin_mspy # 微軟雙拼 22 - schema: double_pinyin_abc # 智能 ABC 雙拼 23 - schema: double_pinyin_flypy # 小鶴雙拼 24 - schema: wugniu # 吳語上海話（新派） 25 - schema: wugniu_lopha # 吳語上海話（老派） 26 - schema: sampheng # 中古漢語三拼 27 - schema: zyenpheng # 中古漢語全拼 28 - schema: ipa_xsampa # X-SAMPA 國際音標 29 - schema: emoji # emoji 表情 保存后重新部署即可。 Tim sudo pacman -S deepin.com.qq.office安装即可。这个过程同时安装了wine。也可以使用wine打开其它.exe。sudo pacman -S winetricks后即可方便地添加一些windows上的库，例如winetricks xna40安装mono等。 百度云 sudo pacman -S baidunetdisk，需要多试几次才能登录上。 网易云 网易云客户端虽然是网易云和深度合作的官方客户端，但除了可以下载外体验上似乎与Web端相比没什么优势……平时不如用Web…… 非要下载的话Web也不是不可以，以钢铁洪流为例，地址为https://music.163.com/#/song?id=1394369908，将#/song替换为song/media/outer/url即可右键下载。许多网站提供给一个歌曲id跳转到这一页面的服务，也不算麻烦。 代码环境配置 VSCode sudo pacman -S visual-studio-code-bin，ctrl++调大界面，选项里把bar移到右边。 在Explorer中打开文件夹，比如在家目录新建Workspaces/VSCode作为工作空间。 扩展中安装中文语言包。 设置里强制显示空格和制表符。 Markdown 安装三个插件即可： Markdown All in One Markdown Preview Github Styling Markdown TOC C++ 测试GCC环境和安装GDB GCC即the GNU Compiler Collection，是GNU的一个编译器集合，包含多种编译器及相关工具。其中的gcc是GNU的C编译器(GNU C Compiler)；g++是GNU的C++编译器(GNU C++ Compiler)。也是GNU Compiler Collection的一部分，sudo pacman -S gcc即可。 使用gcc -v确认环境已正确配置。可以nano HelloWorld.cpp尝试写一个HelloWorld，通过g++ HelloWorld.cpp编译。编译完成后会生成一个a.out文档，~/a.out运行它。 除此之外，还需要一个GNU DeBugger即GDB。只需sudo pacman -S gdb即可安装。 在VSCode上运行程序 与在Windows上只需安装一个紫色程序即可高喊M$天下第一实现一切功能不同，在linux下，开发过程中需要使用一系列独立工具配合完成开发。VSCode只是一个文档编辑器，需要进行设置以告诉它怎么和其它工具（也就是前面说的几个）配合工作。 首先安装“C/C++”插件，这可以使它对.c和.cpp文件执行恰当的操作。除此之外，还有如下有用的插件应当安装： Code Runner：编译运行单个文件必备 Bracket Pair Colorizer：大括号变成彩虹色 RainBow Brackets：小括号变成彩虹色 Include Autocomplete：自动补全头文件 C++ Intellisense：不知道是干啥的，但是VSCode推荐了反正 完成之后打开之前的HelloWorld，右键可以运行。但是不能调试，并且头文件那里有可能会标红说找不到。 Code Runner默认使用的是“输出”，这个是只读的，设置中勾上“Run In Terminal”即可在终端中进行cin等操作。 在VSCode上调试程序 在调试选项卡中单击“没有配置”下拉菜单，添加配置，选择C++(GDB/LLDB)。此时会在当前工作区下新建一个launch.json文件并让你设置。另外接下来使用中还会有其它两个需要配置的文件生成。这里不等它们自动生成直接自己手动添加，效果似乎是一样的。 c_cpp_properties.json gcc -v -E -x c++ -搜索includePath，将结果填在下面的&quot;includePath&quot;处，注意添加/*和引号，中间用逗号分隔： 1&#123;2 \"configurations\": [3 &#123;4 \"name\": \"g++\",5 \"intelliSenseMode\": \"gcc-x64\",6 \"includePath\": [7 \"/usr/lib/gcc/x86_64-pc-linux-gnu/9.1.0/include/*\",8 \"/usr/local/include/*\",9 \"/usr/lib/gcc/x86_64-pc-linux-gnu/9.1.0/include-fixed/*\",10 \"/usr/include/*\"11 ],12 \"defines\": [],13 \"browse\": &#123;14 \"path\": [15 \"$&#123;workspaceFolder&#125;\"16 ],17 \"limitSymbolsToIncludedHeaders\": true,18 \"databaseFilename\": \"\"19 &#125;,20 \"cStandard\": \"c11\",21 \"cppStandard\": \"c++17\",22 \"compilerPath\": \"/usr/bin/gcc\"23 &#125;24 ],25 \"version\": 426&#125; 这样就解决了标红的问题。 launch.json： 此文件给出调试时的任务。 1&#123;2 \"version\": \"0.2.0\", //20193 \"configurations\": [4 &#123;5 //配置名称，将会在启动配置的下拉菜单中显示6 \"name\": \"(gdb) Launch\",7 //配置类型，这里只能为cppdbg8 \"type\": \"cppdbg\",9 //请求配置类型，可以为launch（启动）或attach（附加）10 \"request\": \"launch\",11 //将要进行调试的程序也就是前面task生成的那哥们的路径12 \"program\": \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe\",13 //程序调试时传递给程序的命令行参数14 \"args\": [],15 //设为true时程序将暂停在程序入口处16 \"stopAtEntry\": false,17 //下面俩不理解18 \"cwd\": \"$&#123;fileDirname&#125;\",19 \"environment\": [],20 //调试时是否显示控制台窗口21 \"externalConsole\": false,22 //miDebugger的配置，不太懂23 \"MIMode\": \"gdb\",24 \"miDebuggerPath\": \"/usr/bin/gdb\",25 //调试会话开始前执行的任务，要与TASK的名字对应26 \"preLaunchTask\": \"Build\",27 //不知道是干啥的28 \"setupCommands\": [29 &#123;30 \"description\": \"Enable pretty-printing for gdb\",31 \"text\": \"-enable-pretty-printing\",32 \"ignoreFailures\": true33 &#125;34 ]35 &#125;36 ]37&#125; tasks.json： 此文件指定调试前执行的任务。 注意在以下文件中网上文章常用的路径是诸如${workspaceFolder}（比较新）或${workspaceRoot}（比较旧）。这会使编译和调试时在工作目录下生成和调试文件。为了方便在工作目录下使用子文件夹（个人偏好），此处均使用${fileDirname}。 1&#123;2 \"version\": \"2.0.0\",3 \"tasks\": [4 &#123;5 //任务的名字6 \"label\": \"Build\",7 //该任务要执行的命令8 \"command\": \"g++\",9 //参数们，执行时每个之间会用空格空开10 \"args\": [11 \"-g\",12 \"$&#123;file&#125;\",13 //编译$&#123;file&#125;14 \"-o\",15 \"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe\"16 //生成一个位于$&#123;fileDirname&#125;的$&#123;fileBasenameNoExtension&#125;.exe17 ],18 //下面的看不懂了先不管吧19 \"problemMatcher\": &#123;20 \"owner\": \"cpp\",21 \"fileLocation\": [22 \"relative\",23 \"$&#123;fileDirname&#125;\"24 ],25 \"pattern\": &#123;26 \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\",27 \"file\": 1,28 \"line\": 2,29 \"column\": 3,30 \"severity\": 4,31 \"message\": 532 &#125;33 &#125;34 &#125;35 ]36&#125; 至此可以使用VSCode调试C++了。实际调试时如果使用单步调试，遇到cout等时会报/build/gcc/src/gcc-build/x86_64-unknown-linux-gnu/libstdc++-v3/include/bits/ostream.tcc: No such file or directory.。必应了一夜都没找到解决方法，结果谷歌了一下第二条结果就可完美解决： This happens because the ostream source file cannot be found. You can strip the libstdc++ library: 1sudo strip &#x2F;usr&#x2F;lib&#x2F;libstdc++.so.6 And then gdb will not try to open the source file and the error will not appear anymore. You can switch back to the unstripped version by reinstalling it with: 1sudo pacman -S gcc-libs 注意：此操作会导致所有程序退出，并且操作后需要重启，需要先保存并关闭所有其它内容！ 多文件的编译 通常会将头文件分为两个文件，分别用来写实现和声明。例如对于如下的文件结构： 某文件夹 main.cpp header.hpp header.cpp 主程序是main.cpp，header.hpp是一个头文件，但里面的类只是做了声明，具体的实现在header.cpp中。这个时候使用上面的配置就不管用了，因为在这个工程中两个.cpp都需要被编译，而上面的配置（无论是code-runner还是调试）只编译了main.cpp。 对于code-runner，打开VSCode的settings.json（不是.vscode下的那个针对Workspace的），添加一项&quot;code-runner.executorMap&quot;:{}，不出意外的话此时会自动填充好默认的各语言的配置文件。将&quot;cpp&quot;一项改为&quot;cd $dir &amp;&amp; g++ *.cpp -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,，也就是把具体的文件替换为了*.cpp即编译所有.cpp即可。 对于调试，将tasks.json中的&quot;${file}&quot;改为&quot;*.cpp&quot;会提示找不到文件，似乎是因为这里只能使用绝对目录，这特么就很尴尬了，尝试了加一个cd任务先进入文件夹再用*.cpp等很多方法研究了一晚上没找到合适的修改方法，暂时想调试这类工程只能手动在tasks.json中添加除主文件外的其它文件的绝对路径。 后记 在第一次升级系统后执行格式化文档报错。查看C/C++扩展的输出发现报错为： 1Formatting failed:2&#x2F;home&#x2F;oiljhihai&#x2F;.vscode&#x2F;extensions&#x2F;ms-vscode.cpptools-0.26.0&#x2F;bin&#x2F;..&#x2F;LLVM&#x2F;bin&#x2F;clang-format -style&#x3D;&#123; BasedOnStyle: LLVM, UseTab: Never, IndentWidth: 4, TabWidth: 4, BreakBeforeBraces: Allman, AllowShortIfStatementsOnASingleLine: false, IndentCaseLabels: false, ColumnLimit: 0, AccessModifierOffset: -4 &#125; -fallback-style&#x3D;LLVM -sort-includes&#x3D;0 -assume-filename&#x3D;&#x2F;home&#x2F;oiljhihai&#x2F;Workspaces&#x2F;VSCode&#x2F;HDU5396.cpp3&#x2F;home&#x2F;oiljhihai&#x2F;.vscode&#x2F;extensions&#x2F;ms-vscode.cpptools-0.26.0&#x2F;bin&#x2F;..&#x2F;LLVM&#x2F;bin&#x2F;clang-format: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory 可以看出是因为没找到libinfo.so.5。查了一下，这个东西是一个叫“ncurses”的包里的东西。pacman -Ss一下，大概是这次升级将ncurses5升级到了6，所以就找不到了。 pacman -Ss中有两个跟nurses5有关的，先装了第一个看起来像是32位版的sudo pacman -S lib32-ncurses5-compat-libs，没什么用；又试了第二个sudo pacman -S ncurses5-compat-libs，问题解决。 Python 安装插件 Python Python-autopep8 再结合之前已经装好的Code Runner，就可以运行py程序了。 运行过程中VSCode会提示要装其它什么东西，装就行了，可能网不好会失败几次。 右键格式化，提示装些东西，选autopep8比较好用。 安装Anaconada 在https://repo.continuum.io/archive/下载.sh文件，在文件目录bash xxxx.sh。安装没问题的话which python可以得到路径。由于路径被配置在了~/.bashrc，需要source ~/.bashrc一下。 注意下载Anaconda3，一开始下成了2之后还有点小麻烦……由于是先装了2，再装了3，3的路径就没添加上，所以卸掉2后按升级的方法重装了3：bash xxxx.sh -u；卸载的方法是删掉安装文件夹并删掉bashrc中自动生成的那一段信息。 在VSCode中打开一个.py，下方显示文件类型的地方点一下，选配置，在json中添加Anaconda的路径和其它设置选项： 1\"python.pythonPath\": \"&lt;which python的结果，类似/home/oiljhihai/anaconda3/bin/python，系统自带的py位于/user/bin/python&gt;\",2 \"python.autoComplete.extraPaths\": [3 \"&lt;应该差不多是形如~/anaconda3/lib/python3.7/site-packages，找一下这个文件夹&gt;\"4 ],5 \"python.linting.flake8Enabled\": false,6\"python.formatting.provider\": \"autopep8\",7//禁用自动换行8 \"python.formatting.autopep8Args\": [9 \"--max-line-length=200\",10 ],11 \"python.testing.unittestEnabled\": true,12 \"python.testing.pytestEnabled\": true,13 \"python.testing.nosetestsEnabled\": false, 安装OpenCV 在终端进入Python，运行： 1import pip._internal2print(pip._internal.pep425tags.get_supported()) 可以查看当前py版本所支持的包。在https://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv或清华镜像https://pypi.tuna.tsinghua.edu.cn/simple/opencv-python/找到符合条件的包，丢到前面的&quot;python.autoComplete.extraPaths&quot;:填的目录下直接pip install opencv_python-xxxxxx.whl即可。 以下不用看，把opencv版本搞错了。 conda install --channel https://conda.anaconda.org/menpo opencv3即可安装，但过程中报错“Unsatisfiable Error”。大体意思是版本不对应。可以根据详细的报错信息判断出目前的Python是3.7，而openCV只支持到3.6。解决办法是安装3.6的环境conda create -n python3.6 -c menpo configparser。 安装完毕后电脑上同时有python3.7和3.6，其中3.7位于前面说的位置，3.6位于~/anaconda3/envs/python3.6/bin/python，bashrc只记录了3.7的路径。于是通过conda activate python3.6进入3.6的环境，再次安装即可。安装完毕后python进入写python代码模式，import cv2不报错就是装好了。 conda deactivate退出python3.6。 进入VSCode，此时VSCode还在用3.7的路径，所以不能写openCV。用3.6的路径替换一下就OK了。这时运行.py还是先在终端默认的3.7运行，报错后VSCode会自动根据设定的路径conda activate python3.6。 通过： 1import cv22img = cv2.imread('~/Workspaces/VSCode/test/test.jpeg',cv2.IMREAD_COLOR)3cv2.imshow('image',img)4cv2.waitKey(0)5cv2.destroyAllWindows() 测试。然而如果用相对路径会报错“OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in imshow”，没查到为啥（另外网上说中文路径、图片不在工程文件夹内都会报错。这也太WEAK了吧……）。但是这样的话目录啥的变了直接凉凉啊，研究半天，这里可以用路径获取+格式化输出： 1import os2path=os.path.dirname(os.path.abspath(__file__))3img0=cv2.imread(r'%s/mipha.jpg'%path) Hexo+GithubPages博客配置 Hexo基本环境的配置 hexo依赖于git和node.js。 manjaro自带git，可git查看详情。 hexo官方建议使用node.js的管理工具nvm安装node.js（nvm是管理node.js的版本的工具，npm是node.js管理它的包的工具）。尝试了官方https://github.com/nvm-sh/nvm给出的curl -o- https://raw.githubusercontent.com/creationix/nvm/v.xx.xx.xx/install.sh | bash（xx为当前版本号）命令，访问会被拒绝。经测试可用 1git clone https://github.com/creationix/nvm.git ~/.nvm &amp;&amp; cd ~/.nvm &amp;&amp; git checkout `git describe --abbrev=0 --tags` 命令安装，可以看出这里是把它装到了/.nvm下。完成后在~/.bash_profile~【更新：~/.bashrc下（否则重启终端后需要source ~/.bash_profile，不然会提示没有npm这个命令。官方教程说~/.bashrc, ~/.zshrc, ~/.bash_profile, ~/.profile都可以】中添加环境变量： 1export NVM_DIR=\"$HOME/.nvm\"2[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\"3export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node 注意地址与安装地址相匹配。最后一行是淘宝镜像源，根据需求添加，也可在调用npm时NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm install node。保存后source ~/.bash_profile即可使用nvm和node命令。 然后使用NVM安装node.js，只需nvm install node，这样npm也可以使用了。 进行一下设置： 1npm config set user 02npm config set unsafe-perm true3npm config set registry https://registry.npm.taobao.org 不设置前两个的话会报Permission denied，进度条卡在最开始不动，最后一个是镜像源。至此可以使用npm命令下载node包。 Hexo的安装与初始化 npm install -g hexo-cli，可使用hexo -v查看安装结果。 从github上下载网页的代码hexo init &lt;folder&gt;后在&lt;folder&gt;/安装所需的依赖npm install，之后hexo -s就可以看到网页了。考虑使用~/blog作为文件夹。 写博客 在Hexo目录下hexo new [类型] &lt;&quot;博客名&quot;&gt;，类型缺省时为新建一篇博客post（另两种是新建页面page和新建草稿draft）。这其实就是将模板文件blog/scaffolds/对应类型的内容复制过来并重命名为博客名.md。默认post新建博客类型的模板为以下内容： 1---2title: &#123;&#123; title &#125;&#125;3date: &#123;&#123; date &#125;&#125;4tags:5--- 其中前两项生成时会自动填写，tags一项的填写格式为 1tags: [标签1,标签2,...]2或3tags:4 - 标签15 - 标签26 - …… 编辑保存后hexo g即可。运行hexo s可查看。 除默认配置外，有必要添加如下内容。 categories:，分级目录属性。与tags属性不同，其可以划分父子级关系。例如： 1---2title: 怎么拿长老知识3...4categories: 5 - 游戏6 - 遗迹：灰烬重生7...8--- &lt;!--more--&gt;，此标签之后的部分将被隐藏，点进去才能看，对NexT很有用。 ~~thumbnail:（如果主题支持文章封面），后跟图片链接即可。经测试，使用450*212的图片作为主题“Hueman”的封面可以获得比较好的画质，体积也只有20至30KB。~~之前用的Hueman，现在NexT不支持，不过可以在&lt;!--more--&gt;前放，格式更随意，横向两百多像素效果就不错，接着用212吧，嗯，水的华氏温标沸点……算是个整数？ updated: 1569245658000更新日期。 最终效果如下： 1---2title: &#123;&#123; title &#125;&#125;3date: &#123;&#123; date &#125;&#125;4updated: &#123;&#123; date &#125;&#125;5tags: 6categories: 7mathjax: false8---910![]()1112&lt;center&gt;&lt;/center&gt;1314&lt;!--more--&gt; 站点的配置 在blog/有一_config.yml文件，其保存有站点相关的设置。 开头是Site模块： 1# Site2title: 标题，会显示在浏览器标签栏上3subtitle: 副标题4description: 描述5keywords:6author: 作者7language: 语言（简中：zh-CN；不同主题不同，例如NexT中似乎叫zh-Hans）8timezone: 网站时区，默认使用电脑的无需改动 剩下的似乎不是太用改，例如URL模块似乎是当网站放在子目录下时用的等等。 当此配置文件与主题的配置文件冲突时，此配置文件将覆盖主题的配置文件。 hexo的文章是.md经过swig转换成的html，生成的html中的空格和注释会影响JS的性能，可在blog/安装hexo自带的neat插件npm install hexo-neat --save进行压缩。安装插件后在站点配置文件中添加： 1# hexo-neat2# 全局开关3neat_enable: true4# 压缩html5neat_html:6 enable: true7 exclude:8# 压缩css 9neat_css:10 enable: true11 exclude:12 - '**/*.min.css'13# 压缩js14neat_js:15 enable: true16 mangle: true17 output:18 compress:19 exclude:20 - '**/*.min.js'21 - '**/jquery.fancybox.pack.js'22 - '**/index.js' exclude项是跳过压缩的文件。 【更新】neat突然会报错了，暂且设为false。 主题的配置 如果想要换主题，首先找到一个主题，下载可得一个压缩包解压到themes文件夹下即可。注意很多主题同时会有WordPress和Hexo两个版本，不要下错。 曾经长期使用Landscape（2018年）和Hueman（2019年）两个主题。Landscape作为默认主题，简约大气，自己改一下图片啊配色啊啥的相当不错，但支持的功能略少；Hueman算是杂志风格，支持的功能也很多，但总感觉侧边栏和选项卡功能重复，不够简约，而且一些符号显示会出错，默认的代码块也很丑。目前使用最大众化的NexT主题。 该主题仓库位于这里，参照说明安装即可。 使用主题文件夹下多出的文件夹的名字替换掉博客根目录下的_config.yml中theme项的内容后hexo g即可，注意theme:后应当有一个空格。 这里是一份较早前版本的参考文档，具有一定参考性，但已有部分设置与最新版本有偏差。 主题的_config.yml需要设置的项主要有一下一些： 修改风格项Schemes。 为侧栏增加标签页、分类页和关于页，将menu下对应项的注释取注，并按上述文档生成前两者页面即可。后者通过hexo new page &quot;about&quot;，在其内写入： 1---2title: about3date: 2019-09-23 18:13:294---5正文 来实现。 显示当前浏览进度scrollpercent置为true。 启用本地搜索只需npm install hexo-generator-searchdb --save并设置： 1# Local search2local_search:3 enable: true 添加： 1search:2 path: search.xml3 field: post4 format: html5 limit: 10000 设置头像只需简单修改Sidebar Avatar字段。 这个主题还提供了评论功能，有许多可选的服务提供商，不过没什么卵用。国内的要么倒闭了要么需要实名制，国外的又要扶墙…… 【更新】发现了一个比较好用的服务商，棒子的“来必力”。只需正常步骤注册即可获得一段代码，用此代码替换掉主题中的layout/comment/livere.ejs中的内容，再在主题配置文件中禁用comment项下的所有评论工具，在comment项外，比如上面一行添加livere_uid: xxxxxxxx，其中xxxxxxx为获取的代码中提供的UID。再将主题中的layout/common/article.ejs中最后一行&lt;%- partial('comment/index') %&gt;改为&lt;%- partial('comment/livere') %&gt;即可。【更新】划去部分针对Hueman。NexT只需在主题配置文件下找到livere_uid:填上代码中的UID即可。 添加网站访问数统计只需在xx-analysis项添加从分析网站比如百度分析、谷歌分析等等网站获得的哈希值即可。注册帐号后根据提示操作即可获得一段JS代码，哈希值在其中。但这类网站只能站主登录进去查看自己网站的访问情况。若想在网站中显示访问数，可使用不算子，注意footer文件的位置可能与官方描述有差别。不蒜子自身只提供标签与数字，具体内容由用户编辑。使用官方给出的简易程序对footer做如下修改将统计显示在页脚：【更新】划去部分针对Hueman，Next集成不算子，只需调整busuanzi_count项即可。 如果想要开启RSS订阅，首先需要安装RSS插件npm install hexo-generator-feed --save，并在站点配置文件中添加RSS支持： 1# RSS订阅支持2plugin:3 - hexo-generator-feed4feed:5 type: atom #RSS的类型(atom/rss2)6 path: atom.xml #文件路径,默认atom.xml/rss2.xml7 limit: 20 #展示文章的数量,0或false展示全部 最后将主题配置文件中的rss项改为rss: /atom.xml可开启RSS订阅，可在public/见atom.xml。 字体配置先找到font并启用，这样就可以自定义字体怎么用而不是通过默认的谷歌字库外链加载默认字体。全局设置使用思源黑体，谷歌和奥多比联合开发，品质保证！code要以等宽字体显示所以需要设置为等宽字体，“Fira Code”虽然样子只能说还行，但提供了极好的连字模式，如果只是想表示\\(\\rightarrow\\)之类可以直接代码块-&gt;，非常方便。缺点是会给读者造成误解，管它呢，这破博客本身就是写了自嗨的。可选择字库外链，中科大的地址是//fonts.lug.ustc.edu.cn，速度勉强，偶尔会崩。 部署至GitHub 安装hexo的插件：npm install hexo-deployer-git --save。 在github中建立一个以自己名字命名的仓库，建好后将_config.yml中的`deploy项替换为： 1deploy:2 type: git3 repository: 建好仓库后给出的地址中git格式那个复制一下粘过来4 branch: master 首先配置git用户名git config --global user.name &quot;&lt;用户名&gt;&quot;和邮箱git config --global user.email &quot;&lt;邮箱&gt;&quot;，这会生成一个~/gitconfig文件，想改的话直接改这个文件就行。然后获取SHH密钥ssh-keygen -t rsa -C &quot;&lt;前面的邮箱&gt;&quot;，一路回车即可，之后会生成一个~/.ssh文件夹，其中有一个私钥id_rsa和一个公钥id_rsa.pub，将公钥添加至github。从github网页右上角的下拉菜单里的settings中添加。 如果ssh -T git@github.com后（第一次连接时中间需要yes一下）出现You've successfully authenticated, but GitHub does not provide shell access.说明OK了，使用hexo d即可部署网页。 域名解析 终端ping -4 用户名.github.io可以获得GitHub Pages的服务器地址。 在提供域名解析的网站的控制台，设置主机记录www，记录类型为A，记录值为刚才ping得的地址。再设置一条主机记录@，记录类型为CNAME，记录值是用户名.github.io。这两条分别意味着将购买的域名指向一个IPv4地址和另一个域名。 在blog/source/建立CNAME文件，写入购买的域名。进入GitHub中的博客仓库。在仓库的Setting-&gt;Custom domain添加域名后保存即可。 使用LaTex语法 在主题配置文件中开启“mathjax”一项为true即可使用LaTex语法，某些主题可能还需要将“math”开启，可选择是每个页面都开启还是需要手动开启。 注意，与正常使用Markdown不同，Hexo不支持LaTex，mathjax并非对.md渲染，而是渲染Hexo生成的Html。因此要确保Hexo不会误将LaTex标记渲染为Html标签。一种方法是在公式块中使用Markdown语法符号时使用转义，更一劳永逸的方法是更换Hexo的渲染引擎。 默认的渲染引擎“hexo-renderer-marked”可通过npm uninstall hexo-renderer-marked --save卸载，npm install hexo-renderer-pandoc --save，即可更换成另一个表现较好的引擎。与许多人推荐的npm install hexo-renderer-kramed --save相比，该引擎表现更好，无需额外修改一些配置文件。 【更新】发现无法渲染形如\\(\\xRightarrow[aaa]{bbb}\\)的格式。暂时用\\(\\Rightarrow_{aaa}^{bbb} \\Rightarrow\\)这样子代替。 看板娘 可以使用 Live 2D 为博客增添一个 2D 角色。 首先检查package.json里是否已安装&quot;hexo-helper-live2d&quot;，有的话可以先npm uninstall hexo-helper-live2d，官方称“THIS PACKAGE IS DEPRECATED BECAUSE IT WON'T ADD DEPENDENCIES ON YOUR PRODUCTION ENVIRONMENT”。 安装npm install --save hexo-helper-live2d后node_moduels/会生成配置文件夹live2d-widget。 https://github.com/xiazeyu/live2d-widget-models.git提供了可用的模型，前缀为live2d-widget-model-haru的模型需要npm install live2d-widget-model-haru支持。 以一只黑猫的模型为例，npm install live2d-widget-model-hijiki后配置博客站点配置文件_config.yml，添加： 1live2d:2 enable: true3 pluginModelPath: assets/4 model:5 use: live2d-widget-model-hijiki #模板目录，在node_modules里6 display:7 position: right #位置只能调上下和靠左靠右 具体多靠左多靠右不能调8 width: 200 #大小9 height: 290 #上下位置10 mobile:11 show: false #是否在手机进行显示 即可。这个位置大小是NexT的那个两栏的模式+黑猫我精心调之后觉得最合适的。 尾声 完成以上配置后的manjaro已经可以正常使用了。可以从优化中设置GNOME桌面的样式——不过默认外观已经很好看了，但是在拓展中可以启用GNOME的一些有用插件，例如显示在上方工具条中的许多有用工具。 Windows系统中的字体可以直接拿过来安装，非常方便；如果只是在Libre Office下用的话只拷贝到～/.config/libreoffice/4/user/fonts下也可以在Libre Office中用。如果没有fonts目录新建即可。 若报未找到strip分割所需的二进制文件，似乎是由于缺少编译器，sudo pacman -S core/binutils可安装酷睿的binutils工具集，或安装gcc。","categories":[{"name":"戏法","slug":"戏法","permalink":"http://yoursite.com/categories/%E6%88%8F%E6%B3%95/"}],"tags":[{"name":"Manjaro","slug":"Manjaro","permalink":"http://yoursite.com/tags/Manjaro/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"VSCode","slug":"VSCode","permalink":"http://yoursite.com/tags/VSCode/"},{"name":"Anaconda","slug":"Anaconda","permalink":"http://yoursite.com/tags/Anaconda/"}]}]}