<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/logo128.jpg"><link rel="icon" type="image/png" sizes="32x32" href="/images/logo32.jpg"><link rel="icon" type="image/png" sizes="16x16" href="/images/logo16.jpg"><link rel="mask-icon" href="/images/tag512.jpg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.useso.com/css?family=Noto Sans:300,300italic,400,400italic,700,700italic|Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("http://mechanicalmind.cn").hostname,root:"/",scheme:"Muse",version:"7.6.0",exturl:!1,sidebar:{position:"right",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="包括进程、死锁和作业调度相关内容。"><meta name="keywords" content="操作系统,进程,死锁"><meta property="og:type" content="article"><meta property="og:title" content="操作系统・壹・处理机管理"><meta property="og:url" content="http:&#x2F;&#x2F;mechanicalmind.cn&#x2F;posts&#x2F;4c0c7f47.html"><meta property="og:site_name" content="Mech_Mind&#39;s blog"><meta property="og:description" content="包括进程、死锁和作业调度相关内容。"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-12-24T16:00:00.000Z"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://mechanicalmind.cn/posts/4c0c7f47.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>操作系统・壹・处理机管理 | Mech_Mind's blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Mech_Mind's blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Mech_Mind's blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Proletoj el ĉiuj landoj, unuiĝu!</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> Archives</a></li><li class="menu-item menu-item-tools"><a href="/tools/" rel="section"><i class="fa fa-fw fa-briefcase"></i> Tools</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans"><link itemprop="mainEntityOfPage" href="http://mechanicalmind.cn/posts/4c0c7f47.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/logo512.jpg"><meta itemprop="name" content="Mechanical_Mind"><meta itemprop="description" content="敲键盘 按快门 巡星空"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Mech_Mind's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 操作系统・壹・处理机管理</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-12-24 15:35:40" itemprop="dateCreated datePublished" datetime="2019-12-24T15:35:40+08:00">2019-12-24</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-12-25 00:00:00" itemprop="dateModified" datetime="2019-12-25T00:00:00+08:00">2019-12-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%B7%B1%E8%93%9D/" itemprop="url" rel="index"><span itemprop="name">深蓝</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%B7%B1%E8%93%9D/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span></span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">Views:</span><span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">Symbols count in article:</span> <span>13k</span></span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">Reading time &asymp;</span> <span>11 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src=""></p><center> 包括进程、死锁和作业调度相关内容。</center><a id="more"></a><h1 id="顺序与并发执行的描述">顺序与并发执行的描述</h1><p>说一个程序是顺序执行的，意味着其每个程序段是依次执行的，且每个程序段内的所有指令也是依次执行的。这种程序运行时<strong>独占全机资源</strong>，<strong>执行结果不受外界影响</strong>。</p><p>使用前驱图描述程序执行的先后顺序。前驱图是一个有向图，节点为一个程序或语句（或进程），如果一个节点必须在另一个节点执行后才能执行，就从后者引一条边至前者。称后者是前者的<strong>前驱</strong>。前驱图应当是无环的。</p><p>如果两节点间没有前驱关系（直接或间接），它们就可以并发地执行。</p><p>并发执行的程序为了满足同时段内执行的内容没有前驱关系，进程间可能要相互等一等之类，会有执行的“<strong>间断性</strong>”；由于是多个程序并发地在跑，因此全机资源不是被独占的，一个程序跑的时候可能修改了另一个程序的数据之类，<strong>失去了封闭性</strong>，也意味着可能两次输入相同的运行的输出不一样，出现<strong>不可再现的、与时间有关的错误</strong>。</p><h1 id="进程的基本概念">进程的基本概念</h1><p>传统意义上，进程是程序在一个数据集上的运行过程，是系统进行资源分配和调度的一个独立单位。其实体由程序段、相关的数据段和进程控制块（PCB）构成。</p><p>与程序不同，程序只是一堆死的代码，是静态的；而进程是“运行过程”，讲的是个<strong>动态的</strong>概念（就是因为动态所以才会出不可再现的错误，一般意义上不会认为程序会出不可再现的错误对吧）。这是它最本质的特征。</p><p>多个进程互相<strong>独立</strong>地运行、分配资源、接受调度，共同存在于内存中，且可以<strong>并发</strong>执行。但执行是<strong>异步</strong>的。</p><p>如果一个进程万事俱备只欠处理机资源，就叫它是<strong>就绪（Ready）</strong>的；给了处理机资源跑起来了，就叫它在<strong>执行（Running）</strong>，规定的时间片结束后回到就绪态等待下一次进程调度；前面说了并发执行有间断性，一个进程等的时候就叫<strong>阻塞（Blocked）</strong>，一般是执行态时进入阻塞态，此时处理机去执行其它进程，这个进程等好后进入就绪态。</p><p>除以上三种基本状态外，进程在创建时叫创建状态，此时申请并填写PCB、分配资源，完成后进入就绪状态；终止时叫终止状态，善后处理，清零PCB之类；还有种挂起状态。</p><h1 id="os对进程的描述">OS对进程的描述</h1><p>OS使用进程控制块记录一个进程。包含如下信息：</p><ul><li>进程标识符，包括编号（OS根据这个使用进程，其它都是给用户看的）、名字、对应父进程子进程的标识和用户标识（谁拥有此进程）等；</li><li>处理机状态，保存各寄存器的内容，中断后好恢复；</li><li>进程调度信息，进程当前状态、优先级和其它信息，例如现在阻塞了为啥阻塞的、进程等了多久、总共跑了多久之类；</li><li>进程控制信息，程序和数据的地址、有关进程同步和通信的信息、该进程需要哪些资源已经分配了哪些资源、指向PCB中下一个进程的指针。</li></ul><p>一般OS用链接方式或索引方式组织PCB。链接方式即弄三个队列，分别对应就绪的、阻塞的和空白的PCB，还有一个指针指向正在执行的进程；索引就是用表来实现。</p><h1 id="进程控制">进程控制</h1><p>进程控制包括创建进程、终止进程和进程状态转换 是进程管理最基本的功能，由OS内核完成。</p><h2 id="创建进程create">创建进程（Create）</h2><p>一个进程创建另一个进程，有如下情况：</p><ul><li>用户登录，用户登录OS时OS内核为该用户创建一个进程，插入就绪队列；</li><li>作业调度，多道批处理里面该调度个新程序开始跑时OS内核就给它创建一个进程；</li><li>提供服务，用户程序要求某种请求时OS内核为这个服务创建一个进程，这样这个服务和用户程序也是可以并发的，比方说Word，并不是说打印的时候就不能操作了；</li><li>应用请求，应用程序可以请求创建进程。</li></ul><p>Unix中把创建进程的进程称为父进程，被创建的进程称为子进程，子进程继承父进程的资源，销毁父进程时子进程一并销毁。Windows中不存在此概念，每个进程有一个句柄决定它可以控制哪些其它进程。</p><p>创建进程时，OS调用进程创建原语创建进程。首先申请空白PCB，然后为新进程分配内存等，然后初始化PCB，最后插入就绪队列。</p><h2 id="终止进程">终止进程（）</h2><p>一个进程被终止，有如下情况：</p><ul><li>正常结束，程序里专门有条指令调用系统中端告诉OS我好了；</li><li>异常，程序试图越界访问资源、调用非法指令、运行或等待超时、算术运算错误等情况；</li><li>外界干预，例如发生系统死锁，就只好由OS或操作者看看能不能救，或父进程被销毁于是子进程被株连，或父进程清理门户。</li></ul><p>终止进程时，OS调用进程终止原语终止进程。首先找到它，确定状态，要是还在执行就先停掉并置调度标志为真待会下一个就绪的进程好跑；看看有没有子进程，有的话一并终止；归还资源，移出队列。</p><h2 id="进程的阻塞与唤醒blockwakeup">进程的阻塞与唤醒（block/wakeup）</h2><p>一个进程被阻塞，有如下情况：</p><ul><li>请求系统服务，但系统暂时无法提供；</li><li>启动某种操作，某种必须做完才能继续的操作，例如等待I/O；</li><li>等数据之类；</li><li>无事可做。</li></ul><p>阻塞进程时，进程主动调用阻塞原语把自己阻塞。首先停止执行，接下来修改PCB状态为阻塞，并将PCB插入阻塞队列，保存现场，重分配处理机。</p><p>唤醒进程时，将之移出阻塞队列，修改PCB状态为就绪，插入就绪队列。</p><h2 id="进程的挂起与激活suspendactive">进程的挂起与激活（suspend/active）</h2><p>挂起进程时，调用挂起原语。首先检查其状态。若处于活动就绪或执行状态，则将其转为静止就绪；若处于活动阻塞,则将其转为静止阻塞。将PCB放到特定内存区域，如果之前该进程在执行，就重新调度。</p><p>激活进程时，将进程从外存调入内存，检查其状态，若是静止就绪，则改为活动就绪；若是静止阻塞，则改为活动阻塞。若采用的是抢占式调度策略，则还应检查被激活就绪进程的优先级，若其优先级比先行执行进程高，则应将处理机分配给被激活进程。</p><h1 id="进程同步">进程同步</h1><p>为避免异步，需要进程同步。</p><p>多个进程间可能存在制约关系导致异步。对于多个进程的共享资源，如打印机，各进程应当互斥地访问，一般必须向系统提出申请，由OS分配，叫间接制约；对于不许经过系统直接就能访问的资源的制约关系，如两个进程都需用到某个缓冲区，叫直接制约。</p><p>在一段时间内只能由一个进程访问的资源（硬或软）叫临界资源。访问临界资源的循环进程描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">while(true)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    非临界区，其它代码；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    进入区，检查资源是否正被访问；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    临界区，访问临界资源；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    退出区，将正被访问标志恢复至未被访问；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    非临界区，其它代码。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>一个同步机制，应当保证临界资源未被访问时可以被访问，正被访问时无法被访问；要求访问临界资源的进程在有限时间内可以访问得到，进程等待访问临界区时处理机给其它进程用（否则叫“忙等”）。</p><h2 id="常用进程同步机制">常用进程同步机制</h2><h3 id="硬件同步机制">硬件同步机制</h3><p>利用特殊的硬件指令解决临界区问题。</p><ul><li>关中断</li><li>利用Test-and-Set指令</li><li>利用 Swap指令</li></ul><p>缺陷：</p><ul><li>忙等</li><li>难于解决进程同步问题</li></ul><h3 id="信号量机制">信号量机制</h3><p>Dijkstra提出了整型信号量机制，后来慢慢发展，先是记录型信号量，然后AND型信号量，再然后信号量集，卓有成效且应用广泛。</p><p>最初信号量是一个整型<code>S</code>，表示资源数目。被用一个就减一，释放一个就加一。当有程序想访问资源时就死循环地看还剩几个资源，直到资源数大于零时跳出循环使用资源。这里如果得不到资源无法让出处理机给其它进程用，会导致忙等。</p><p>记录（即结构体）型信号量由一个代表临界资源数目的整型变量<code>value</code>和该资源上阻塞的队列（链表）指针<code>L</code>构成。<code>value</code>和整型信号量中的<code>S</code>意义相同。当发现资源数小于等于零时，不是一直死循环地看资源数直到大于零，而是调用阻塞原语自我阻塞，并把自己插入至<code>L</code>，<code>value</code>自减。也就是说，<code>value</code>为负数时，其相反数为被阻塞的进程数。释放资源时如果发现<code>value</code>小于零，就唤醒一个阻塞队列中的进程。</p><p>把资源的请求和释放写成函数，大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Semaphore</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    PCB* <span class="built_in">list</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;S;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(S)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    S.value = S.value – <span class="number">1</span> ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>  ( S.value &lt; <span class="number">0</span> ) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        block (S.<span class="built_in">list</span>) ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* 让权等待 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span> <span class="params">(S)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    S.value = S.value + <span class="number">1</span> ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>  ( S.value &lt;= <span class="number">0</span> )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        wakeup (S.<span class="built_in">list</span>) ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*唤醒第一个等待的进程 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>若有<code>n</code>个进程<code>m</code>个资源，信号量的可能范围就是<code>m~(m-n)</code>。</p><p>利用信号量机制实现进程互斥地访问临界资源，只需将<code>S.value</code>初值设为1，将<code>wait(S)</code>作为进入区、<code>signal(S)</code>作为退出区。</p><p>除了利用信号量机制控制资源的访问、实现进程互斥外，还可以用来实现前驱关系。</p><h3 id="管程机制">管程机制</h3><p>略。</p><h2 id="经典进程同步问题">经典进程同步问题</h2><h3 id="生产者-消费者问题">生产者-消费者问题</h3><p>生产者生产东西，放到缓冲区，消费者从缓冲区拿东西。生产者放东西到缓冲区前会先看一眼，如果满了，就不放；消费者拿东西前也会看一眼，如果没了，就不拿。</p><p>看起来没什么问题。写成程序就有问题了。</p><p>用一个<code>cnt</code>记录缓冲区的东西数量，生产者或消费者先读<code>cnt</code>的值，再改变它。改变<code>cnt</code>值的过程通常是如下的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV 存储器,寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">INC 寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOV 寄存器,存储器</span></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">MOV 存储器,寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">DEC 寄存器</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">MOV 寄存器,存储器</span></pre></td></tr></table></figure><p>如果第二个MOV前插入了其它指令比如另一个进程的第一个MOV指令，就会出错。</p><p>比如初值为1时，如果并发地执行这两坨指令，有可能得到0或1或2三种结果。</p><p>回到生产者-消费者问题，由简单到复杂有多种情况：</p><ul><li>一个生产者、一个消费者、缓冲区可以放一个东西的问题；</li><li>一个生产者、一个消费者、缓冲区可以放若干东西的问题；</li><li>若干生产者、若干消费者、缓冲区可以放若干东西的问题。</li></ul><p>对于最简单的情况，为同步双方设置各自的信号量，初值为其初始状态可用的资源数；增加进入区和退出区，同步双方任一进程在进入临界区之前，应先对自己的信号量执行<code>wait(&lt;己方信号量&gt;)</code>操作，以测试是否有自己可用的资源，若有资源可用，则进入临界区，否则阻塞；同步双方任一进程离开临界区后，应对对方的信号量执行<code>signal(&lt;对方信号量&gt;)</code>操作，以通知对方已有资源可用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">item buffer;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者和消费者的信号量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">semaphore empty,full;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者最初信号量为1，可以向缓冲池放一个产品</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">empty.value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者最初信号量为0，没有东西可拿</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">full.value=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cobegin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process <span class="title">Producer</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        produce an item in nextp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//测试能不能放东西</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        wait(empty);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//nextp放入buffer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        buffer=nextp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//通知被阻塞的消费者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        signal(full);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process <span class="title">Consumer</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//测试能不能拿东西</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        wait(full);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//buffer内的东西拿到nextc</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        nextc=buffer;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//通知被阻塞的生产者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        signal(empty);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        consume the item in nextc;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">coend</span></pre></td></tr></table></figure><p>若缓冲区可放k个东西，只需将生产者的初值记为k即可。另外为生产者和消费者分别提供一个下标指定其访问的缓冲区位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">item buffer[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者和消费者的信号量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">semaphore empty,full;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者最初信号量为k，可以向缓冲池放k个产品</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">empty.value=k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者最初信号量为0，没有东西可拿</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">full.value=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前下标都是0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in=<span class="number">0</span>,out=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">cobegin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process <span class="title">Producer</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        produce an item in nextp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//测试能不能放东西</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        wait(empty);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//nextp放入buffer[in]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        buffer[in]=nextp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//计算下一个位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        in=(in+<span class="number">1</span>)%k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//通知被阻塞的消费者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        signal(full);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process <span class="title">Consumer</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//测试能不能拿东西</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        wait(full); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//buffer[out]内的东西拿到nextc</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        nextc=buffer[out];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//计算下一个位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        out=(out+<span class="number">1</span>)%k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//通知被阻塞的生产者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        signal(empty);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        consume the item in nextc;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">coend</span></pre></td></tr></table></figure><p>对于最复杂的情况，连下标的<code>in</code>和<code>out</code>都会出现冲突了，因为不止一个生产者、不止一个消费者，所以访问<code>in</code>和<code>out</code>也需要。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">item buffer[n] ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//in和out的信号量、生产者和消费者的信号量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">semaphore mutex,empty,full;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前下标都是0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>，out = <span class="number">0</span> ；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个下标最初信号量为1，可以被一个生产者或消费者访问</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">mutex.value = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者最初信号量为k，可以向缓冲池放k个产品</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">empty.value=k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者最初信号量为0，没有东西可拿</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">full.value = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">cobegin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process <span class="title">produceri</span><span class="params">()</span><span class="comment">//(i=1,2,…,k)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        item nextp ；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (TRUE)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#123;   ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            produce an item in nextp；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            wait(empty)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            wait(mutex)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            buffer[in] = nextp ；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            in = (in + <span class="number">1</span>)% n ；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            signal(mutex)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            signal(full)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    process consumerj()<span class="comment">//(j=1,2,…,m)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#123;  item nextc ；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (TRUE)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            wait(full)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            wait(mutex)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            nextc = buffer[out] ；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            out = (out + <span class="number">1</span>)% n ；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">            signal(mutex)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            signal(empty)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            consume the item in nextc ；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">coend</span></pre></td></tr></table></figure><h3 id="哲学家就餐问题">哲学家就餐问题</h3><p>有5个哲学家共用一张圆桌，分别坐在周围的5张椅子上，在圆桌上有5个碗和5只筷子（每人面前一只碗，左右手边各一双筷子），他们的生活方式是交替地进行思考和进餐。平时，每个哲学家进行思考，饥饿时便试图拿起其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐完毕，放下筷子继续思考。</p><p>5个筷子用五个信号量表示即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">chopstick[<span class="number">0</span>].value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">chopstick[<span class="number">1</span>].value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">chopstick[<span class="number">2</span>].value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">chopstick[<span class="number">3</span>].value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">chopstick[<span class="number">4</span>].value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cobegin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process  <span class="title">Pi</span><span class="params">()</span><span class="comment">//(i = 0，1，2，3，4)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//拿起左边筷子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            wait(chopstick[i])；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//拿起右边筷子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            wait(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>])；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            eating；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//放下左边筷子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            signal(chopstick[i])；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//放下右边筷子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            thinking；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">coend</span></pre></td></tr></table></figure><p>问题在于如果所有人都拿着左边筷子，就陷入了死锁。</p><p>解决办法法很多：</p><ul><li>至多允许4个哲学家同时取左边的筷子，这样能至少保证一个哲学家能就餐，并在用毕后释放他用过的两只筷子，从而使更多的哲学家能够进餐；</li><li>仅当哲学家左右两只筷子均可用时（AND信号量机制），才允许他拿起筷子进餐；</li><li>规定奇数号哲学家先拿左边筷子，然后再拿右边筷子；而偶数号哲学家先拿右边筷子，然后再拿左边筷子；</li><li>规定每个哲学家先拿序号小的筷子——按序号分配。</li></ul><p>以第一种方法为例，再加一个关于左边筷子能否取用的信号量即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>],S；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">chopstick[<span class="number">0</span>].value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">chopstick[<span class="number">1</span>].value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">chopstick[<span class="number">2</span>].value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">chopstick[<span class="number">3</span>].value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">chopstick[<span class="number">4</span>].value=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">S.value=<span class="number">4</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cobegin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process  <span class="title">Pi</span><span class="params">()</span><span class="comment">//(i = 0，1，2，3，4)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//能否拿筷子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            wait(S);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//拿起左边筷子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            wait(chopstick[i])；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//拿起右边筷子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            wait(chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>])；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            eating；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//放下左边筷子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            signal(chopstick[i])；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//放下右边筷子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>])；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//释放能否拿筷子标记</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            signal(S);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            thinking；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">coend</span></pre></td></tr></table></figure><h3 id="读者-写者问题">读者-写者问题</h3><p>一个数据文件或记录，可被多个进程共享，我们把只要求读该文件的进程称为“读者进程”，其他进程称为“写者进程”。显然，只要有一个写者进程正访问文件，就不能有其它进程访问。</p><p>因此可设置一个初值为1的信号量，表示当前允许的写者数，同时用一个普通变量记录读者数。由于可能同时有多个进程尝试访问读者数，还需为这个访问设置一个信号量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">semaphore Wmutex，Rmutex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Rcounter = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Wmutex.value=Rmutex.value=<span class="number">1</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">cobegin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process <span class="title">Readeri</span><span class="params">()</span><span class="comment">//(i = 1，2，…)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        wait(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(Rcounter==<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//等写者信号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            wait(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        Rcounter = Rcounter + <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        signal(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        …</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        Reading;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        …</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        wait(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        Rcounter = Rcounter – <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(Rcounter==<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            signal(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        signal(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process <span class="title">Writerj</span><span class="params">()</span><span class="comment">//(j=1，2，…)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        wait(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        Writing;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        signal(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">coend</span></pre></td></tr></table></figure><p>问题在于，如果一个读者正在读时来了写者，然后读者还没读完，又来一个读者。现在假设第一个读者读完了，但计数器显示仍有读者，于是写者标记未被释放，新读者反而早于更早来的写者访问文件。一直如此则写者将被饿死。</p><p>考虑再增加一个信号量，如果有写者到达，则晚于此写者的读者将无法访问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">semaphore Wmutex,Rmutex,w;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Rcounter = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Wmutex.value=Rmutex.value=w.value=<span class="number">1</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">cobegin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process <span class="title">Readeri</span><span class="params">()</span><span class="comment">//(i = 1，2，…)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//有写者的话之后的w就不能访问了</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        wait(w);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        wait(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(Rcounter==<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//等写者信号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            wait(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        Rcounter = Rcounter + <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        signal(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        signal(w);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        …</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        Reading;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        …</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        wait(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        Rcounter = Rcounter – <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(Rcounter==<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            signal(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        signal(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process <span class="title">Writerj</span><span class="params">()</span><span class="comment">//(j=1，2，…)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//有写者的话之后的w就不能访问了</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        wait(w);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        wait(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        Writing;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        signal(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        signal(w);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">coend</span></pre></td></tr></table></figure><p>这个算法解决了读者读完后除非已经没有读者否则被唤醒的一定是读者的问题。现在在写者写完后被唤醒的不一定是读者或写者，随缘。如果想要被唤醒的一定是写者，可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wmutex用于写进程互斥访问Wcounter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wsem用于封锁有写者时封锁后续写进程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">semaphore Wmutex=Wsem= <span class="number">1</span>；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rmutex用于读进程互斥访问Rcounter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rsem1用于在有写者时封锁后续第一个读者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rsem2用于在Rsem1起效后封锁后续所有读者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">semaphore Rmutex=Rsem1=Rsem2=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Rcounter = Wconuter = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cobegin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function">process <span class="title">Reader_i</span> <span class="params">(i = <span class="number">1</span>，<span class="number">2</span>，…)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//是否是写者后的读者后的读者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        wait(Rsem2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//是否是写者后的读者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        wait(Rsem1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//是否有人正在访问计数器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        wait(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        Rcounter = Rcounter + <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//如果当前仅有自己一个读者在访问文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//则判断是否有写者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(Rcounter==<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            wait(Wsem);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        signal(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        signal(Rsem1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        signal(Rsem2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        Reading;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        wait(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        Rcounter = Rcounter - <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//如果当前仅有自己一个读者在访问文件并且刚刚关上</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">//则判断是否有写者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(Rcounter==<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            signal(Wsem);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        signal(Rmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="function">process <span class="title">Writer_j</span> <span class="params">(j=<span class="number">1</span>，<span class="number">2</span>，…)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        wait(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        Wcounter++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (Wcounter==<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        wait(Rsem1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        signal(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        wait(Wsem);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        Writing( );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        signal(Wsem);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        wait(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        Wcounter=Wcounter<span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (Wcounter==<span class="number">0</span>) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            signal(Rsem1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        signal(Wmutex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">coend</span></pre></td></tr></table></figure><h1 id="进程通信">进程通信</h1><p>信号量机制效率太低了，且对用户不透明，因此需要设计允许透明地传送大量信息的方式，主要有：</p><ul><li>共享存储器通信，类似生产者消费者问题中的缓冲区，但效率更高；</li><li>管道通信（共享文件）；</li><li>消息传递通信，以上两个只适合单机，这个还适合网络通信：<ul><li>直接通信方式</li><li>间接通信方式——信箱通信</li></ul></li><li>客户机-服务器系统，仅适合网络通信。</li></ul><h1 id="作业与进程的调度">作业与进程的调度</h1><p>就绪队列用中有许多进程，然而穷比只得起四核CPU，该让哪个进程先跑呢？要靠进程调度或作业调度。调度时有以下几种级别：</p><p>（作业是比程序更广泛的概念，但仍可以使用类似PCB的方式描述，称为JCB。类似进程地，作业也有一些基本状态，收容、运行和完成状态。）</p><ul><li>高级调度，或者叫作业调度，决定把哪些作业由外存调至内存，要考虑调几个、分别是谁；</li><li>中级调度，或者叫内存调度，主要负责进程的挂起和激活；</li><li>低级调度，或者叫进程调度，决定哪个进程使用处理机，分抢占式——某个进程跑着跑着可以被其它进程顶下去——和非抢占式。</li></ul><p>我们希望有合适的调度算法，使处理机利用率（有效工作时间和有效工作时间加空闲时间之比）和I/O设备利用率尽可能高且对各进程公平、一些重要进程能立即被强制执行。</p><p>有以下几种常用调度算法：</p><h2 id="先来先服务fcfs">先来先服务（FCFS）</h2><p>顾名思义。适合有很多耗时比较长、没什么I/O的作业或进程的情况。非抢占式。</p><h2 id="短作业优先短进程优先sjfspf">短作业优先/短进程优先（SJF/SPF）</h2><p>顾名思义。可以降低平均周转时间（到达到完成的时间），但长作业可能被饿死。而且用户给的预计运行时间未必准。非抢占式。</p><h2 id="优先级调度psa">优先级调度（PSA）</h2><p>前两种算法的加强版。即前两种算法分别是单纯以到达时间或作业预计时间为优先级。如果做成抢占式的，还可以用在实时系统中。</p><p>可以静态或动态地确定优先级，通过进程类型（是I/O还是别的什么？）、资源耗费（包括时间内存等）和用户的指定等。动态确定时，可以提高一个等了很久的进程的优先级，慢慢降低正在执行的进程的优先级等。</p><h2 id="高响应比优先调度算法hrrn">高响应比优先调度算法（HRRN）</h2><p>一种求动态优先级的方式。等待时间与要求服务时间之和与要求服务时间的比例作为优先级，谁高调用谁。</p><h2 id="基于时间片的轮转调度法rr">基于时间片的轮转调度法（RR）</h2><p>按FCFS排列就绪队列，当处理机空闲时，将处理机分配给队首进程，等一个时间片过去，将正处理的进程排至队尾。</p><h2 id="多级反馈队列调度算法mfq">多级反馈队列调度算法（MFQ）</h2><p>设置多个优先级不同的就绪队列，每个队列时间片长度不同，优先级越高的队列时间片越长。当一个进程到达时，将它加入优先级最高的队列的末尾。处理机执行完时间片后如果当前进程未完成，则放到低一级的队列最后。最低优先级的队列内部使用RR算法调度。当最高优先级的队列为空时才执行低一级优先的队列，依次类推。如果正在执行时有高于当前进程优先级的进程到达（即执行非最高优先级进程时有进程到达），则将当前执行的进程放至原优先级对应队列的队尾，首先执行新来的进程。</p><p>这种算法无需知道预期运行时间，比较NB。</p><h2 id="示例">示例</h2><p>有一个具有两道作业的批处理系统（最多可有两道作业同时装入内存执行）,作业调度采用计算时间短的作业优先调度算法,进程调度采用以优先数为基础的抢占式调度算法,今有如下作业序列（表中所列作业优先数即为进程优先数,数值越小优先级越高）:</p><table><thead><tr class="header"><th>作业名</th><th>到达时间</th><th>估计运行时间</th><th>优先数</th></tr></thead><tbody><tr class="odd"><td>J1</td><td>10:10</td><td>20分钟</td><td>5</td></tr><tr class="even"><td>J2</td><td>10:20</td><td>30分钟</td><td>3</td></tr><tr class="odd"><td>J3</td><td>10:30</td><td>25分钟</td><td>4</td></tr><tr class="even"><td>J4</td><td>10:50</td><td>20分钟</td><td>6</td></tr></tbody></table><p>显然J1在10:10先到，装入内存并运行了10min，10:20J2到达，装入内存，由于优先级更高，抢占J1直到执行完毕即10:50，此时J3和J4都到达了。作业调度遵循短作业优先，即J4又被装入内存，其优先级低于J1，于是J1执行完毕。此时是11:00，J3也被装入内存，其优先级更高，到11:25J3执行完毕，J4最后执行。</p><h1 id="死锁">死锁</h1><blockquote><p>一组进程处于死锁状态是指：如果在一个进程集合中的每一个进程都在等待只能由该集合中的其它一个进程才能引发的事件，则称一组进程或系统发生了死锁。（孙钟秀主编《操作系统教程》）</p></blockquote><p>之前哲学家进餐问题有提过。主要出现原因是多个进程对某类资源有竞争、这些进程每次还不止要一个资源、且没规定好它们访问资源的顺序，就可能出现死锁。典型的情况是进程访问了一个资源，又去访问另一个，但另一个不可用，于是他在那等，又抓着已经拿到的资源不放手，导致产生一个循环，一个进程拿着另一个进程要的资源不放手，他要的资源又被另一个进程拿着不放手……</p><h2 id="预防">预防</h2><p>使临界资源不再临界，或一次性分配好资源而不是一个一个给，或允许进程释放已抢占的资源，或指定好访问顺序即可。</p><p>第一种情况限制太大，一般还是想让临界资源互斥的；第二种情况会拖慢系统；第三种方式不好实现；第四种方式规定太死，实际使用哪能这么巧有个顺序。</p><h2 id="避免">避免</h2><p>既然从原理上预防死锁不太可行，于是考虑在分配资源时动态地预防。</p><p>有些时候是不会进入死锁的，例如有三个进程，分别要10、4、9个资源，已分配5、2、2个，还剩3个。这时可以分2个给第二个进程让它跑完，还剩6个；再分5个给第一个进程，最后再满足最后一个进程。这时是安全的。</p><p>有些时候会进入死锁，例如上例中的三个进程，分别要10、4、10个资源，已分配5、2、3个，还剩2个。这时可以分2个给第二个进程让它跑完，还剩4个；无论如何也找不到可以让剩下两个进程跑起来的方法了。这是不安全的。</p><p>有个银行家算法可对此进行判断，其设计之初是为了防止银行的钱（剩余资源）不够放贷（进程请求资源）的：</p><p>对有n个进程m类资源的情况，设置一个有m个元素的数组Availabe记录每个资源的剩余可用数，用三个n*m的矩阵Max、Allocation和Need表示每个进程对每种资源的需求数、已有数和还需要的数。</p><p>一个进程发出资源请求Request后进行如下检查：</p><ol type="1"><li>Requset中的元素是否不大于Need中对应元素？否则报错；</li><li>Request中的元素是否不大于Available中对应元素？否则让进程等待；</li><li>尝试模拟分配完成的情况，即Avalible中元素减去Request中对应元素，Allocation中元素加上Request中对应元素，Need中元素减去Request中对应元素。</li><li>复制一个Available，名为Work。即分配完后的剩余资源数。建立一个布尔型数组Finish，对应每个进程的完成情况，初值均为false。</li><li>找哪个尚未Finish的进程的Need小于等于Work，有的话意味着剩余资源足够它执行完并释放。假装释放了，把被占用的资源Alloction加到Work上，标记这个进程为完成。重复，直到所有进程都完成，或没有进程可以被完成。</li><li>如果都能完成，说明安全，可以分配；否则不能分配。</li></ol><p>例如现有5个进程P0~P4，三类资源A、B和C分别共有10、5和7个，当前资源分配如下：</p><table><thead><tr class="header"><th style="text-align:center"></th><th style="text-align:center">Max A/B/C</th><th style="text-align:center">Allocation A/B/C</th><th style="text-align:center">Need A/B/C</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">P0</td><td style="text-align:center">7/5/3</td><td style="text-align:center">0/1/0</td><td style="text-align:center">7/4/3</td></tr><tr class="even"><td style="text-align:center">P1</td><td style="text-align:center">3/2/2</td><td style="text-align:center">2/0/0</td><td style="text-align:center">1/2/2</td></tr><tr class="odd"><td style="text-align:center">P2</td><td style="text-align:center">9/0/2</td><td style="text-align:center">3/0/2</td><td style="text-align:center">6/0/0</td></tr><tr class="even"><td style="text-align:center">P3</td><td style="text-align:center">2/2/2</td><td style="text-align:center">2/1/1</td><td style="text-align:center">0/1/1</td></tr><tr class="odd"><td style="text-align:center">P4</td><td style="text-align:center">4/3/3</td><td style="text-align:center">0/0/2</td><td style="text-align:center">4/3/1</td></tr></tbody></table><p>也就是说剩余如下：</p><table><thead><tr class="header"><th style="text-align:center">Avalibale A/B/C</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">3/3/2</td></tr></tbody></table><p>比方说现在P1请求<code>Request1(1/0/2)</code>，先与Need比较，OK；再与Avalible比较，OK。于是模拟分配。</p><table><thead><tr class="header"><th style="text-align:center"></th><th style="text-align:center">Max A/B/C</th><th style="text-align:center">Allocation A/B/C</th><th style="text-align:center">Need A/B/C</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">P0</td><td style="text-align:center">7/5/3</td><td style="text-align:center">0/1/0</td><td style="text-align:center">7/4/3</td></tr><tr class="even"><td style="text-align:center">P1</td><td style="text-align:center">3/2/2</td><td style="text-align:center"><em><strong>3/0/2</strong></em></td><td style="text-align:center"><em><strong>0/2/0</strong></em></td></tr><tr class="odd"><td style="text-align:center">P2</td><td style="text-align:center">9/0/2</td><td style="text-align:center">3/0/2</td><td style="text-align:center">6/0/0</td></tr><tr class="even"><td style="text-align:center">P3</td><td style="text-align:center">2/2/2</td><td style="text-align:center">2/1/1</td><td style="text-align:center">0/1/1</td></tr><tr class="odd"><td style="text-align:center">P4</td><td style="text-align:center">4/3/3</td><td style="text-align:center">0/0/2</td><td style="text-align:center">4/3/1</td></tr></tbody></table><p>剩余如下：</p><table><thead><tr class="header"><th style="text-align:center">Avalibale A/B/C</th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><em><strong>2/3/0</strong></em></td></tr></tbody></table><p>接下来检查安全性。</p><p>最早的Work就是Avaliable，P0的Need太多，P1的够，于是有：</p><table><thead><tr class="header"><th style="text-align:center"></th><th style="text-align:center">Work A/B/C</th><th style="text-align:center">Allocation A/B/C</th><th style="text-align:center">Need A/B/C</th><th style="text-align:center">Work+Allocation A/B/C</th><th style="text-align:center">Finish</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">P1</td><td style="text-align:center">2/3/0</td><td style="text-align:center">3/0/2</td><td style="text-align:center">0/2/0</td><td style="text-align:center">5/3/2</td><td style="text-align:center">true</td></tr></tbody></table><p>现在我们的资源变成5、3和2了，P0仍然不够，P2也不够，P3够了，于是：</p><table><thead><tr class="header"><th style="text-align:center"></th><th style="text-align:center">Work A/B/C</th><th style="text-align:center">Allocation A/B/C</th><th style="text-align:center">Need A/B/C</th><th style="text-align:center">Work+Allocation A/B/C</th><th style="text-align:center">Finish</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">P1</td><td style="text-align:center">2/3/0</td><td style="text-align:center">3/0/2</td><td style="text-align:center">0/2/0</td><td style="text-align:center">5/3/2</td><td style="text-align:center">true</td></tr><tr class="even"><td style="text-align:center">P3</td><td style="text-align:center">5/3/2</td><td style="text-align:center">2/1/1</td><td style="text-align:center">0/1/1</td><td style="text-align:center">7/4/3</td><td style="text-align:center">true</td></tr></tbody></table><p>依此类推发现所有进程都OK，于是可以分配资源。</p><h2 id="检测">检测</h2><p>资源分配图。</p><h2 id="解除">解除</h2><p>回收资源/撤销进程。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>Post author:</strong> Mechanical_Mind</li><li class="post-copyright-link"> <strong>:</strong> <a href="/http:/mechanicalmind.cn/posts/4c0c7f47.html" title="操作系统・壹・处理机管理">http://mechanicalmind.cn/posts/4c0c7f47.html</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag"># 进程</a> <a href="/tags/%E6%AD%BB%E9%94%81/" rel="tag"># 死锁</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/dca81ae.html" rel="prev" title="apk文件的反编译"><i class="fa fa-chevron-left"></i> apk文件的反编译</a></div><div class="post-nav-item"> <a href="/posts/7d897d14.html" rel="next" title="组成原理・〇・总论">组成原理・〇・总论<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NjgzMS8yMzMzMg=="></div></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#顺序与并发执行的描述"><span class="nav-number">1.</span> <span class="nav-text">顺序与并发执行的描述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程的基本概念"><span class="nav-number">2.</span> <span class="nav-text">进程的基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#os对进程的描述"><span class="nav-number">3.</span> <span class="nav-text">OS对进程的描述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程控制"><span class="nav-number">4.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建进程create"><span class="nav-number">4.1.</span> <span class="nav-text">创建进程（Create）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终止进程"><span class="nav-number">4.2.</span> <span class="nav-text">终止进程（）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的阻塞与唤醒blockwakeup"><span class="nav-number">4.3.</span> <span class="nav-text">进程的阻塞与唤醒（block/wakeup）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的挂起与激活suspendactive"><span class="nav-number">4.4.</span> <span class="nav-text">进程的挂起与激活（suspend/active）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程同步"><span class="nav-number">5.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常用进程同步机制"><span class="nav-number">5.1.</span> <span class="nav-text">常用进程同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#硬件同步机制"><span class="nav-number">5.1.1.</span> <span class="nav-text">硬件同步机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量机制"><span class="nav-number">5.1.2.</span> <span class="nav-text">信号量机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管程机制"><span class="nav-number">5.1.3.</span> <span class="nav-text">管程机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经典进程同步问题"><span class="nav-number">5.2.</span> <span class="nav-text">经典进程同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者-消费者问题"><span class="nav-number">5.2.1.</span> <span class="nav-text">生产者-消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哲学家就餐问题"><span class="nav-number">5.2.2.</span> <span class="nav-text">哲学家就餐问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读者-写者问题"><span class="nav-number">5.2.3.</span> <span class="nav-text">读者-写者问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程通信"><span class="nav-number">6.</span> <span class="nav-text">进程通信</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#作业与进程的调度"><span class="nav-number">7.</span> <span class="nav-text">作业与进程的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#先来先服务fcfs"><span class="nav-number">7.1.</span> <span class="nav-text">先来先服务（FCFS）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#短作业优先短进程优先sjfspf"><span class="nav-number">7.2.</span> <span class="nav-text">短作业优先/短进程优先（SJF/SPF）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优先级调度psa"><span class="nav-number">7.3.</span> <span class="nav-text">优先级调度（PSA）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高响应比优先调度算法hrrn"><span class="nav-number">7.4.</span> <span class="nav-text">高响应比优先调度算法（HRRN）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于时间片的轮转调度法rr"><span class="nav-number">7.5.</span> <span class="nav-text">基于时间片的轮转调度法（RR）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多级反馈队列调度算法mfq"><span class="nav-number">7.6.</span> <span class="nav-text">多级反馈队列调度算法（MFQ）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例"><span class="nav-number">7.7.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#死锁"><span class="nav-number">8.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#预防"><span class="nav-number">8.1.</span> <span class="nav-text">预防</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免"><span class="nav-number">8.2.</span> <span class="nav-text">避免</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测"><span class="nav-number">8.3.</span> <span class="nav-text">检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解除"><span class="nav-number">8.4.</span> <span class="nav-text">解除</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Mechanical_Mind" src="/images/logo512.jpg"><p class="site-author-name" itemprop="name">Mechanical_Mind</p><div class="site-description" itemprop="description">敲键盘 按快门 巡星空</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">49</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">38</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i> RSS</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://duckkkkky.github.io/I-just-don-t-know-where-to-go/" title="https:&#x2F;&#x2F;duckkkkky.github.io&#x2F;I-just-don-t-know-where-to-go&#x2F;" rel="noopener" target="_blank">duckkkkky</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Mechanical_Mind</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Symbols count total:</span> <span title="Symbols count total">193k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span class="post-meta-item-text">Reading time total &asymp;</span> <span title="Reading time total">2:56</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0</div> <span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>
NexT.utils.loadComments(() => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:200,height:290},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>